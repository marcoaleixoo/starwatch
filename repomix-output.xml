This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
releases/
  v0.1.0.md
src/
  assets/
    metalgrid3-bl/
      About these PBR files.txt
      desktop.ini
  fps/
    core/
      hangarTextures.ts
      playerController.ts
      sceneContext.ts
    lighting/
      rectAreaLamp.ts
      shadowNetwork.ts
    placement/
      surfaces/
        floorSurface.ts
        placementSurface.ts
        surfaceRegistry.ts
        types.ts
        wallSurface.ts
      tools/
        deleteTool.ts
        index.ts
        lampTool.ts
        wallTool.ts
      ghosts.ts
      lampBuilder.ts
      placementController.ts
      placementSolver.ts
      placementTypes.ts
      wallBuilder.ts
    state/
      playerModules.ts
      playerPersistence.ts
      playerState.ts
      playerStore.ts
      shipHydrator.ts
      shipPersistence.ts
      shipState.ts
      shipStore.ts
    utils/
      math.ts
    constants.ts
    ShipBuilderCanvas.tsx
    types.ts
  legacy/
    game/
      Game.ts
      world.ts
    hal/
      halLLM.ts
    ui/
      Chat.tsx
      MonacoEditor.tsx
      ScriptsPanel.tsx
    App.tsx
    main.tsx
  App.tsx
  env.d.ts
  main.tsx
.gitignore
AGENTS.md
index.html
MANIFESTO.md
package.json
tsconfig.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/assets/metalgrid3-bl/About these PBR files.txt">
These texture files were created by FreePBR.com and may be used freely in your video games and 3d work at no cost. They may not however be redistributed on other websites or anywhere else other than FreePBR.com. We think that is more than fair. :) We also would greatly appreciate it if some sorrt of credit was given if you do indeed use these textures in a published game. Other than that, keep on creating and have fun. :)
</file>

<file path="src/assets/metalgrid3-bl/desktop.ini">
[.ShellClassInfo]
InfoTip=This folder is shared online.
IconFile=C:\Program Files\Google\Drive\googledrivesync.exe
IconIndex=16
</file>

<file path="src/fps/core/hangarTextures.ts">
import { PBRMaterial, Scene, Texture } from "babylonjs";
import armorAlbedoUrl from "../../assets/armor-plating1-bl/armor-plating1_albedo.png?url";
import armorNormalUrl from "../../assets/armor-plating1-bl/armor-plating1_normal-ogl.png?url";
import armorRoughnessUrl from "../../assets/armor-plating1-bl/armor-plating1_roughness.png?url";
import armorMetallicUrl from "../../assets/armor-plating1-bl/armor-plating1_metallic.png?url";
import armorAoUrl from "../../assets/armor-plating1-bl/armor-plating1_ao.png?url";
import metalgridAlbedoUrl from "../../assets/metalgrid3-bl/metalgrid3_basecolor.png?url";
import metalgridNormalUrl from "../../assets/metalgrid3-bl/metalgrid3_normal-ogl.png?url";
import metalgridRoughnessUrl from "../../assets/metalgrid3-bl/metalgrid3_roughness.png?url";
import metalgridMetallicUrl from "../../assets/metalgrid3-bl/metalgrid3_metallic.png?url";
import metalgridAoUrl from "../../assets/metalgrid3-bl/metalgrid3_AO.png?url";

export interface HangarTextureSet {
  albedo: Texture;
  normal: Texture;
  roughness: Texture;
  metallic: Texture;
  ao: Texture;
}

type HangarTextureKey = "armor" | "metal";

interface TextureDefinition {
  albedo: string;
  normal: string;
  roughness: string;
  metallic: string;
  ao: string;
}

const TEXTURE_DEFINITIONS: Record<HangarTextureKey, TextureDefinition> = {
  armor: {
    albedo: armorAlbedoUrl,
    normal: armorNormalUrl,
    roughness: armorRoughnessUrl,
    metallic: armorMetallicUrl,
    ao: armorAoUrl,
  },
  metal: {
    albedo: metalgridAlbedoUrl,
    normal: metalgridNormalUrl,
    roughness: metalgridRoughnessUrl,
    metallic: metalgridMetallicUrl,
    ao: metalgridAoUrl,
  },
};

const textureCache = new WeakMap<Scene, Map<HangarTextureKey, HangarTextureSet>>();

function createTexture(scene: Scene, url: string): Texture {
  return new Texture(url, scene, false, true, Texture.TRILINEAR_SAMPLINGMODE);
}

function createTextureSet(scene: Scene, key: HangarTextureKey): HangarTextureSet {
  const definition = TEXTURE_DEFINITIONS[key];
  const albedo = createTexture(scene, definition.albedo);
  const normal = createTexture(scene, definition.normal);
  const roughness = createTexture(scene, definition.roughness);
  const metallic = createTexture(scene, definition.metallic);
  const ao = createTexture(scene, definition.ao);

  [albedo, normal, roughness, metallic, ao].forEach((texture) => {
    texture.wrapU = Texture.WRAP_ADDRESSMODE;
    texture.wrapV = Texture.WRAP_ADDRESSMODE;
  });
  normal.invertZ = true;
  normal.gammaSpace = false;

  return { albedo, normal, roughness, metallic, ao };
}

export function getHangarTextureSet(scene: Scene, key: HangarTextureKey): HangarTextureSet {
  let map = textureCache.get(scene);
  if (!map) {
    map = new Map<HangarTextureKey, HangarTextureSet>();
    textureCache.set(scene, map);
  }
  let set = map.get(key);
  if (!set) {
    set = createTextureSet(scene, key);
    map.set(key, set);
  }
  return set;
}

export function applyHangarTextures(
  material: PBRMaterial,
  textures: HangarTextureSet,
  tiling: { u: number; v: number },
) {
  disposeHangarMaterial(material);

  const albedo = textures.albedo.clone();
  const normal = textures.normal.clone();
  const metallic = textures.metallic.clone();
  const ao = textures.ao.clone();

  [albedo, normal, metallic, ao].forEach((texture) => {
    texture.uScale = tiling.u;
    texture.vScale = tiling.v;
    texture.wrapU = Texture.WRAP_ADDRESSMODE;
    texture.wrapV = Texture.WRAP_ADDRESSMODE;
  });

  material.albedoTexture = albedo;
  material.bumpTexture = normal;
  material.metallicTexture = metallic;
  material.ambientTexture = ao;

  const metadata = (material.metadata as { hangarTextureClones?: Texture[] } | undefined) ?? {};
  metadata.hangarTextureClones = [albedo, normal, metallic, ao];
  material.metadata = metadata;
}

export function disposeHangarMaterial(material: PBRMaterial) {
  const metadata = (material.metadata as { hangarTextureClones?: Texture[] } | undefined) ?? {};
  metadata.hangarTextureClones?.forEach((texture) => {
    texture.dispose();
  });
  if (metadata.hangarTextureClones) {
    metadata.hangarTextureClones = [];
  }
  material.metadata = metadata;
}

export function disposeHangarTextureCache(scene: Scene) {
  const map = textureCache.get(scene);
  if (!map) {
    return;
  }
  map.forEach((set) => {
    set.albedo.dispose();
    set.normal.dispose();
    set.roughness.dispose();
    set.metallic.dispose();
    set.ao.dispose();
  });
  map.clear();
  textureCache.delete(scene);
}
</file>

<file path="src/fps/core/playerController.ts">
import { KeyboardEventTypes, Quaternion, UniversalCamera, Vector3, type Scene } from "babylonjs";
import { CAMERA_SETTINGS, INPUT_KEYS } from "../constants";
import type { PlayerStore } from "../state/playerStore";
import type {
  PlayerState,
  PlayerTransformState,
  QuaternionSerialized,
  Vector3Serialized,
} from "../state/playerState";
import { serializeQuaternion, serializeVector3 } from "../state/playerState";

const KEYBOARD_MOVE_MAP: Record<string, { axis: "x" | "z"; direction: number }> = {
  KeyW: { axis: "z", direction: 1 },
  ArrowUp: { axis: "z", direction: 1 },
  KeyS: { axis: "z", direction: -1 },
  ArrowDown: { axis: "z", direction: -1 },
  KeyA: { axis: "x", direction: -1 },
  ArrowLeft: { axis: "x", direction: -1 },
  KeyD: { axis: "x", direction: 1 },
  ArrowRight: { axis: "x", direction: 1 },
};

const CROUCH_KEYS = new Set(["ControlLeft", "ControlRight"]);
const JUMP_KEYS = new Set(["Space"]);

interface PlayerControllerOptions {
  scene: Scene;
  canvas: HTMLCanvasElement;
  store: PlayerStore;
}

export interface PlayerController {
  camera: UniversalCamera;
  dispose(): void;
  teleport(position: Vector3Serialized, orientation?: QuaternionSerialized): void;
  setCutsceneLock(locked: boolean): void;
}

export function createPlayerController(options: PlayerControllerOptions): PlayerController {
  const { scene, canvas, store } = options;
  const engine = scene.getEngine();
  const initialState = store.getSnapshot();

  const camera = new UniversalCamera(
    "fpCam",
    new Vector3(
      initialState.transform.position.x,
      initialState.transform.position.y || CAMERA_SETTINGS.eyeLevel,
      initialState.transform.position.z,
    ),
    scene,
  );
  camera.minZ = CAMERA_SETTINGS.minZ;
  camera.maxZ = CAMERA_SETTINGS.maxZ;
  camera.speed = CAMERA_SETTINGS.speed;
  camera.angularSensibility = CAMERA_SETTINGS.angularSensibility;
  camera.inertia = CAMERA_SETTINGS.inertia;
  camera.applyGravity = true;
  camera.checkCollisions = true;
  camera.ellipsoid = new Vector3(
    CAMERA_SETTINGS.ellipsoid.x,
    CAMERA_SETTINGS.ellipsoid.y,
    CAMERA_SETTINGS.ellipsoid.z,
  );
  camera.ellipsoidOffset = new Vector3(
    CAMERA_SETTINGS.ellipsoidOffset.x,
    CAMERA_SETTINGS.ellipsoidOffset.y,
    CAMERA_SETTINGS.ellipsoidOffset.z,
  );
  camera.keysUp.push(INPUT_KEYS.move.forward);
  camera.keysLeft.push(INPUT_KEYS.move.left);
  camera.keysDown.push(INPUT_KEYS.move.backward);
  camera.keysRight.push(INPUT_KEYS.move.right);

  const initialQuaternion = new Quaternion(
    initialState.transform.orientation.x,
    initialState.transform.orientation.y,
    initialState.transform.orientation.z,
    initialState.transform.orientation.w,
  );
  applyQuaternionToCamera(camera, initialQuaternion);

  let controlsAttached = false;
  const attachControls = () => {
    if (controlsAttached) {
      return;
    }
    camera.attachControl(canvas, true);
    controlsAttached = true;
  };
  const detachControls = () => {
    if (!controlsAttached) {
      return;
    }
    camera.detachControl();
    controlsAttached = false;
    if (document.pointerLockElement === canvas) {
      try {
        document.exitPointerLock();
      } catch {
        // ignore pointer lock failures
      }
    }
  };

  if (!initialState.input.cameraLocked && !initialState.input.movementLocked) {
    attachControls();
  }

  const actions = store.getActions();
  let isPushingFromCamera = false;
  let lastTransformSignature = transformSignature(initialState.transform);
  let lastFramePosition = camera.position.clone();

  const pointerLockListener = () => {
    const pointerLocked = document.pointerLockElement === canvas;
    actions.patchInput({ pointerLocked });
  };
  document.addEventListener("pointerlockchange", pointerLockListener);

  const pressedKeys = new Set<string>();
  let lastMovementIntent = initialState.movementIntent;

  const updateMovementIntent = () => {
    const move = { x: 0, z: 0 };
    pressedKeys.forEach((code) => {
      const mapping = KEYBOARD_MOVE_MAP[code];
      if (!mapping) {
        return;
      }
      move[mapping.axis] += mapping.direction;
    });

    const length = Math.hypot(move.x, move.z);
    if (length > 1e-3) {
      move.x /= Math.max(1, length);
      move.z /= Math.max(1, length);
    } else {
      move.x = 0;
      move.z = 0;
    }

    const sprint = INPUT_KEYS.sprint.some((code) => pressedKeys.has(code));
    const jump = Array.from(JUMP_KEYS).some((code) => pressedKeys.has(code));
    const crouch = Array.from(CROUCH_KEYS).some((code) => pressedKeys.has(code));

    if (
      almostEqual(move.x, lastMovementIntent.move.x) &&
      almostEqual(move.z, lastMovementIntent.move.z) &&
      sprint === lastMovementIntent.sprint &&
      jump === lastMovementIntent.jump &&
      crouch === lastMovementIntent.crouch
    ) {
      return;
    }

    const next = {
      move,
      sprint,
      jump,
      crouch,
    };
    actions.setMovementIntent({
      move,
      sprint,
      jump,
      crouch,
    });
    lastMovementIntent = next;
  };

  const keyboardObserver = scene.onKeyboardObservable.add((info) => {
    const event = info.event;
    if (info.type === KeyboardEventTypes.KEYDOWN) {
      pressedKeys.add(event.code);
    } else if (info.type === KeyboardEventTypes.KEYUP) {
      pressedKeys.delete(event.code);
    }
    updateMovementIntent();
  });

  const applyInputState = (state: PlayerState) => {
    const { cameraLocked, movementLocked } = state.input;
    if (cameraLocked || movementLocked) {
      detachControls();
    } else {
      attachControls();
    }
  };

  const subscription = store.subscribe((state) => {
    applyInputState(state);
    lastMovementIntent = state.movementIntent;

    const signature = transformSignature(state.transform);
    if (isPushingFromCamera) {
      lastTransformSignature = signature;
      return;
    }
    if (signature === lastTransformSignature) {
      return;
    }
    lastTransformSignature = signature;
    applyTransformToCamera(camera, state.transform);
    lastFramePosition = camera.position.clone();
  });

  const transformObserver = scene.onBeforeRenderObservable.add(() => {
    const deltaSeconds = engine.getDeltaTime() / 1000;
    const currentPosition = camera.position;
    const velocity = deltaSeconds > 1e-4 ? currentPosition.subtract(lastFramePosition).scale(1 / deltaSeconds) : Vector3.Zero();
    lastFramePosition = currentPosition.clone();

    if (Math.abs(camera.rotation.z) > 1e-4) {
      camera.rotation.z = 0;
    }
    const quaternion = Quaternion.RotationYawPitchRoll(
      camera.rotation.y,
      camera.rotation.x,
      0,
    );

    const nextTransform: PlayerTransformState = {
      position: serializeVector3(currentPosition.x, currentPosition.y, currentPosition.z),
      orientation: serializeQuaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w),
      velocity: serializeVector3(velocity.x, velocity.y, velocity.z),
    };

    const signature = transformSignature(nextTransform);
    if (signature === lastTransformSignature) {
      return;
    }
    isPushingFromCamera = true;
    actions.setTransform(nextTransform);
    isPushingFromCamera = false;
    lastTransformSignature = signature;
  });

  const teleport = (position: Vector3Serialized, orientation?: QuaternionSerialized) => {
    const quaternion = orientation
      ? new Quaternion(orientation.x, orientation.y, orientation.z, orientation.w)
      : Quaternion.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, camera.rotation.z);

    applyTransformToCamera(camera, {
      position,
      orientation: orientation
        ? orientation
        : {
            x: quaternion.x,
            y: quaternion.y,
            z: quaternion.z,
            w: quaternion.w,
          },
      velocity: serializeVector3(0, 0, 0),
    });
    lastFramePosition = camera.position.clone();
    const sanitized = Quaternion.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, 0);
    const transform: PlayerTransformState = {
      position: serializeVector3(position.x, position.y, position.z),
      orientation: serializeQuaternion(sanitized.x, sanitized.y, sanitized.z, sanitized.w),
      velocity: serializeVector3(0, 0, 0),
    };
    isPushingFromCamera = true;
    actions.setTransform(transform);
    isPushingFromCamera = false;
    lastTransformSignature = transformSignature(transform);
  };

  const setCutsceneLock = (locked: boolean) => {
    actions.patchInput({
      movementLocked: locked,
      cameraLocked: locked,
    });
    if (locked) {
      detachControls();
    } else {
      attachControls();
    }
  };

  const dispose = () => {
    document.removeEventListener("pointerlockchange", pointerLockListener);
    scene.onBeforeRenderObservable.remove(transformObserver);
    scene.onKeyboardObservable.remove(keyboardObserver);
    subscription();
    if (controlsAttached) {
      detachControls();
    }
    camera.dispose();
  };

  return {
    camera,
    dispose,
    teleport,
    setCutsceneLock,
  };
}

function transformSignature(transform: PlayerTransformState): string {
  return [
    transform.position.x,
    transform.position.y,
    transform.position.z,
    transform.orientation.x,
    transform.orientation.y,
    transform.orientation.z,
    transform.orientation.w,
    transform.velocity.x,
    transform.velocity.y,
    transform.velocity.z,
  ].join("|");
}

function applyTransformToCamera(camera: UniversalCamera, transform: PlayerTransformState) {
  camera.position.set(transform.position.x, transform.position.y, transform.position.z);
  const quaternion = new Quaternion(
    transform.orientation.x,
    transform.orientation.y,
    transform.orientation.z,
    transform.orientation.w,
  );
  applyQuaternionToCamera(camera, quaternion);
}

function applyQuaternionToCamera(camera: UniversalCamera, quaternion: Quaternion) {
  const euler = quaternion.toEulerAngles();
  camera.rotation.set(euler.x, euler.y, 0);
}

function almostEqual(a: number, b: number) {
  return Math.abs(a - b) <= 1e-5;
}
</file>

<file path="src/fps/placement/surfaces/floorSurface.ts">
import { Matrix, Vector3 } from "babylonjs";
import type { AbstractMesh, PickingInfo } from "babylonjs";
import type { PlacementSurface } from "./placementSurface";
import type {
  FloorMountConstraints,
  PlacementFrame,
  PlacementMode,
  SurfaceSampleRequest,
} from "./types";
import { clamp } from "../../utils/math";

export interface FloorSurfaceOptions {
  id: string;
  mesh: AbstractMesh;
  up?: Vector3;
  forward?: Vector3;
}

export class FloorSurface implements PlacementSurface {
  public readonly id: string;
  public readonly mesh: AbstractMesh;
  private readonly up: Vector3;
  private readonly forward: Vector3;

  constructor(options: FloorSurfaceOptions) {
    this.id = options.id;
    this.mesh = options.mesh;
    this.up = (options.up ?? Vector3.Up()).normalize();
    const forward = options.forward ?? new Vector3(0, 0, 1);
    this.forward = forward.normalize();
  }

  supports(mode: PlacementMode) {
    return mode === "floor-mount";
  }

  sample(request: SurfaceSampleRequest): PlacementFrame | null {
    if (request.mode !== "floor-mount") {
      return null;
    }

    const constraints = request.constraints as FloorMountConstraints;
    if (constraints.type !== "floor-mount") {
      return null;
    }

    return this.sampleFloorMount(request.pick, constraints);
  }

  dispose() {
    // Nothing to release for now.
  }

  private sampleFloorMount(pick: PickingInfo, constraints: FloorMountConstraints): PlacementFrame | null {
    if (!pick.hit || pick.pickedMesh?.uniqueId !== this.mesh.uniqueId || !pick.pickedPoint) {
      return null;
    }

    const mesh = this.mesh;
    const worldMatrix = mesh.getWorldMatrix();
    const inverse = Matrix.Identity();
    worldMatrix.invertToRef(inverse);

    const localPoint = Vector3.TransformCoordinates(pick.pickedPoint, inverse);
    const bounds = mesh.getBoundingInfo().boundingBox.extendSize;

    const halfWidth = bounds.x;
    const halfDepth = bounds.z;

    const snap = constraints.grid > 0 ? constraints.grid : 0;
    const maxX = Math.max(halfWidth - constraints.itemSize.width / 2, 0);
    const maxZ = Math.max(halfDepth - constraints.itemSize.depth / 2, 0);

    const snappedX = snap
      ? clamp(Math.round(localPoint.x / snap) * snap, -maxX, maxX)
      : clamp(localPoint.x, -maxX, maxX);
    const snappedZ = snap
      ? clamp(Math.round(localPoint.z / snap) * snap, -maxZ, maxZ)
      : clamp(localPoint.z, -maxZ, maxZ);

    const baseLocal = new Vector3(snappedX, 0, snappedZ);
    const baseWorld = Vector3.TransformCoordinates(baseLocal, worldMatrix);

    const up = this.up.clone();
    const forward = this.forward.clone();
    const right = Vector3.Cross(up, forward).normalize();
    const heightOffset = constraints.heightOffset + constraints.itemSize.height / 2;
    const position = baseWorld.add(up.scale(heightOffset));

    return {
      surfaceId: this.id,
      mesh,
      mode: "floor-mount",
      position,
      forward,
      up,
      right,
      local: {
        x: Number(snappedX.toFixed(3)),
        y: 0,
        z: Number(snappedZ.toFixed(3)),
      },
    };
  }
}
</file>

<file path="src/fps/placement/surfaces/placementSurface.ts">
import type { AbstractMesh } from "babylonjs";
import type { PlacementFrame, PlacementMode, SurfaceSampleRequest } from "./types";

export interface PlacementSurface {
  readonly id: string;
  readonly mesh: AbstractMesh;
  supports(mode: PlacementMode): boolean;
  sample(request: SurfaceSampleRequest): PlacementFrame | null;
  dispose(): void;
}
</file>

<file path="src/fps/placement/surfaces/surfaceRegistry.ts">
import type { AbstractMesh, PickingInfo } from "babylonjs";
import type { PlacementSurface } from "./placementSurface";

export interface SurfaceRegistry {
  register(surface: PlacementSurface): void;
  unregister(mesh: AbstractMesh): void;
  resolveFromMesh(mesh?: AbstractMesh | null): PlacementSurface | null;
  resolveFromPick(pick?: PickingInfo | null): PlacementSurface | null;
  list(): PlacementSurface[];
  dispose(): void;
}

export function createSurfaceRegistry(): SurfaceRegistry {
  const surfacesById = new Map<string, PlacementSurface>();
  const surfacesByMesh = new Map<number, PlacementSurface>();

  const register = (surface: PlacementSurface) => {
    surfacesById.set(surface.id, surface);
    surfacesByMesh.set(surface.mesh.uniqueId, surface);
  };

  const unregister = (mesh: AbstractMesh) => {
    const surface = surfacesByMesh.get(mesh.uniqueId);
    if (!surface) {
      return;
    }
    surfacesByMesh.delete(mesh.uniqueId);
    surfacesById.delete(surface.id);
    surface.dispose();
  };

  return {
    register,
    unregister,
    resolveFromMesh: (mesh?: AbstractMesh | null) => {
      if (!mesh) {
        return null;
      }
      return surfacesByMesh.get(mesh.uniqueId) ?? null;
    },
    resolveFromPick: (pick?: PickingInfo | null) => {
      if (!pick) {
        return null;
      }
      return surfacesByMesh.get(pick.pickedMesh?.uniqueId ?? -1) ?? null;
    },
    list: () => Array.from(surfacesById.values()),
    dispose: () => {
      surfacesByMesh.forEach((surface) => {
        surface.dispose();
      });
      surfacesByMesh.clear();
      surfacesById.clear();
    },
  };
}
</file>

<file path="src/fps/placement/surfaces/types.ts">
import type { AbstractMesh, PickingInfo, Vector3 } from "babylonjs";

export type PlacementMode = "wall-mount" | "floor-mount" | "ceiling-mount";

export interface PlacementFrame {
  surfaceId: string;
  mesh: AbstractMesh;
  mode: PlacementMode;
  position: Vector3;
  forward: Vector3;
  up: Vector3;
  right: Vector3;
  local: {
    x: number;
    y: number;
    z: number;
  };
}

export interface WallMountConstraints {
  type: "wall-mount";
  grid: number;
  itemSize: {
    width: number;
    height: number;
    depth: number;
  };
  offset: number;
  boundsPadding: {
    horizontal: number;
    vertical: number;
  };
}

export interface FloorMountConstraints {
  type: "floor-mount";
  grid: number;
  itemSize: {
    width: number;
    depth: number;
    height: number;
  };
  heightOffset: number;
}

export type PlacementConstraints = WallMountConstraints | FloorMountConstraints;

export interface SurfaceSampleRequest {
  mode: PlacementMode;
  constraints: PlacementConstraints;
  pick: PickingInfo;
}
</file>

<file path="src/fps/placement/surfaces/wallSurface.ts">
import { Matrix, Vector3 } from "babylonjs";
import type { AbstractMesh, PickingInfo } from "babylonjs";
import type { PlacementSurface } from "./placementSurface";
import type {
  PlacementFrame,
  PlacementMode,
  SurfaceSampleRequest,
  WallMountConstraints,
} from "./types";
import { clamp } from "../../utils/math";

export interface WallSurfaceOptions {
  id: string;
  mesh: AbstractMesh;
  inward: Vector3;
  up?: Vector3;
}

export class WallSurface implements PlacementSurface {
  public readonly id: string;
  public readonly mesh: AbstractMesh;
  private readonly inward: Vector3;
  private readonly up: Vector3;

  constructor(options: WallSurfaceOptions) {
    this.id = options.id;
    this.mesh = options.mesh;
    this.inward = options.inward.normalize();
    this.up = (options.up ?? Vector3.Up()).normalize();
  }

  supports(mode: PlacementMode) {
    return mode === "wall-mount";
  }

  sample(request: SurfaceSampleRequest): PlacementFrame | null {
    if (request.mode !== "wall-mount") {
      return null;
    }

    const constraints = request.constraints as WallMountConstraints;
    if (constraints.type !== "wall-mount") {
      return null;
    }

    return this.sampleWallMount(request.pick, constraints);
  }

  dispose() {
    // Nothing to release for now.
  }

  private sampleWallMount(pick: PickingInfo, constraints: WallMountConstraints): PlacementFrame | null {
    const { mesh } = this;
    if (!pick.hit || pick.pickedMesh?.uniqueId !== mesh.uniqueId || !pick.pickedPoint) {
      return null;
    }

    const worldMatrix = mesh.getWorldMatrix();
    const inverse = Matrix.Identity();
    worldMatrix.invertToRef(inverse);

    const localPoint = Vector3.TransformCoordinates(pick.pickedPoint, inverse);
    const bounds = mesh.getBoundingInfo().boundingBox.extendSize;

    const halfWidth = bounds.x;
    const halfHeight = bounds.y;
    const paddingX = constraints.boundsPadding.horizontal;
    const paddingY = constraints.boundsPadding.vertical;

    const allowedHalfWidth = Math.max(halfWidth - (constraints.itemSize.width / 2 + paddingX), 0);
    const allowedHalfHeight = Math.max(halfHeight - (constraints.itemSize.height / 2 + paddingY), 0);

    const snap = constraints.grid > 0 ? constraints.grid : 0;
    const snappedX = snap
      ? clamp(Math.round(localPoint.x / snap) * snap, -allowedHalfWidth, allowedHalfWidth)
      : clamp(localPoint.x, -allowedHalfWidth, allowedHalfWidth);
    const snappedY = snap
      ? clamp(Math.round(localPoint.y / snap) * snap, -allowedHalfHeight, allowedHalfHeight)
      : clamp(localPoint.y, -allowedHalfHeight, allowedHalfHeight);

    const baseLocal = new Vector3(snappedX, snappedY, 0);
    const baseWorld = Vector3.TransformCoordinates(baseLocal, worldMatrix);

    const forward = this.inward.clone();
    if (pick.ray && Vector3.Dot(forward, pick.ray.direction) > 0) {
      forward.scaleInPlace(-1);
    }

    const right = Vector3.Cross(this.up, forward).normalize();
    const up = Vector3.Cross(forward, right).normalize();

    const depthOffset = constraints.itemSize.depth / 2 + constraints.offset;
    const position = baseWorld.add(forward.scale(depthOffset));

    return {
      surfaceId: this.id,
      mesh,
      mode: "wall-mount",
      position,
      forward,
      up,
      right,
      local: {
        x: Number(snappedX.toFixed(3)),
        y: Number(snappedY.toFixed(3)),
        z: 0,
      },
    };
  }
}
</file>

<file path="src/fps/placement/tools/deleteTool.ts">
import { PointerEventTypes } from "babylonjs";
import { INPUT_KEYS } from "../../constants";
import type { PlacementToolDefinition, ToolRuntimeContext } from "../placementTypes";

const TOOL_ID = "delete";

const pickRemovable = (context: ToolRuntimeContext) =>
  context.scene.pick(
    context.scene.pointerX,
    context.scene.pointerY,
    (mesh) => {
      const metadata = mesh?.metadata as { toolId?: unknown } | undefined;
      return typeof metadata?.toolId === "string";
    },
  );

export const deleteToolDefinition: PlacementToolDefinition = {
  id: TOOL_ID,
  label: "Remover",
  icon: "âœ–",
  hotkey: INPUT_KEYS.deleteMode,
  create: (context: ToolRuntimeContext) => {
    const clear = () => {
      context.highlight(null);
      context.ghost.hide();
    };

    return {
      id: TOOL_ID,
      onActivate: () => {
        clear();
      },
      onDeactivate: () => {
        clear();
      },
      onPointerLockChange: (isLocked: boolean) => {
        if (!isLocked) {
          clear();
        }
      },
      onPointerMove: (pointerInfo) => {
        if (pointerInfo.type !== PointerEventTypes.POINTERMOVE) {
          return;
        }

        const pick = pickRemovable(context);
        if (!context.withinRange(pick?.pickedPoint)) {
          clear();
          return;
        }

        const mesh = pick?.pickedMesh;
        if (!mesh) {
          context.highlight(null);
          return;
        }

        context.highlight(mesh);
        context.ghost.hide();
      },
      onPointerDown: (pointerInfo) => {
        if (pointerInfo.type !== PointerEventTypes.POINTERDOWN) {
          return;
        }
        if (pointerInfo.event.button !== 0) {
          return;
        }

        const pick = pickRemovable(context);
        if (!context.withinRange(pick?.pickedPoint)) {
          return;
        }

        if (context.removeMesh(pick?.pickedMesh ?? null)) {
          context.highlight(null);
        }
      },
      dispose: () => {
        clear();
      },
    };
  },
};
</file>

<file path="src/fps/placement/tools/index.ts">
import type { PlacementToolDefinition } from "../placementTypes";
import { deleteToolDefinition } from "./deleteTool";
import { lampToolDefinition } from "./lampTool";
import { wallToolDefinition } from "./wallTool";

export const TOOL_DEFINITIONS: PlacementToolDefinition[] = [
  wallToolDefinition,
  lampToolDefinition,
  deleteToolDefinition,
];

export const TOOL_DEFINITION_BY_ID = new Map<string, PlacementToolDefinition>(
  TOOL_DEFINITIONS.map((definition) => [definition.id, definition]),
);
</file>

<file path="src/fps/placement/placementSolver.ts">
import type { PickingInfo } from "babylonjs";
import type { SurfaceRegistry } from "./surfaces/surfaceRegistry";
import type {
  PlacementConstraints,
  PlacementFrame,
  PlacementMode,
} from "./surfaces/types";

export interface PlacementModeEntry<C extends PlacementConstraints = PlacementConstraints> {
  mode: PlacementMode;
  constraints: C;
}

export interface PlacementProfile {
  modes: PlacementModeEntry[];
}

export interface PlacementSolver {
  solve(profile: PlacementProfile, pick: PickingInfo | null): PlacementFrame | null;
}

export function createPlacementSolver(surfaceRegistry: SurfaceRegistry): PlacementSolver {
  return {
    solve: (profile: PlacementProfile, pick: PickingInfo | null) => {
      if (!pick) {
        return null;
      }
      const surface = surfaceRegistry.resolveFromPick(pick);
      if (!surface) {
        return null;
      }

      for (const entry of profile.modes) {
        if (!surface.supports(entry.mode)) {
          continue;
        }
        const frame = surface.sample({
          mode: entry.mode,
          constraints: entry.constraints,
          pick,
        });
        if (frame) {
          return frame;
        }
      }

      return null;
    },
  };
}
</file>

<file path="src/fps/state/playerModules.ts">
import type { PlayerStore } from "./playerStore";
import type { PlayerModuleDefinition } from "./playerStore";

interface HealthModuleState {
  current: number;
  max: number;
  [key: string]: unknown;
}

interface EnergyModuleState {
  current: number;
  max: number;
  regenPerSecond: number;
  [key: string]: unknown;
}

interface HungerModuleState {
  value: number;
  threshold: number;
  [key: string]: unknown;
}

interface InventorySlot {
  id: string;
  quantity: number;
  [key: string]: unknown;
}

interface InventoryModuleState {
  capacity: number;
  slots: InventorySlot[];
  [key: string]: unknown;
}

const healthModule: PlayerModuleDefinition<HealthModuleState> = {
  id: "vitals.health",
  version: 1,
  createInitialState: () => ({
    current: 100,
    max: 100,
  }),
  onRegister: (context) => {
    context.emit({ type: "player.module.ready", payload: { moduleId: "vitals.health" } });
  },
};

const energyModule: PlayerModuleDefinition<EnergyModuleState> = {
  id: "vitals.energy",
  version: 1,
  createInitialState: () => ({
    current: 100,
    max: 100,
    regenPerSecond: 2,
  }),
  onRegister: (context) => {
    context.emit({ type: "player.module.ready", payload: { moduleId: "vitals.energy" } });
  },
};

const hungerModule: PlayerModuleDefinition<HungerModuleState> = {
  id: "vitals.hunger",
  version: 1,
  createInitialState: () => ({
    value: 0,
    threshold: 100,
  }),
  onRegister: (context) => {
    context.emit({ type: "player.module.ready", payload: { moduleId: "vitals.hunger" } });
  },
};

const inventoryModule: PlayerModuleDefinition<InventoryModuleState> = {
  id: "inventory.core",
  version: 1,
  createInitialState: () => ({
    capacity: 24,
    slots: [],
  }),
  onRegister: (context) => {
    context.emit({ type: "player.module.ready", payload: { moduleId: "inventory.core" } });
  },
};

export function registerBaselinePlayerModules(store: PlayerStore) {
  const actions = store.getActions();
  actions.registerModule(healthModule);
  actions.registerModule(energyModule);
  actions.registerModule(hungerModule);
  actions.registerModule(inventoryModule);
}
</file>

<file path="src/fps/state/playerPersistence.ts">
import type { PlayerStore } from "./playerStore";
import type { PlayerState } from "./playerState";
import { PLAYER_STATE_VERSION } from "./playerState";
import { createEmptyPlayerState } from "./playerState";

const DEFAULT_STORAGE_KEY = "starwatch.player-state";
const DEFAULT_DEBOUNCE_MS = 250;

export function loadPlayerState(storageKey = DEFAULT_STORAGE_KEY): PlayerState | null {
  if (typeof window === "undefined") {
    return null;
  }

  try {
    const raw = window.localStorage.getItem(storageKey);
    if (!raw) {
      return null;
    }
    const parsed = JSON.parse(raw) as PlayerState | undefined;
    if (!parsed || typeof parsed.version !== "number") {
      return null;
    }
    if (parsed.version !== PLAYER_STATE_VERSION) {
      return null;
    }
    return normalizePlayerState(parsed);
  } catch (error) {
    console.warn("[PlayerPersistence] Failed to load player state:", error);
    return null;
  }
}

export function savePlayerState(state: PlayerState, storageKey = DEFAULT_STORAGE_KEY) {
  if (typeof window === "undefined") {
    return;
  }
  try {
    window.localStorage.setItem(storageKey, JSON.stringify(state));
  } catch (error) {
    console.warn("[PlayerPersistence] Failed to save player state:", error);
  }
}

export interface PlayerPersistenceController {
  dispose(): void;
  flush(): void;
}

export function createPlayerPersistence(
  store: PlayerStore,
  options?: {
    storageKey?: string;
    debounceMs?: number;
  },
): PlayerPersistenceController {
  const storageKey = options?.storageKey ?? DEFAULT_STORAGE_KEY;
  const debounceMs = options?.debounceMs ?? DEFAULT_DEBOUNCE_MS;

  let latestState: PlayerState | null = null;
  let timeoutHandle: number | null = null;
  let disposed = false;
  let skipNext = true;

  const scheduleSave = () => {
    if (timeoutHandle !== null) {
      window.clearTimeout(timeoutHandle);
    }
    timeoutHandle = window.setTimeout(() => {
      timeoutHandle = null;
      if (!latestState) {
        return;
      }
      savePlayerState(latestState, storageKey);
    }, debounceMs);
  };

  const unsubscribe = store.subscribe((state) => {
    latestState = state;
    if (skipNext) {
      skipNext = false;
      return;
    }
    if (!disposed) {
      scheduleSave();
    }
  });

  return {
    dispose: () => {
      disposed = true;
      unsubscribe();
      if (timeoutHandle !== null) {
        window.clearTimeout(timeoutHandle);
        timeoutHandle = null;
      }
    },
    flush: () => {
      if (!latestState) {
        return;
      }
      if (timeoutHandle !== null) {
        window.clearTimeout(timeoutHandle);
        timeoutHandle = null;
      }
      savePlayerState(latestState, storageKey);
    },
  };
}

function normalizePlayerState(state: PlayerState): PlayerState {
  const snapshot = createEmptyPlayerState();
  snapshot.transform = {
    position: { ...state.transform.position },
    orientation: { ...state.transform.orientation },
    velocity: { ...state.transform.velocity },
  };
  snapshot.movementIntent = {
    move: { ...state.movementIntent.move },
    sprint: state.movementIntent.sprint,
    jump: state.movementIntent.jump,
    crouch: state.movementIntent.crouch,
  };
  snapshot.input = {
    pointerLocked: state.input.pointerLocked,
    movementLocked: state.input.movementLocked,
    cameraLocked: state.input.cameraLocked,
  };
  snapshot.modules = {};
  Object.values(state.modules ?? {}).forEach((module) => {
    if (!module) {
      return;
    }
    snapshot.modules[module.id] = {
      id: module.id,
      version: module.version,
      state: { ...module.state },
    };
  });
  return snapshot;
}
</file>

<file path="src/fps/state/playerState.ts">
export interface Vector3Serialized {
  x: number;
  y: number;
  z: number;
}

export interface QuaternionSerialized {
  x: number;
  y: number;
  z: number;
  w: number;
}

export interface PlayerTransformState {
  position: Vector3Serialized;
  orientation: QuaternionSerialized;
  velocity: Vector3Serialized;
}

export interface PlayerMovementIntent {
  move: {
    x: number;
    z: number;
  };
  sprint: boolean;
  jump: boolean;
  crouch: boolean;
}

export interface PlayerInputState {
  pointerLocked: boolean;
  movementLocked: boolean;
  cameraLocked: boolean;
}

export interface PlayerModuleSnapshot<TState = Record<string, unknown>> {
  id: string;
  version: number;
  state: TState;
}

export interface PlayerState {
  version: number;
  transform: PlayerTransformState;
  movementIntent: PlayerMovementIntent;
  input: PlayerInputState;
  modules: Record<string, PlayerModuleSnapshot>;
}

export const PLAYER_STATE_VERSION = 1;

export function createEmptyPlayerState(): PlayerState {
  return {
    version: PLAYER_STATE_VERSION,
    transform: {
      position: serializeVector3(0, 0, 0),
      orientation: serializeQuaternion(0, 0, 0, 1),
      velocity: serializeVector3(0, 0, 0),
    },
    movementIntent: {
      move: { x: 0, z: 0 },
      sprint: false,
      jump: false,
      crouch: false,
    },
    input: {
      pointerLocked: false,
      movementLocked: false,
      cameraLocked: false,
    },
    modules: {},
  };
}

export function serializeVector3(x: number, y: number, z: number): Vector3Serialized {
  return {
    x: round(x),
    y: round(y),
    z: round(z),
  };
}

export function serializeQuaternion(
  x: number,
  y: number,
  z: number,
  w: number,
): QuaternionSerialized {
  return {
    x: round(x),
    y: round(y),
    z: round(z),
    w: round(w),
  };
}

function round(value: number) {
  return Number(value.toFixed(5));
}
</file>

<file path="src/fps/state/playerStore.ts">
import {
  createEmptyPlayerState,
  PLAYER_STATE_VERSION,
  type PlayerInputState,
  type PlayerMovementIntent,
  type PlayerModuleSnapshot,
  type PlayerState,
  type PlayerTransformState,
} from "./playerState";

type PlayerStateListener = (state: PlayerState) => void;

export interface PlayerEvent<TPayload = unknown> {
  type: string;
  payload?: TPayload;
}

type PlayerEventListener = (event: PlayerEvent) => void;

export interface PlayerModuleDefinition<TState extends Record<string, unknown>> {
  id: string;
  version: number;
  createInitialState(): TState;
  onRegister?(context: PlayerModuleContext<TState>): void;
  onDispose?(context: PlayerModuleContext<TState>): void;
}

export interface PlayerModuleContext<TState extends Record<string, unknown>> {
  read(): TState;
  set(next: TState): void;
  patch(patch: Partial<TState>): void;
  emit(event: PlayerEvent): void;
  actions(): PlayerActionContext;
}

export interface PlayerStoreActions {
  setTransform(transform: PlayerTransformState): void;
  patchMovementIntent(intent: Partial<PlayerMovementIntent>): void;
  setMovementIntent(intent: PlayerMovementIntent): void;
  patchInput(input: Partial<PlayerInputState>): void;
  registerModule<TState extends Record<string, unknown>>(
    definition: PlayerModuleDefinition<TState>,
  ): void;
  unregisterModule(moduleId: string): void;
  emit(event: PlayerEvent): void;
}

export interface PlayerActionContext {
  readState(): PlayerState;
  readTransform(): PlayerTransformState;
  setTransform(transform: PlayerTransformState): void;
  patchMovementIntent(intent: Partial<PlayerMovementIntent>): void;
  updateModule<TState extends Record<string, unknown>>(
    moduleId: string,
    updater: (current: TState) => TState,
  ): void;
  emit(event: PlayerEvent): void;
}

interface PlayerModuleRegistration<TState extends Record<string, unknown>> {
  definition: PlayerModuleDefinition<TState>;
  context: PlayerModuleContext<TState>;
}

export class PlayerStore {
  private state: PlayerState;
  private listeners: Set<PlayerStateListener>;
  private eventListeners: Set<PlayerEventListener>;
  private modules: Map<string, PlayerModuleRegistration<Record<string, unknown>>>;

  constructor(initialState?: PlayerState) {
    this.state = normalizePlayerState(initialState);
    this.listeners = new Set();
    this.eventListeners = new Set();
    this.modules = new Map();
  }

  getSnapshot(): PlayerState {
    return clonePlayerState(this.state);
  }

  getActions(): PlayerStoreActions {
    return {
      setTransform: (transform) => {
        this.setTransform(transform);
      },
      patchMovementIntent: (intent) => {
        this.patchMovementIntent(intent);
      },
      setMovementIntent: (intent) => {
        this.setMovementIntent(intent);
      },
      patchInput: (input) => {
        this.patchInput(input);
      },
      registerModule: (definition) => {
        this.registerModule(definition);
      },
      unregisterModule: (moduleId) => {
        this.unregisterModule(moduleId);
      },
      emit: (event) => {
        this.emit(event);
      },
    };
  }

  getActionContext(): PlayerActionContext {
    return {
      readState: () => this.getSnapshot(),
      readTransform: () => cloneTransform(this.state.transform),
      setTransform: (transform) => this.setTransform(transform),
      patchMovementIntent: (intent) => this.patchMovementIntent(intent),
      updateModule: (moduleId, updater) => {
        this.updateModule(moduleId, updater as (current: Record<string, unknown>) => Record<string, unknown>);
      },
      emit: (event) => this.emit(event),
    };
  }

  subscribe(listener: PlayerStateListener): () => void {
    this.listeners.add(listener);
    listener(this.getSnapshot());
    return () => {
      this.listeners.delete(listener);
    };
  }

  subscribeEvents(listener: PlayerEventListener): () => void {
    this.eventListeners.add(listener);
    return () => {
      this.eventListeners.delete(listener);
    };
  }

  replace(nextState: PlayerState) {
    this.state = normalizePlayerState(nextState);
    this.notify();
  }

  setTransform(transform: PlayerTransformState) {
    if (transformsEqual(this.state.transform, transform)) {
      return;
    }
    this.state = {
      ...this.state,
      transform: cloneTransform(transform),
    };
    this.notify();
  }

  setMovementIntent(intent: PlayerMovementIntent) {
    if (movementIntentEqual(this.state.movementIntent, intent)) {
      return;
    }
    this.state = {
      ...this.state,
      movementIntent: cloneMovementIntent(intent),
    };
    this.notify();
  }

  patchMovementIntent(intent: Partial<PlayerMovementIntent>) {
    const next = { ...this.state.movementIntent, ...intent };
    this.setMovementIntent(next);
  }

  patchInput(input: Partial<PlayerInputState>) {
    const next = { ...this.state.input, ...input };
    if (inputStateEqual(this.state.input, next)) {
      return;
    }
    this.state = {
      ...this.state,
      input: next,
    };
    this.notify();
  }

  registerModule<TState extends Record<string, unknown>>(
    definition: PlayerModuleDefinition<TState>,
  ) {
    if (this.modules.has(definition.id)) {
      return;
    }

    const persisted = this.state.modules[definition.id];
    const moduleState =
      persisted && persisted.version === definition.version
        ? (persisted.state as TState)
        : definition.createInitialState();

    this.state = {
      ...this.state,
      modules: {
        ...this.state.modules,
        [definition.id]: {
          id: definition.id,
          version: definition.version,
          state: cloneRecord(moduleState),
        },
      },
    };

    const context: PlayerModuleContext<TState> = {
      read: () => cloneRecord(this.state.modules[definition.id].state as TState),
      set: (next) => {
        this.state = {
          ...this.state,
          modules: {
            ...this.state.modules,
            [definition.id]: {
              id: definition.id,
              version: definition.version,
              state: cloneRecord(next),
            },
          },
        };
        this.notify();
        this.emit({ type: "player.module.updated", payload: { moduleId: definition.id } });
      },
      patch: (patch) => {
        const previous = this.state.modules[definition.id].state as TState;
        const next = { ...previous, ...patch };
        context.set(next);
      },
      emit: (event) => {
        this.emit(event);
      },
      actions: () => this.getActionContext(),
    };

    this.modules.set(definition.id, {
      definition,
      context,
    });

    definition.onRegister?.(context);
    this.emit({ type: "player.module.registered", payload: { moduleId: definition.id } });
    this.notify();
  }

  unregisterModule(moduleId: string) {
    const registration = this.modules.get(moduleId);
    if (!registration) {
      return;
    }

    registration.definition.onDispose?.(registration.context);
    this.modules.delete(moduleId);
    const nextModules = { ...this.state.modules };
    delete nextModules[moduleId];
    this.state = {
      ...this.state,
      modules: nextModules,
    };
    this.emit({ type: "player.module.unregistered", payload: { moduleId } });
    this.notify();
  }

  emit(event: PlayerEvent) {
    this.eventListeners.forEach((listener) => {
      listener(event);
    });
  }

  private updateModule(
    moduleId: string,
    updater: (current: Record<string, unknown>) => Record<string, unknown>,
  ) {
    const moduleSnapshot = this.state.modules[moduleId];
    if (!moduleSnapshot) {
      return;
    }
    const current = moduleSnapshot.state;
    const next = updater(current);
    if (shallowEqual(current, next)) {
      return;
    }
    this.state = {
      ...this.state,
      modules: {
        ...this.state.modules,
        [moduleId]: {
          id: moduleSnapshot.id,
          version: moduleSnapshot.version,
          state: cloneRecord(next),
        },
      },
    };
    this.notify();
    this.emit({ type: "player.module.updated", payload: { moduleId } });
  }

  private notify() {
    const snapshot = this.getSnapshot();
    this.listeners.forEach((listener) => {
      listener(snapshot);
    });
  }
}

function normalizePlayerState(state?: PlayerState): PlayerState {
  if (!state || state.version !== PLAYER_STATE_VERSION) {
    return createEmptyPlayerState();
  }
  const snapshot = createEmptyPlayerState();
  snapshot.transform = cloneTransform(state.transform);
  snapshot.movementIntent = cloneMovementIntent(state.movementIntent);
  snapshot.input = { ...state.input };
  snapshot.modules = {};
  Object.values(state.modules ?? {}).forEach((module) => {
    if (!module) {
      return;
    }
    snapshot.modules[module.id] = {
      id: module.id,
      version: module.version,
      state: cloneRecord(module.state),
    };
  });
  return snapshot;
}

function clonePlayerState(state: PlayerState): PlayerState {
  return {
    version: state.version,
    transform: cloneTransform(state.transform),
    movementIntent: cloneMovementIntent(state.movementIntent),
    input: { ...state.input },
    modules: cloneModules(state.modules),
  };
}

function cloneTransform(transform: PlayerTransformState): PlayerTransformState {
  return {
    position: { ...transform.position },
    orientation: { ...transform.orientation },
    velocity: { ...transform.velocity },
  };
}

function cloneMovementIntent(intent: PlayerMovementIntent): PlayerMovementIntent {
  return {
    move: { ...intent.move },
    sprint: intent.sprint,
    jump: intent.jump,
    crouch: intent.crouch,
  };
}

function cloneModules(
  modules: Record<string, PlayerModuleSnapshot<Record<string, unknown>>>,
): Record<string, PlayerModuleSnapshot<Record<string, unknown>>> {
  const copy: Record<string, PlayerModuleSnapshot<Record<string, unknown>>> = {};
  Object.values(modules).forEach((module) => {
    if (!module) {
      return;
    }
    copy[module.id] = {
      id: module.id,
      version: module.version,
      state: cloneRecord(module.state),
    };
  });
  return copy;
}

function cloneRecord<T extends Record<string, unknown>>(record: T): T {
  return { ...record };
}

function shallowEqual(a: Record<string, unknown>, b: Record<string, unknown>) {
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  if (keysA.length !== keysB.length) {
    return false;
  }
  return keysA.every((key) => Object.is(a[key], b[key]));
}

function transformsEqual(a: PlayerTransformState, b: PlayerTransformState) {
  return (
    almostEqual(a.position.x, b.position.x) &&
    almostEqual(a.position.y, b.position.y) &&
    almostEqual(a.position.z, b.position.z) &&
    almostEqual(a.velocity.x, b.velocity.x) &&
    almostEqual(a.velocity.y, b.velocity.y) &&
    almostEqual(a.velocity.z, b.velocity.z) &&
    almostEqual(a.orientation.x, b.orientation.x) &&
    almostEqual(a.orientation.y, b.orientation.y) &&
    almostEqual(a.orientation.z, b.orientation.z) &&
    almostEqual(a.orientation.w, b.orientation.w)
  );
}

function movementIntentEqual(a: PlayerMovementIntent, b: PlayerMovementIntent) {
  return (
    almostEqual(a.move.x, b.move.x) &&
    almostEqual(a.move.z, b.move.z) &&
    a.sprint === b.sprint &&
    a.jump === b.jump &&
    a.crouch === b.crouch
  );
}

function inputStateEqual(a: PlayerInputState, b: PlayerInputState) {
  return (
    a.pointerLocked === b.pointerLocked &&
    a.movementLocked === b.movementLocked &&
    a.cameraLocked === b.cameraLocked
  );
}

function almostEqual(a: number, b: number) {
  return Math.abs(a - b) <= 1e-5;
}
</file>

<file path="src/fps/utils/math.ts">
export function clamp(value: number, min: number, max: number) {
  return Math.min(Math.max(value, min), max);
}

export function degreesToRadians(degrees: number) {
  return (degrees * Math.PI) / 180;
}
</file>

<file path="src/legacy/game/Game.ts">
import { Engine, Scene, ArcRotateCamera, UniversalCamera, Vector3, HemisphericLight, MeshBuilder, Color3, StandardMaterial, Mesh, Color4, DynamicTexture, ParticleSystem, Texture, VertexBuffer, GlowLayer, PointLight, Scalar, KeyboardEventTypes } from 'babylonjs';
import type { ResourceType, Sector } from './world';
import { generateSector } from './world';

type Vec3 = { x: number; y: number; z: number };

type ScriptJob = { name: string; code: string };
type ScriptEntry = { code: string; description: string; lastModified: string };
type WorkerLogEntry = { id: string; level: 'info' | 'warn' | 'error'; message: string; timestamp: number };
type WorkerState = 'idle' | 'starting' | 'running' | 'completed' | 'error' | 'stopped';
type WorkerStatus = {
  scriptName: string | null;
  state: WorkerState;
  startedAt?: number;
  finishedAt?: number;
  logs: WorkerLogEntry[];
  lastMessage?: string;
  lastError?: string;
};

export type TerminalId = 'engineering' | 'construction';
export type TerminalInfo = { id: TerminalId; label: string; hint: string; description?: string };

type TerminalInstance = TerminalInfo & {
  mesh: Mesh;
  screen: Mesh;
  interactDistance: number;
  idleColor: Color3;
  activeColor: Color3;
  light?: PointLight | null;
};

type GameOptions = {
  onTerminalProximity?: (info: TerminalInfo | null) => void;
  onTerminalInteract?: (info: TerminalInfo) => void;
  onPointerLockChange?: (locked: boolean) => void;
};

export class Game {
  private engine: Engine;
  private scene: Scene;
  private camera: ArcRotateCamera;
  private fpCamera: UniversalCamera;
  private options: GameOptions;
  private inputPaused = false;
  private pointerLocked = false;
  private terminals: TerminalInstance[] = [];
  private nearbyTerminal: TerminalInstance | null = null;
  private activeTerminalId: TerminalId | null = null;
  private canvasClickHandler: (() => void) | null = null;
  private pointerLockHandler: (() => void) | null = null;
  private ship = { mesh: null as unknown as Mesh, velocity: new Vector3(0, 0, 0), maxSpeed: 1.8, destination: null as Vector3 | null };
  private world!: Sector;
  private asteroidMeshes = new Map<string, Mesh>();
  private meshToAsteroidId = new Map<string, string>();
  private selected: { type: 'ship' | 'asteroid' | null; id?: string } = { type: null };
  private selectedPrevEmissive: Color3 | null = null;
  private inventory = { iron: 0, silicon: 0, uranium: 0 };
  private mining = { targetId: null as string | null, active: false, range: 10, rate: 5 };
  private miningLog: { lastEvent: 'none' | 'depleted' | 'stopped'; lastTarget?: { id: string; resource: ResourceType } } = { lastEvent: 'none' };
  private scanned = new Set<string>();
  private scanRadius = 1000; // km (redefinido apÃ³s carregar o setor)
  private logicTimer: number | null = null;
  private worker: Worker | null = null;
  private workerStatus: WorkerStatus = { scriptName: null, state: 'idle', logs: [] };
  private mode: 'play' | 'sector' = 'play';
  private prevCam: { alpha: number; beta: number; radius: number; target: Vector3; fogMode: number; fogStart?: number; fogEnd?: number; fogDensity?: number; panning?: number; lockedTarget?: any; followingShip?: boolean } | null = null;
  private labelMeshes: Mesh[] = [];
  private sun?: Mesh;
  private starfield?: Mesh;
  private dustEmitter?: Mesh;
  private dustSystem?: ParticleSystem;
  private distantStars: Array<{ material: StandardMaterial; base: number; amplitude: number; speed: number; phase: number; color: Color3 }> = [];
  private followingShip = false;
  // Script Library (persisted)
  private scriptLibrary: Map<string, ScriptEntry> = new Map();

  constructor(private canvas: HTMLCanvasElement, options: GameOptions = {}) {
    this.options = options;
    this.engine = new Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
    this.scene = new Scene(this.engine);
    this.scene.clearColor = new Color4(0.02, 0.04, 0.08, 1); // deep space
    // Softer, longer-range fog for melhor visibilidade
    this.scene.fogMode = Scene.FOGMODE_LINEAR;
    this.scene.fogColor = new Color3(0.03, 0.06, 0.12) as any;
    (this.scene as any).fogStart = 2500;
    (this.scene as any).fogEnd = 9000;

    // Camera: top-down legacy (mantida para automaÃ§Ãµes tÃ¡ticas)
    this.camera = new ArcRotateCamera('camera', Math.PI / 2, 1.2, 120, new Vector3(0, 0, 0), this.scene);
    this.camera.panningSensibility = 50;
    this.camera.lowerRadiusLimit = 40;
    this.camera.upperRadiusLimit = 1000;
    this.camera.minZ = 0.1;

    // First-person camera inside the ship
    this.scene.collisionsEnabled = true;
    this.scene.gravity = new Vector3(0, -0.6, 0);
    this.fpCamera = new UniversalCamera('fpCamera', new Vector3(0, 1.7, 6), this.scene);
    this.fpCamera.minZ = 0.05;
    this.fpCamera.speed = 1.8;
    this.fpCamera.inertia = 0.6;
    this.fpCamera.angularSensibility = 5200;
    this.fpCamera.applyGravity = true;
    this.fpCamera.checkCollisions = true;
    this.fpCamera.ellipsoid = new Vector3(0.5, 0.9, 0.5);
    this.fpCamera.keysUp.push(87, 38); // W / ArrowUp
    this.fpCamera.keysDown.push(83, 40); // S / ArrowDown
    this.fpCamera.keysLeft.push(65, 37); // A / ArrowLeft
    this.fpCamera.keysRight.push(68, 39); // D / ArrowRight
    this.scene.activeCamera = this.fpCamera;
    this.fpCamera.attachControl(canvas, true);
    const fpMouse = (this.fpCamera.inputs.attached as any)?.mouse;
    if (fpMouse) {
      fpMouse.usePointerLock = true;
    }
    this.setupPointerLock();

    new HemisphericLight('light1', new Vector3(1, 1, 0), this.scene);

    // Ship mesh
    const ship = MeshBuilder.CreateBox('ship', { width: 2.2, depth: 5, height: 1.2 }, this.scene);
    const sm = new StandardMaterial('shipMat', this.scene);
    sm.diffuseColor = new Color3(0.5, 0.7, 1);
    ship.material = sm;
    this.ship.mesh = ship as any;

    // Load or generate sector and spawn bodies
    const loaded = this.tryLoad();
    if (!loaded) {
      this.world = generateSector();
    }
    // Ajustar parÃ¢metros dependentes da escala do setor
    this.configureScaleFromWorld();
    this.spawnSector();

    // Load scripts library (seed with default patrol if empty)
    this.loadScripts();

    // Background: starfield skybox + subtle dust + sun
    this.createStarfield();
    this.createSpaceDust();
    this.createDistantStars();
    this.createSun();
    this.createShipInterior();

    // Input: selection picking
    this.setupPicking();

    // Render loop
    this.engine.runRenderLoop(() => {
      this.updatePhysics();
      this.scene.render();
    });

    // Logic tick at 1 Hz
    this.logicTimer = window.setInterval(() => this.logicTick(), 1000);

    // Resize
    window.addEventListener('resize', () => this.engine.resize());
  }

  private setupPointerLock() {
    if (this.canvasClickHandler) {
      this.canvas.removeEventListener('click', this.canvasClickHandler);
    }
    if (this.pointerLockHandler) {
      document.removeEventListener('pointerlockchange', this.pointerLockHandler);
    }
    this.canvasClickHandler = () => {
      if (this.inputPaused) return;
      if (document.pointerLockElement !== this.canvas) {
        this.canvas.requestPointerLock();
      }
    };
    this.pointerLockHandler = () => {
      const locked = document.pointerLockElement === this.canvas;
      this.pointerLocked = locked;
      this.options.onPointerLockChange?.(locked);
    };
    this.canvas.addEventListener('click', this.canvasClickHandler);
    document.addEventListener('pointerlockchange', this.pointerLockHandler);
  }

  dispose() {
    if (document.pointerLockElement === this.canvas) {
      document.exitPointerLock();
    }
    if (this.canvasClickHandler) {
      this.canvas.removeEventListener('click', this.canvasClickHandler);
      this.canvasClickHandler = null;
    }
    if (this.pointerLockHandler) {
      document.removeEventListener('pointerlockchange', this.pointerLockHandler);
      this.pointerLockHandler = null;
    }
    if (this.logicTimer) window.clearInterval(this.logicTimer);
    if (this.worker) {
      this.worker.terminate();
      this.worker = null;
    }
    this.workerStatus = { scriptName: null, state: 'idle', logs: [] };
    this.scene.dispose();
    this.engine.dispose();
  }

  moveTo(v: Vec3) {
    this.ship.destination = new Vector3(v.x, v.y, v.z);
  }

  setFollowShip(on: boolean) {
    this.followingShip = on;
    if (on) {
      // Segue a nave usando lockedTarget
      this.camera.lockedTarget = this.ship.mesh;
    } else {
      this.camera.lockedTarget = null as any;
    }
  }

  isFollowingShip() {
    return this.followingShip;
  }

  getShipStatus() {
    return {
      position: this.ship.mesh.position.clone(),
      speed: this.ship.velocity.length(),
      destination: this.ship.destination ? { x: this.ship.destination.x, y: this.ship.destination.y, z: this.ship.destination.z } : null,
    };
  }

  getSectorInfo() {
    const counts = this.world.asteroids.reduce(
      (acc, a) => {
        acc[a.resource] += a.amount > 0 ? 1 : 0;
        return acc;
      },
      { iron: 0, silicon: 0, uranium: 0 } as Record<ResourceType, number>
    );
    return {
      id: this.world.id,
      name: this.world.name,
      seed: this.world.seed,
      bounds: this.world.bounds,
      asteroidCounts: counts,
    };
  }

  getResources() {
    return { ...this.inventory };
  }

  performScan() {
    // Reveal asteroides dentro do raio de varredura a partir da nave
    const pos = this.ship.mesh.position;
    const newly: string[] = [];
    for (const a of this.world.asteroids) {
      if (a.amount <= 0) continue;
      if (this.scanned.has(a.id)) continue;
      const d = new Vector3(a.position.x, a.position.y, a.position.z).subtract(pos).length();
      if (d <= this.scanRadius) {
        this.scanned.add(a.id);
        newly.push(a.id);
      }
    }
    return newly;
  }

  scanSector(filter?: { resource?: ResourceType; limit?: number }) {
    const pos = this.ship.mesh.position;
    const entries = this.world.asteroids
      .filter((a) => this.scanned.has(a.id) && a.amount > 0 && (!filter?.resource || a.resource === filter.resource))
      .map((a) => {
        const d = new Vector3(a.position.x, a.position.y, a.position.z).subtract(pos).length();
        return { id: a.id, resource: a.resource, amount: a.amount, position: a.position, distance: d, clusterId: a.clusterId };
      })
      .sort((a, b) => a.distance - b.distance);
    const limit = filter?.limit ?? 10;
    return entries.slice(0, limit);
  }

  startMining(resource: ResourceType) {
    // Prefer scanned targets; if none scanned, try performScan first
    let nearest = this.scanSector({ resource, limit: 1 })[0];
    if (!nearest) {
      this.performScan();
      nearest = this.scanSector({ resource, limit: 1 })[0];
    }
    if (!nearest) return { ok: false as const, error: 'No asteroid found for resource' };
    this.mining.targetId = nearest.id;
    this.mining.active = false; // will activate when in range
    this.ship.destination = new Vector3(nearest.position.x, nearest.position.y, nearest.position.z);
    this.miningLog.lastEvent = 'none';
    return { ok: true as const, targetId: nearest.id, position: nearest.position };
  }

  stopMining() {
    this.mining.targetId = null;
    this.mining.active = false;
    this.miningLog.lastEvent = 'stopped';
    return { ok: true as const };
  }

  resetSector() {
    // Clear persistence and regenerate
    try { localStorage.removeItem('starwatch.v010.save'); } catch {}
    // Dispose asteroid meshes
    for (const [, m] of this.asteroidMeshes) m.dispose(false, true);
    this.asteroidMeshes.clear();
    this.meshToAsteroidId.clear();
    // Reset state
    this.world = generateSector();
    this.scanned.clear();
    this.inventory = { iron: 0, silicon: 0, uranium: 0 };
    this.mining = { targetId: null, active: false, range: 10, rate: 5 };
    this.ship.destination = null;
    this.ship.mesh.position.set(0, 0, 0);
    this.worker?.terminate();
    this.worker = null;
    this.workerStatus = { scriptName: null, state: 'idle', logs: [] };
    // Respawn
    this.spawnSector();
    // Save immediately
    this.save();
  }

  enterSectorMap() {
    if (this.mode === 'sector') return;
    this.mode = 'sector';
    this.prevCam = {
      alpha: this.camera.alpha,
      beta: this.camera.beta,
      radius: this.camera.radius,
      target: this.camera.target.clone(),
      fogMode: this.scene.fogMode!,
      fogStart: (this.scene as any).fogStart,
      fogEnd: (this.scene as any).fogEnd,
      fogDensity: (this.scene as any).fogDensity,
      panning: this.camera.panningSensibility,
      lockedTarget: (this.camera as any).lockedTarget,
      followingShip: this.followingShip,
    };
    // Desliga follow para visÃ£o do mapa do setor
    this.setFollowShip(false);
    // Top-down zoomed out
    this.camera.setTarget(new Vector3(0, 0, 0));
    this.camera.alpha = Math.PI / 2;
    this.camera.beta = 0.0001;
    this.camera.radius = this.world.bounds * 1.8;
    this.camera.panningSensibility = 0;
    // Disable fog for clarity
    this.scene.fogMode = Scene.FOGMODE_NONE as any;
    // Create labels
    this.createSectorLabels();
  }

  exitSectorMap() {
    if (this.mode !== 'sector') return;
    this.mode = 'play';
    // Restore camera and fog
    if (this.prevCam) {
      this.camera.setTarget(this.prevCam.target);
      this.camera.alpha = this.prevCam.alpha;
      this.camera.beta = this.prevCam.beta;
      this.camera.radius = this.prevCam.radius;
      if (this.prevCam.panning != null) this.camera.panningSensibility = this.prevCam.panning;
      this.scene.fogMode = this.prevCam.fogMode as any;
      (this.scene as any).fogStart = this.prevCam.fogStart;
      (this.scene as any).fogEnd = this.prevCam.fogEnd;
      (this.scene as any).fogDensity = this.prevCam.fogDensity;
      // Restaura lockTarget/follow ship
      if (this.prevCam.followingShip) this.setFollowShip(true);
      else this.camera.lockedTarget = this.prevCam.lockedTarget ?? null;
    }
    // Dispose labels
    for (const m of this.labelMeshes) m.dispose(false, true);
    this.labelMeshes = [];
  }

  runScript(job: ScriptJob) {
    if (this.worker) {
      this.worker.terminate();
      if (this.workerStatus.state === 'running' || this.workerStatus.state === 'starting') {
        this.workerStatus = {
          ...this.workerStatus,
          state: 'stopped',
          finishedAt: Date.now(),
          lastMessage: 'Script anterior interrompido.',
        };
      }
    }
    this.workerStatus = {
      scriptName: job.name,
      state: 'starting',
      startedAt: Date.now(),
      logs: [],
    };
    const blob = new Blob([
      this.makeWorkerSource(job.code, job.name)
    ], { type: 'application/javascript' });
    const url = URL.createObjectURL(blob);
    const worker = new Worker(url, { type: 'module' });
    URL.revokeObjectURL(url);
    this.worker = worker;
    this.workerStatus.state = 'running';

    worker.onmessage = (ev) => {
      const msg = ev.data;
      if (!msg) return;
      if (msg.type === 'tool') {
        (async () => {
          try {
            if (msg.name === 'moveTo') {
              const { x, y, z } = msg.args ?? {};
              this.moveTo({ x, y, z });
              worker.postMessage({ type: 'tool-ack', id: msg.id, ok: true, result: null });
            } else if (msg.name === 'performScan') {
              const out = this.performScan();
              worker.postMessage({ type: 'tool-ack', id: msg.id, ok: true, result: out });
            } else if (msg.name === 'scanSector') {
              const out = this.scanSector(msg.args);
              worker.postMessage({ type: 'tool-ack', id: msg.id, ok: true, result: out });
            } else if (msg.name === 'startMining') {
              const out = this.startMining(msg.args?.resource);
              worker.postMessage({ type: 'tool-ack', id: msg.id, ok: true, result: out });
            } else if (msg.name === 'stopMining') {
              const out = this.stopMining();
              worker.postMessage({ type: 'tool-ack', id: msg.id, ok: true, result: out });
            } else if (msg.name === 'getMiningStatus') {
              const out = this.getMiningStatus();
              worker.postMessage({ type: 'tool-ack', id: msg.id, ok: true, result: out });
            } else if (msg.name === 'getShipStatus') {
              const out = this.getShipStatus();
              worker.postMessage({ type: 'tool-ack', id: msg.id, ok: true, result: out });
            } else if (msg.name === 'getResources') {
                const out = this.getResources();
                worker.postMessage({ type: 'tool-ack', id: msg.id, ok: true, result: out });
              }
            } catch (e) {
              console.error('Script tool error', e);
              worker.postMessage({ type: 'tool-ack', id: msg.id, ok: false, error: String(e) });
            }
        })();
      } else if (msg.type === 'log') {
        const entry: WorkerLogEntry = {
          id: msg.id || Math.random().toString(36).slice(2),
          level: msg.level === 'error' ? 'error' : msg.level === 'warn' ? 'warn' : 'info',
          message: String(msg.message ?? ''),
          timestamp: msg.timestamp || Date.now(),
        };
        this.workerStatus.logs = [...this.workerStatus.logs.slice(-99), entry];
        this.workerStatus.lastMessage = entry.message;
        if (entry.level === 'error') {
          this.workerStatus.lastError = entry.message;
        }
      } else if (msg.type === 'script-state') {
        if (msg.state === 'completed') {
          this.workerStatus = {
            ...this.workerStatus,
            state: 'completed',
            finishedAt: Date.now(),
            lastMessage: msg.message || 'Script concluÃ­do.',
          };
          worker.terminate();
          if (this.worker === worker) this.worker = null;
        } else if (msg.state === 'error') {
          this.workerStatus = {
            ...this.workerStatus,
            state: 'error',
            finishedAt: Date.now(),
            lastError: msg.error || 'Erro desconhecido',
          };
          worker.terminate();
          if (this.worker === worker) this.worker = null;
        }
      }
    };
    worker.onerror = (e) => {
      console.error('Script worker error', e);
      this.workerStatus = {
        ...this.workerStatus,
        state: 'error',
        finishedAt: Date.now(),
        lastError: e.message || String(e),
      };
      if (this.worker === worker) this.worker = null;
    };
  }

  runScriptByName(name: string) {
    const code = this.getScriptCode(name);
    if (!code) {
      console.warn('Script not found:', name);
      return { ok: false as const, error: 'Script not found' };
    }
    this.runScript({ name, code });
    return { ok: true as const };
  }

  private makeWorkerSource(userCode: string, scriptName: string) {
    // Tiny API bridge: Game.moveTo, Memory.get/set, sleep + mining/scan helpers
    return `
      const __postLog = (level, message) => {
        try {
          postMessage({ type: 'log', level, message: message != null ? String(message) : '', timestamp: Date.now(), id: Math.random().toString(36).slice(2) });
        } catch (_) {}
      };
      const __formatArgs = (args) => args.map((v) => {
        if (typeof v === 'string') return v;
        try { return JSON.stringify(v); } catch { return String(v); }
      }).join(' ');
      (() => {
        const originalLog = console.log.bind(console);
        const originalWarn = console.warn ? console.warn.bind(console) : console.log.bind(console);
        const originalError = console.error ? console.error.bind(console) : console.log.bind(console);
        console.log = (...args) => { originalLog(...args); __postLog('info', __formatArgs(args)); };
        console.warn = (...args) => { originalWarn(...args); __postLog('warn', __formatArgs(args)); };
        console.error = (...args) => { originalError(...args); __postLog('error', __formatArgs(args)); };
      })();

      const Memory = new Map();
      function postTool(name, args) {
        return new Promise((resolve) => {
          const id = Math.random().toString(36).slice(2);
          function onAck(ev) {
            const msg = ev.data;
            if (msg && msg.type === 'tool-ack' && msg.id === id) {
              resolve(msg.result);
              self.removeEventListener('message', onAck);
            }
          }
          self.addEventListener('message', onAck);
          postMessage({ type: 'tool', id, name, args });
        });
      }
      const Game = {
        moveTo: async (v) => { await postTool('moveTo', v); },
        performScan: async () => await postTool('performScan'),
        scanSector: async (filter) => await postTool('scanSector', filter),
        startMining: async (resource) => await postTool('startMining', { resource }),
        stopMining: async () => await postTool('stopMining'),
        getMiningStatus: async () => await postTool('getMiningStatus'),
        getShipStatus: async () => await postTool('getShipStatus'),
        getResources: async () => await postTool('getResources'),
      };
      const sleep = (ms) => new Promise(r => setTimeout(r, ms));
      const MemoryAPI = { set: (k, v) => Memory.set(k, v), get: (k) => Memory.get(k) };
      self.Game = Game; self.Memory = MemoryAPI; self.sleep = sleep;
      // Helpers
      async function patrol() {
        const A = { x: 500, y: 0, z: 250 }; const B = { x: 200, y: 0, z: -200 };
        while (true) { await Game.moveTo(A); await sleep(3000); await Game.moveTo(B); await sleep(3000); }
      }
      async function mineResource(resource) {
        await Game.performScan();
        const res = await Game.startMining(resource);
        if (!res?.ok) return res;
        while (true) {
          const s = await Game.getMiningStatus();
          if (!s || s.state === 'idle') break;
          await sleep(1000);
        }
        return { ok: true };
      }
      postMessage({ type: 'script-state', state: 'ready', scriptName: ${JSON.stringify(scriptName)} });
      (async () => {
        try {
${userCode.split('\n').map((line) => `          ${line}`).join('\n')}
        } catch (e) {
          console.error('Erro no script:', e);
          postMessage({ type: 'script-state', state: 'error', error: e?.stack || e?.message || String(e) });
          return;
        }
        postMessage({ type: 'script-state', state: 'completed', message: 'ExecuÃ§Ã£o encerrada.' });
      })();
    `;
  }

  // ===== Script Library API =====
  listScripts() {
    return Array.from(this.scriptLibrary.entries()).map(([name, e]) => ({ name, description: e.description, lastModified: e.lastModified }));
  }

  getScriptCode(name: string): string | null {
    const e = this.scriptLibrary.get(name);
    return e ? e.code : null;
  }

  createScript(name: string, code: string, description: string = '') {
    if (!name || !code) return { ok: false as const, error: 'Missing name or code' };
    if (this.scriptLibrary.has(name)) return { ok: false as const, error: 'Script already exists' };
    const entry: ScriptEntry = { code, description, lastModified: new Date().toISOString() };
    this.scriptLibrary.set(name, entry);
    this.saveScripts();
    return { ok: true as const };
  }

  updateScript(name: string, newCode: string) {
    const e = this.scriptLibrary.get(name);
    if (!e) return { ok: false as const, error: 'Script not found' };
    e.code = newCode;
    e.lastModified = new Date().toISOString();
    this.scriptLibrary.set(name, e);
    this.saveScripts();
    return { ok: true as const };
  }

  deleteScript(name: string) {
    if (!this.scriptLibrary.has(name)) return { ok: false as const, error: 'Script not found' };
    this.scriptLibrary.delete(name);
    this.saveScripts();
    return { ok: true as const };
  }

  private loadScripts() {
    try {
      const raw = localStorage.getItem('starwatch.v030.scripts');
      if (raw) {
        const obj = JSON.parse(raw) as Record<string, ScriptEntry>;
        this.scriptLibrary = new Map<string, ScriptEntry>(Object.entries(obj));
      }
    } catch (e) {
      console.warn('Failed to load scripts', e);
    }
    if (this.scriptLibrary.size === 0) {
      // Seed with a default patrol script
      const code = `// patrol.js\n// Patrulha simples entre dois pontos usando a API do worker\n(async () => {\n  const A = { x: 500, y: 0, z: 250 };\n  const B = { x: 200, y: 0, z: -200 };\n  while (true) {\n    await Game.moveTo(A);\n    await sleep(3000);\n    await Game.moveTo(B);\n    await sleep(3000);\n  }\n})();`;
      this.scriptLibrary.set('patrol.js', { code, description: 'Patrulha entre dois pontos', lastModified: new Date().toISOString() });
      this.saveScripts();
    }
  }

  private saveScripts() {
    try {
      const obj: Record<string, ScriptEntry> = {};
      for (const [k, v] of this.scriptLibrary.entries()) obj[k] = v;
      localStorage.setItem('starwatch.v030.scripts', JSON.stringify(obj));
    } catch (e) {
      console.warn('Failed to save scripts', e);
    }
  }

  private updatePhysics() {
    const dt = this.engine.getDeltaTime() / 1000; // seconds
    const pos = this.ship.mesh.position;
    if (this.ship.destination) {
      const to = this.ship.destination.subtract(pos);
      const dist = to.length();
      if (dist < 0.5) {
        this.ship.velocity.setAll(0);
      } else {
        const dir = to.normalize();
        this.ship.velocity = dir.scale(this.ship.maxSpeed);
      }
    } else {
      this.ship.velocity.setAll(0);
    }
    pos.addInPlace(this.ship.velocity.scale(dt));

    // Se estÃ¡ seguindo a nave e nÃ£o estamos no mapa de setor, garante lock ativo
    if (this.followingShip && this.mode === 'play') {
      if ((this.camera as any).lockedTarget !== this.ship.mesh) {
        this.camera.lockedTarget = this.ship.mesh;
      }
    }

    // Mining auto-activation and extraction
    if (this.mining.targetId) {
      const a = this.world.asteroids.find((x) => x.id === this.mining.targetId);
      if (a && a.amount > 0) {
        const d = new Vector3(a.position.x, a.position.y, a.position.z).subtract(pos).length();
        if (!this.mining.active && d <= this.mining.range) {
          this.mining.active = true;
        }
        if (this.mining.active && d <= this.mining.range + 2) {
          // Extract resources
          const mined = Math.min(this.mining.rate * dt, a.amount);
          a.amount -= mined;
          // Update inventory
          if (a.resource === 'iron') this.inventory.iron += mined;
          if (a.resource === 'silicon') this.inventory.silicon += mined;
          if (a.resource === 'uranium') this.inventory.uranium += mined;
          // Visual feedback: shrink slightly
          const mesh = this.asteroidMeshes.get(a.id);
          if (mesh) {
            const base = Math.max(0.5, a.radius * 0.5);
            const factor = Math.max(0.2, a.amount / (a.radius * 100));
            mesh.scaling.setAll(Math.max(base * factor, 0.2));
          }
          if (a.amount <= 0.0001) {
            // Depleted: remove visually
            const m = this.asteroidMeshes.get(a.id);
            if (m) {
              m.dispose(false, true);
              this.asteroidMeshes.delete(a.id);
            }
            this.mining.targetId = null;
            this.mining.active = false;
            this.miningLog.lastEvent = 'depleted';
            this.miningLog.lastTarget = { id: a.id, resource: a.resource };
          }
        }
      } else {
        // Target disappeared
        this.mining.targetId = null;
        this.mining.active = false;
      }
    }
  }

  private logicTick() {
    // Persist state periodically
    this.save();
  }

  private spawnSector() {
    // remove any previous
    for (const [, m] of this.asteroidMeshes) m.dispose(false, true);
    this.asteroidMeshes.clear();
    this.meshToAsteroidId.clear();

    for (const a of this.world.asteroids) {
      if (a.amount <= 0) continue;
      const mesh = this.createAsteroidMesh(a.id, a.resource, a.radius);
      const mat = new StandardMaterial(`mat:${a.id}`, this.scene);
      // Consistent color by type (iron=green, silicon=bluish, uranium=amber)
      if (a.resource === 'iron') mat.diffuseColor = new Color3(0.3, 0.75, 0.35);
      if (a.resource === 'silicon') mat.diffuseColor = new Color3(0.65, 0.7, 0.85);
      if (a.resource === 'uranium') mat.diffuseColor = new Color3(0.85, 0.75, 0.35);
      mesh.material = mat;
      mesh.position = new Vector3(a.position.x, a.position.y, a.position.z);
      this.asteroidMeshes.set(a.id, mesh);
      this.meshToAsteroidId.set(mesh.id, a.id);
    }
  }

  private setupPicking() {
    this.scene.onPointerDown = (_evt, pickInfo) => {
      // Cleanup previous highlight
      if (this.selected.type === 'asteroid' && this.selected.id) {
        const m = this.asteroidMeshes.get(this.selected.id);
        if (m && m.material instanceof StandardMaterial && this.selectedPrevEmissive) {
          (m.material as StandardMaterial).emissiveColor = this.selectedPrevEmissive;
        }
      }
      this.selected = { type: null };
      this.selectedPrevEmissive = null;

      if (pickInfo?.hit && pickInfo.pickedMesh) {
        const mesh = pickInfo.pickedMesh as Mesh;
        if (mesh.id === this.ship.mesh.id) {
          this.selected = { type: 'ship' };
          // foco na nave; manter follow se jÃ¡ ativo
          this.focusCameraOn(this.ship.mesh.position);
        } else if (mesh.id.startsWith('ast:')) {
          const aId = this.meshToAsteroidId.get(mesh.id);
          if (aId) {
            this.selected = { type: 'asteroid', id: aId };
            if (mesh.material instanceof StandardMaterial) {
              const sm = mesh.material as StandardMaterial;
              this.selectedPrevEmissive = sm.emissiveColor.clone();
              sm.emissiveColor = new Color3(0.3, 0.5, 0.9);
            }
            this.focusCameraOn((this.asteroidMeshes.get(aId) as Mesh).position, 80);
          }
        }
      }
    };
  }

  private rndFromId(id: string) {
    let h = 2166136261;
    for (let i = 0; i < id.length; i++) h = (h ^ id.charCodeAt(i)) * 16777619;
    const seed = h >>> 0;
    return function () {
      // mulberry32
      let t = (seed + 0x6d2b79f5) >>> 0;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  private createAsteroidMesh(id: string, resource: ResourceType, radius: number): Mesh {
    // Base meshes vary by type
    let mesh: Mesh;
    const name = `ast:${id}`;
    if (resource === 'silicon') {
      // sharp crystal-like
      mesh = MeshBuilder.CreatePolyhedron(name, { type: 1, size: radius }, this.scene); // Tetrahedron
    } else if (resource === 'uranium') {
      // elongated body
      mesh = MeshBuilder.CreateIcoSphere(name, { radius, subdivisions: 2 }, this.scene);
      mesh.scaling = new Vector3(1.0, 0.7, 1.3);
    } else {
      // iron: chunky rock
      mesh = MeshBuilder.CreateIcoSphere(name, { radius, subdivisions: 3 }, this.scene);
    }

    // Perturb vertices deterministically for id
    const rng = this.rndFromId(id);
    const pos = mesh.getVerticesData(VertexBuffer.PositionKind) as number[];
    if (pos) {
      const amp = resource === 'silicon' ? 0.12 : resource === 'uranium' ? 0.18 : 0.22;
      for (let i = 0; i < pos.length; i += 3) {
        const nx = (rng() - 0.5) * 2;
        const ny = (rng() - 0.5) * 2;
        const nz = (rng() - 0.5) * 2;
        pos[i] += nx * amp * radius;
        pos[i + 1] += ny * amp * radius;
        pos[i + 2] += nz * amp * radius;
      }
      mesh.updateVerticesData(VertexBuffer.PositionKind, pos);
      mesh.refreshBoundingInfo();
    }
    return mesh;
  }

  focusCameraOn(target: Vector3 | { x: number; y: number; z: number }, radius: number = 100) {
    const t = target instanceof Vector3 ? target : new Vector3(target.x, target.y, target.z);
    // Smoothly move camera target and radius
    // Qualquer foco manual desliga follow
    this.setFollowShip(false);
    this.camera.setTarget(t);
    const maxR = Math.max(1000, this.world?.bounds ? this.world.bounds * 0.25 : 1000);
    this.camera.radius = Math.max(40, Math.min(radius, maxR));
  }

  getFleet() {
    return [
      {
        id: 'mothership',
        name: 'USS [Nome da Nave]',
        type: 'mothership',
        position: { x: this.ship.mesh.position.x, y: this.ship.mesh.position.y, z: this.ship.mesh.position.z },
        speed: this.ship.velocity.length(),
        script: this.worker ? 'custom' : null,
      },
    ];
  }

  getWorkerStatus(): WorkerStatus {
    return {
      scriptName: this.workerStatus.scriptName,
      state: this.workerStatus.state,
      startedAt: this.workerStatus.startedAt,
      finishedAt: this.workerStatus.finishedAt,
      logs: this.workerStatus.logs.slice(),
      lastMessage: this.workerStatus.lastMessage,
      lastError: this.workerStatus.lastError,
    };
  }

  getMiningStatus() {
    const targetId = this.mining.targetId;
    if (targetId) {
      const a = this.world.asteroids.find((x) => x.id === targetId);
      const pos = this.ship.mesh.position;
      let distance = 0;
      let remaining = 0;
      let resource: ResourceType | undefined = undefined;
      if (a) {
        distance = Vector3.Distance(new Vector3(a.position.x, a.position.y, a.position.z), pos);
        remaining = a.amount;
        resource = a.resource;
      }
      return {
        state: this.mining.active ? 'mining' : 'approaching',
        targetId,
        resource,
        remaining,
        distance,
        inRange: this.mining.active,
        rate: this.mining.rate,
        lastEvent: this.miningLog.lastEvent,
        lastTarget: this.miningLog.lastTarget ?? null,
      } as const;
    }
    return {
      state: 'idle' as const,
      lastEvent: this.miningLog.lastEvent,
      lastTarget: this.miningLog.lastTarget ?? null,
    };
  }

  getClustersOverview(onlyScanned = true) {
    const clusters = this.world.clusters.map((c) => ({ id: c.id, type: c.type, center: c.center, radius: c.radius }));
    const astByCluster = new Map<string, any[]>();
    for (const a of this.world.asteroids) {
      if (onlyScanned && !this.scanned.has(a.id)) continue;
      if (!a.clusterId) continue;
      const arr = astByCluster.get(a.clusterId) || [];
      arr.push({ id: a.id, resource: a.resource, amount: a.amount, position: a.position });
      astByCluster.set(a.clusterId, arr);
    }
    return clusters.map((c) => ({
      ...c,
      discovered: (astByCluster.get(c.id) || []).length,
    }));
  }

  getAsteroidsInCluster(clusterId: string, onlyScanned = true) {
    const pos = this.ship.mesh.position;
    return this.world.asteroids
      .filter((a) => a.clusterId === clusterId && (!onlyScanned || this.scanned.has(a.id)))
      .map((a) => ({ id: a.id, resource: a.resource, amount: a.amount, position: a.position, distance: Vector3.Distance(new Vector3(a.position.x, a.position.y, a.position.z), pos) }))
      .sort((a, b) => a.distance - b.distance);
  }

  private createStarfield() {
    const size = Math.max(8192, this.world.bounds * 4); // escala com o setor
    const sky = MeshBuilder.CreateBox('sky', { size, sideOrientation: Mesh.BACKSIDE }, this.scene);
    const texSize = 2048;
    const dt = new DynamicTexture('stars', { width: texSize, height: texSize }, this.scene, false);
    const ctx = dt.getContext();
    // Fundo com leve gradiente frio
    const gradient = ctx.createRadialGradient(texSize / 2, texSize / 2, texSize * 0.1, texSize / 2, texSize / 2, texSize * 0.7);
    gradient.addColorStop(0, '#060914');
    gradient.addColorStop(1, '#02030a');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, texSize, texSize);
    // Nebulosas suaves para volume distante
    const nebulaCount = 12;
    for (let i = 0; i < nebulaCount; i++) {
      const nx = Math.random() * texSize;
      const ny = Math.random() * texSize;
      const radius = (Math.random() * 0.18 + 0.05) * texSize;
      const hue = 200 + Math.random() * 40;
      const nebula = ctx.createRadialGradient(nx, ny, radius * 0.15, nx, ny, radius);
      nebula.addColorStop(0, `hsla(${hue.toFixed(1)}, 70%, ${60 + Math.random() * 15}%, 0.18)`);
      nebula.addColorStop(0.7, `hsla(${hue.toFixed(1)}, 60%, 20%, 0.06)`);
      nebula.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = nebula;
      ctx.beginPath();
      ctx.arc(nx, ny, radius, 0, Math.PI * 2);
      ctx.fill();
    }
    // Estrelas em mÃºltiplas camadas
    const starLayers: Array<{ count: number; size: [number, number]; alpha: [number, number] }> = [
      { count: 800, size: [2.2, 3.6], alpha: [0.7, 1] },
      { count: 2200, size: [0.8, 1.8], alpha: [0.4, 0.8] },
      { count: 1200, size: [0.3, 0.9], alpha: [0.2, 0.5] },
    ];
    for (const layer of starLayers) {
      for (let i = 0; i < layer.count; i++) {
        const x = Math.random() * texSize;
        const y = Math.random() * texSize;
        const r = layer.size[0] + Math.random() * (layer.size[1] - layer.size[0]);
        const alpha = layer.alpha[0] + Math.random() * (layer.alpha[1] - layer.alpha[0]);
        const hueChance = Math.random();
        let color = `rgba(230,235,255,${alpha.toFixed(3)})`;
        if (hueChance < 0.12) {
          const hue = 200 + Math.random() * 30;
          color = `hsla(${hue}, 70%, ${65 + Math.random() * 20}%, ${alpha.toFixed(3)})`;
        } else if (hueChance > 0.94) {
          const warmth = 30 + Math.random() * 10;
          color = `hsla(${warmth}, 80%, ${70 + Math.random() * 15}%, ${alpha.toFixed(3)})`;
        }
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
        if (Math.random() < 0.1) {
          ctx.save();
          ctx.globalAlpha = alpha * 0.25;
          ctx.beginPath();
          ctx.arc(x, y, r * 3.2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }
    }
    dt.update(false);
    const mat = new StandardMaterial('skyMat', this.scene);
    mat.backFaceCulling = false;
    mat.disableLighting = true;
    // Use both diffuse and emissive to guarantee visibility
    (mat as any).diffuseTexture = dt as unknown as Texture;
    mat.emissiveTexture = dt as unknown as Texture;
    mat.specularColor = new Color3(0, 0, 0);
    mat.ambientColor = new Color3(0, 0, 0);
    (sky as any).material = mat;
    (sky as any).isPickable = false;
    (sky as any).applyFog = false;
    (sky as any).infiniteDistance = true;
    this.starfield = sky as any;
    this.scene.registerBeforeRender(() => {
      if (this.starfield) {
        this.starfield.rotation.y += 0.00001;
      }
    });
  }

  private createSpaceDust() {
    // subtle particles travelling with the camera to sugerir volume ao redor
    this.dustEmitter = MeshBuilder.CreateSphere('dustEmitter', { diameter: 0.1 }, this.scene);
    this.dustEmitter.parent = this.fpCamera;
    this.dustEmitter.position.set(0, 0, 0);
    this.dustEmitter.isPickable = false;
    this.dustEmitter.isVisible = false;
    this.dustEmitter.doNotSyncBoundingInfo = true;

    const ps = new ParticleSystem('spaceDust', 2400, this.scene);
    const size = 32;
    const dot = new DynamicTexture('dustDot', { width: size, height: size }, this.scene, true);
    const ctx = dot.getContext();
    ctx.clearRect(0, 0, size, size);
    const grad = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
    grad.addColorStop(0, 'rgba(255,255,255,0.95)');
    grad.addColorStop(0.45, 'rgba(200,220,255,0.6)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, size, size);
    dot.update(false);

    ps.particleTexture = dot as unknown as Texture;
    ps.emitter = this.dustEmitter;
    ps.minEmitBox = Vector3.Zero();
    ps.maxEmitBox = Vector3.Zero();
    ps.minSize = 0.08;
    ps.maxSize = 0.35;
    ps.minLifeTime = 32;
    ps.maxLifeTime = 56;
    ps.emitRate = 140;
    ps.minEmitPower = 0.006;
    ps.maxEmitPower = 0.02;
    ps.minAngularSpeed = -0.15;
    ps.maxAngularSpeed = 0.15;
    ps.direction1 = new Vector3(-0.02, -0.004, 0.02);
    ps.direction2 = new Vector3(0.02, 0.004, -0.02);
    ps.color1 = new Color4(1, 1, 1, 0.08);
    ps.color2 = new Color4(0.75, 0.85, 1, 0.05);
    ps.colorDead = new Color4(0.45, 0.6, 1, 0.01);
    ps.blendMode = ParticleSystem.BLENDMODE_ADD;
    ps.gravity = Vector3.Zero();
    ps.updateSpeed = 0.004;
    const minRadius = 220;
    const maxRadius = 460;
    const verticalRange = 140;
    ps.startPositionFunction = (_, position) => {
      const theta = Scalar.RandomRange(0, Math.PI * 2);
      const radiusFactor = 1 - Math.pow(Math.random(), 3.2);
      const radius = minRadius + radiusFactor * (maxRadius - minRadius);
      const verticalBias = Scalar.RandomRange(-0.55, 0.55);
      position.copyFromFloats(
        Math.cos(theta) * radius,
        verticalBias * verticalRange * (0.6 + radiusFactor * 0.4),
        Math.sin(theta) * radius
      );
    };
    ps.startDirectionFunction = (_, direction) => {
      direction.copyFromFloats(
        Scalar.RandomRange(-0.012, 0.012),
        Scalar.RandomRange(-0.006, 0.006),
        Scalar.RandomRange(-0.012, 0.012)
      );
    };

    ps.start();
    this.dustSystem = ps;
    let t = 0;
    this.scene.registerBeforeRender(() => {
      if (!this.dustEmitter) return;
      t += this.scene.getEngine().getDeltaTime() * 0.00004;
      const sway = 18;
      this.dustEmitter.position.x = Math.sin(t) * sway;
      this.dustEmitter.position.y = Math.sin(t * 1.6) * 5;
      this.dustEmitter.position.z = Math.cos(t * 1.1) * sway;
    });
  }

  private createShipInterior() {
    const roomHeight = 4.6;
    const roomWidth = 16;
    const roomDepth = 24;
    const wallThickness = 0.5;

    const floor = MeshBuilder.CreateGround('shipFloor', { width: roomWidth, height: roomDepth }, this.scene);
    floor.position.y = 0;
    floor.checkCollisions = true;
    const floorTex = new DynamicTexture('shipFloorTex', { width: 512, height: 512 }, this.scene, true);
    const fctx = floorTex.getContext();
    fctx.fillStyle = '#0a101a';
    fctx.fillRect(0, 0, 512, 512);
    fctx.strokeStyle = 'rgba(60,100,160,0.3)';
    fctx.lineWidth = 2;
    const gridX = 8;
    const gridY = 12;
    for (let i = 0; i <= gridX; i += 1) {
      const x = (512 / gridX) * i;
      fctx.beginPath();
      fctx.moveTo(x, 0);
      fctx.lineTo(x, 512);
      fctx.stroke();
    }
    for (let i = 0; i <= gridY; i += 1) {
      const y = (512 / gridY) * i;
      fctx.beginPath();
      fctx.moveTo(0, y);
      fctx.lineTo(512, y);
      fctx.stroke();
    }
    floorTex.update(false);
    const floorMat = new StandardMaterial('shipFloorMat', this.scene);
    floorMat.diffuseTexture = floorTex as unknown as Texture;
    floorMat.specularColor = new Color3(0.12, 0.16, 0.22);
    floorMat.emissiveColor = new Color3(0.01, 0.015, 0.02);
    floor.material = floorMat;

    const ceiling = MeshBuilder.CreateGround('shipCeiling', { width: roomWidth, height: roomDepth }, this.scene);
    ceiling.position = new Vector3(0, roomHeight, 0);
    ceiling.rotation.x = Math.PI;
    ceiling.checkCollisions = true;
    const ceilingMat = new StandardMaterial('shipCeilingMat', this.scene);
    ceilingMat.diffuseColor = new Color3(0.07, 0.09, 0.14);
    ceilingMat.specularColor = new Color3(0.12, 0.16, 0.2);
    ceilingMat.emissiveColor = new Color3(0.008, 0.012, 0.02);
    ceiling.material = ceilingMat;

    const wallMat = new StandardMaterial('shipWallMat', this.scene);
    wallMat.diffuseColor = new Color3(0.05, 0.07, 0.1);
    wallMat.specularColor = new Color3(0.12, 0.16, 0.22);
    wallMat.emissiveColor = new Color3(0.008, 0.012, 0.018);

    const makeWall = (name: string, opts: { width: number; height: number; depth: number }, position: Vector3) => {
      const wall = MeshBuilder.CreateBox(name, opts, this.scene);
      wall.position = position;
      wall.material = wallMat;
      wall.checkCollisions = true;
      wall.isPickable = false;
      return wall;
    };
    makeWall('wallNorth', { width: roomWidth, height: roomHeight, depth: wallThickness }, new Vector3(0, roomHeight / 2, -roomDepth / 2));
    makeWall('wallEast', { width: wallThickness, height: roomHeight, depth: roomDepth }, new Vector3(roomWidth / 2, roomHeight / 2, 0));
    makeWall('wallWest', { width: wallThickness, height: roomHeight, depth: roomDepth }, new Vector3(-roomWidth / 2, roomHeight / 2, 0));

    const frameColor = new Color3(0.18, 0.28, 0.42);
    const windowWidth = 8;
    const frameSideWidth = (roomWidth - windowWidth) / 2;
    const sillHeight = 1.0;
    const headerHeight = 0.8;
    const glassInset = roomDepth / 2 - 0.12;
    const frameMat = new StandardMaterial('windowFrameMat', this.scene);
    frameMat.diffuseColor = frameColor.clone();
    frameMat.specularColor = new Color3(0.2, 0.28, 0.4);
    frameMat.emissiveColor = frameColor.scale(0.12);

    const makeFrame = (name: string, size: { width: number; height: number; depth: number }, position: Vector3) => {
      const frame = MeshBuilder.CreateBox(name, size, this.scene);
      frame.position = position;
      frame.material = frameMat;
      frame.checkCollisions = true;
      frame.isPickable = false;
      return frame;
    };

    const southZ = roomDepth / 2;
    makeFrame('windowFrameLeft', { width: frameSideWidth, height: roomHeight, depth: wallThickness }, new Vector3(-(windowWidth / 2 + frameSideWidth / 2), roomHeight / 2, southZ));
    makeFrame('windowFrameRight', { width: frameSideWidth, height: roomHeight, depth: wallThickness }, new Vector3(windowWidth / 2 + frameSideWidth / 2, roomHeight / 2, southZ));
    makeFrame('windowHeader', { width: windowWidth, height: headerHeight, depth: wallThickness }, new Vector3(0, roomHeight - headerHeight / 2, southZ));
    makeFrame('windowSill', { width: windowWidth, height: sillHeight, depth: wallThickness }, new Vector3(0, sillHeight / 2, southZ));

    const glassHeight = roomHeight - headerHeight - sillHeight;
    const glass = MeshBuilder.CreatePlane('windowGlass', { width: windowWidth, height: glassHeight, sideOrientation: Mesh.DOUBLESIDE }, this.scene);
    glass.position = new Vector3(0, sillHeight + glassHeight / 2, glassInset);
    const glassMat = new StandardMaterial('windowGlassMat', this.scene);
    glassMat.diffuseColor = new Color3(0.3, 0.55, 0.9);
    glassMat.alpha = 0.32;
    glassMat.specularColor = new Color3(0.5, 0.7, 0.9);
    glassMat.emissiveColor = new Color3(0.18, 0.32, 0.48);
    glassMat.backFaceCulling = false;
    glass.material = glassMat;
    glass.checkCollisions = true;

    const rimLight = new PointLight('windowRimLight', new Vector3(0, roomHeight - 0.4, southZ - 1.2), this.scene);
    rimLight.diffuse = new Color3(0.35, 0.55, 0.9);
    rimLight.specular = rimLight.diffuse.clone();
    rimLight.intensity = 0.55;
    rimLight.range = 12;

    const mezzanine = MeshBuilder.CreateBox('shipDeck', { width: 12, height: 0.4, depth: 8 }, this.scene);
    mezzanine.position = new Vector3(0, 0.2, -7);
    mezzanine.checkCollisions = true;
    const mezzMat = new StandardMaterial('shipDeckMat', this.scene);
    mezzMat.diffuseColor = new Color3(0.08, 0.11, 0.17);
    mezzMat.specularColor = new Color3(0.14, 0.18, 0.24);
    mezzMat.emissiveColor = new Color3(0.015, 0.02, 0.03);
    mezzanine.material = mezzMat;

    const stripMat = new StandardMaterial('shipStrip', this.scene);
    stripMat.diffuseColor = new Color3(0.2, 0.4, 0.8);
    stripMat.emissiveColor = new Color3(0.08, 0.18, 0.35);
    stripMat.specularColor = new Color3(0.1, 0.16, 0.28);
    const stripL = MeshBuilder.CreateBox('stripL', { width: 0.2, height: 0.2, depth: 10 }, this.scene);
    stripL.position = new Vector3(-7.6, 4.2, -2);
    stripL.material = stripMat;
    stripL.isPickable = false;
    const stripR = MeshBuilder.CreateBox('stripR', { width: 0.2, height: 0.2, depth: 10 }, this.scene);
    stripR.position = new Vector3(7.6, 4.2, -2);
    stripR.material = stripMat;
    stripR.isPickable = false;

    this.addTerminal(
      'engineering',
      new Vector3(-4.6, 1.1, -6.5),
      Math.PI / 8,
      {
        label: 'Terminal de Engenharia',
        hint: 'acessar HAL e varrer asteroides',
        description: 'Computador HAL-9001 integrado aos sensores de mineraÃ§Ã£o.',
        color: new Color3(0.35, 0.65, 1),
      }
    );
    this.addTerminal(
      'construction',
      new Vector3(4.6, 1.1, -6.5),
      -Math.PI / 8,
      {
        label: 'Terminal de ConstruÃ§Ã£o',
        hint: 'planejar novos mÃ³dulos',
        description: 'Interface de drones de construÃ§Ã£o â€” mÃ³dulo em atualizaÃ§Ã£o.',
        color: new Color3(0.65, 0.45, 1),
      }
    );

    const glow = new GlowLayer('interiorGlow', this.scene);
    glow.intensity = 0.35;

    this.scene.registerBeforeRender(() => {
      this.updateTerminalLogic();
    });

    this.scene.onKeyboardObservable.add((kbInfo) => {
      if (kbInfo.type === KeyboardEventTypes.KEYDOWN) {
        const key = kbInfo.event.key.toLowerCase();
        if (key === 'e' && !this.inputPaused && !this.activeTerminalId && this.nearbyTerminal) {
          this.beginTerminalInteraction(this.nearbyTerminal);
        }
      }
    });
  }

  private addTerminal(id: TerminalId, origin: Vector3, rotationY: number, opts: { label: string; hint: string; description?: string; color: Color3 }) {
    const base = MeshBuilder.CreateBox(`terminalBase:${id}`, { width: 1.4, height: 1.4, depth: 0.6 }, this.scene);
    base.position = origin.clone();
    base.rotation.y = rotationY;
    base.checkCollisions = true;
    const baseMat = new StandardMaterial(`terminalBaseMat:${id}`, this.scene);
    baseMat.diffuseColor = new Color3(0.08, 0.12, 0.18);
    baseMat.specularColor = opts.color.scale(0.2);
    baseMat.emissiveColor = opts.color.scale(0.08);
    base.material = baseMat;

    const screen = MeshBuilder.CreatePlane(`terminalScreen:${id}`, { width: 1.1, height: 1 }, this.scene);
    screen.parent = base;
    screen.position = new Vector3(0, 0.35, -0.33);
    screen.rotation.x = 0.08;
    const tex = new DynamicTexture(`terminalTex:${id}`, { width: 512, height: 512 }, this.scene, true);
    const ctx = tex.getContext();
    ctx.fillStyle = 'rgba(10,18,32,0.92)';
    ctx.fillRect(0, 0, 512, 512);
    const grad = ctx.createLinearGradient(0, 0, 512, 512);
    grad.addColorStop(0, `rgba(${(opts.color.r * 255).toFixed(0)},${(opts.color.g * 255).toFixed(0)},${(opts.color.b * 255).toFixed(0)},0.5)`);
    grad.addColorStop(1, `rgba(${(opts.color.r * 255).toFixed(0)},${(opts.color.g * 255).toFixed(0)},${(opts.color.b * 255).toFixed(0)},0.1)`);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 512, 512);
    ctx.fillStyle = '#dce9ff';
    ctx.font = 'bold 38px system-ui';
    ctx.fillText(opts.label, 28, 82);
    ctx.font = '22px system-ui';
    ctx.fillText(`â€¢ ${opts.hint}`, 28, 150);
    ctx.fillText('Pressione [E] para interagir', 28, 196);
    tex.update(false);
    const screenMat = new StandardMaterial(`terminalScreenMat:${id}`, this.scene);
    screenMat.disableLighting = true;
    screenMat.diffuseTexture = tex as unknown as Texture;
    screenMat.emissiveTexture = tex as unknown as Texture;
    screenMat.opacityTexture = tex as unknown as Texture;
    screenMat.emissiveColor = opts.color.scale(0.8);
    screen.material = screenMat;

    const light = new PointLight(`terminalLight:${id}`, origin.add(new Vector3(0, 1.6, -0.8)), this.scene);
    light.diffuse = opts.color.clone();
    light.specular = opts.color.clone();
    light.intensity = 0.5;
    light.range = 8.5;

    this.terminals.push({
      id,
      label: opts.label,
      hint: opts.hint,
      description: opts.description,
      mesh: base,
      screen,
      interactDistance: 2.8,
      idleColor: opts.color.scale(0.35),
      activeColor: opts.color.scale(1.25),
      light,
    });
  }

  private toTerminalInfo(term: TerminalInstance): TerminalInfo {
    return { id: term.id, label: term.label, hint: term.hint, description: term.description };
  }

  private updateTerminalLogic() {
    for (const term of this.terminals) {
      const screenMat = term.screen.material as StandardMaterial | null;
      if (screenMat) {
        const distance = Vector3.Distance(term.mesh.getAbsolutePosition(), this.fpCamera.position);
        const factor = Math.max(0.2, Math.min(1, 1 - distance / term.interactDistance));
        const emissive = term.idleColor.scale(0.4).add(term.activeColor.scale(factor * 0.6));
        screenMat.emissiveColor = emissive;
      }
      if (term.light) {
        const distance = Vector3.Distance(term.mesh.getAbsolutePosition(), this.fpCamera.position);
        const factor = Math.max(0.25, Math.min(1, 1 - distance / term.interactDistance));
        term.light.intensity = 0.3 + factor * 0.55;
      }
    }

    if (this.inputPaused || this.activeTerminalId) {
      this.setNearbyTerminal(null);
      return;
    }

    let best: TerminalInstance | null = null;
    let bestDistance = Number.POSITIVE_INFINITY;
    const camPos = this.fpCamera.position;
    for (const term of this.terminals) {
      const distance = Vector3.Distance(term.mesh.getAbsolutePosition(), camPos);
      if (distance < term.interactDistance && distance < bestDistance) {
        best = term;
        bestDistance = distance;
      }
    }
    this.setNearbyTerminal(best);
  }

  private setNearbyTerminal(term: TerminalInstance | null) {
    if (this.nearbyTerminal === term) return;
    if (term) {
      this.options.onTerminalProximity?.(this.toTerminalInfo(term));
    } else if (this.nearbyTerminal) {
      this.options.onTerminalProximity?.(null);
    }
    this.nearbyTerminal = term;
  }

  private beginTerminalInteraction(term: TerminalInstance) {
    if (this.activeTerminalId) return;
    this.activeTerminalId = term.id;
    this.setNearbyTerminal(null);
    this.setInputPaused(true);
    this.options.onTerminalInteract?.(this.toTerminalInfo(term));
  }

  setInputPaused(paused: boolean) {
    this.inputPaused = paused;
    if (paused) {
      this.fpCamera.detachControl();
      if (document.pointerLockElement === this.canvas) {
        document.exitPointerLock();
      }
    } else {
      this.fpCamera.attachControl(this.canvas, true);
      const fpMouse = (this.fpCamera.inputs.attached as any)?.mouse;
      if (fpMouse) fpMouse.usePointerLock = true;
    }
  }

  closeTerminalInteraction() {
    this.activeTerminalId = null;
    this.setNearbyTerminal(null);
    this.setInputPaused(false);
  }

  private createDistantStars() {
    const count = 28;
    const minDistance = Math.max(5400, this.world.bounds * 3.0);
    const maxDistance = Math.max(9000, this.world.bounds * 4.1);
    const baseColor = new Color3(0.55, 0.82, 1.2);
    const spriteSize = 128;
    const starTexture = new DynamicTexture('distantStarSprite', { width: spriteSize, height: spriteSize }, this.scene, true);
    const starCtx = starTexture.getContext();
    starCtx.clearRect(0, 0, spriteSize, spriteSize);
    const starGrad = starCtx.createRadialGradient(spriteSize / 2, spriteSize / 2, 0, spriteSize / 2, spriteSize / 2, spriteSize / 2);
    starGrad.addColorStop(0, 'rgba(255,255,255,1)');
    starGrad.addColorStop(0.35, 'rgba(160,200,255,0.9)');
    starGrad.addColorStop(0.7, 'rgba(90,140,255,0.35)');
    starGrad.addColorStop(1, 'rgba(0,0,0,0)');
    starCtx.fillStyle = starGrad;
    starCtx.fillRect(0, 0, spriteSize, spriteSize);
    starTexture.update(false);
    for (let i = 0; i < count; i += 1) {
      const size = Scalar.RandomRange(28, 56);
      const star = MeshBuilder.CreatePlane(`distantStar:${i}`, { width: size, height: size }, this.scene);
      star.billboardMode = Mesh.BILLBOARDMODE_ALL;
      const dir = new Vector3(Scalar.RandomRange(-1, 1), Scalar.RandomRange(-0.35, 0.5), Scalar.RandomRange(-1, 1));
      if (dir.lengthSquared() < 0.001) {
        dir.set(0.3, 0.25, -0.2);
      }
      dir.normalize();
      const distance = Scalar.RandomRange(minDistance, maxDistance);
      star.position.copyFrom(dir.scale(distance));
      const mat = new StandardMaterial(`distantStarMat:${i}`, this.scene);
      mat.disableLighting = true;
      mat.backFaceCulling = false;
      mat.diffuseTexture = starTexture as unknown as Texture;
      mat.emissiveTexture = starTexture as unknown as Texture;
      mat.opacityTexture = starTexture as unknown as Texture;
      (mat as any).useAlphaFromDiffuseTexture = true;
      mat.alphaMode = Engine.ALPHA_ADD;
      const intensity = Scalar.RandomRange(2.4, 3.8);
      mat.emissiveColor = baseColor.scale(intensity);
      mat.diffuseColor = Color3.Black();
      star.material = mat;
      star.isPickable = false;
      (star as any).applyFog = false;
      (star as any).infiniteDistance = true;
      const amplitude = Scalar.RandomRange(0.35, 0.6);
      const speed = Scalar.RandomRange(0.45, 1.1);
      const phase = Scalar.RandomRange(0, Math.PI * 2);
      this.distantStars.push({
        material: mat,
        base: intensity,
        amplitude,
        speed,
        phase,
        color: baseColor.scale(Scalar.RandomRange(0.95, 1.25)),
      });
    }

    if (this.distantStars.length > 0) {
      let flickerTime = 0;
      this.scene.registerBeforeRender(() => {
        const delta = this.scene.getEngine().getDeltaTime() * 0.001;
        flickerTime += delta;
        for (const star of this.distantStars) {
          const intensity = star.base + Math.sin(flickerTime * star.speed + star.phase) * star.amplitude;
          star.material.emissiveColor = star.color.scale(Math.max(0.2, intensity));
        }
      });
    }
  }

  private createSun() {
    const size = Math.max(600, this.world.bounds * 0.1);
    const sun = MeshBuilder.CreateSphere('sun', { diameter: size }, this.scene);
    const dist = Math.max(3000, this.world.bounds * 2.0);
    sun.position = new Vector3(dist, size, -dist * 0.85);
    const mat = new StandardMaterial('sunMat', this.scene);
    mat.emissiveColor = new Color3(1.0, 0.9, 0.7);
    mat.disableLighting = true;
    sun.material = mat;
    const glow = new GlowLayer('glow', this.scene);
    glow.intensity = 0.6;
    const light = new PointLight('sunLight', sun.position, this.scene);
    light.intensity = 0.7;
    light.range = 10000;
    (sun as any).applyFog = false;
    this.sun = sun;
  }

  private createSectorLabels() {
    // Cluster labels
    for (const c of this.world.clusters) {
      const text = `${c.id} (${c.type})`;
      const m = this.makeLabelMesh(`lbl:${c.id}`, text, new Color3(0.6, 0.8, 1));
      m.position = new Vector3(c.center.x, (c.center.y || 0) + 120, c.center.z);
      this.labelMeshes.push(m);
    }
    // Sun label (if exists)
    if (this.sun) {
      const m = this.makeLabelMesh('lbl:sun', 'Star', new Color3(1, 0.9, 0.6));
      m.position = this.sun.position.add(new Vector3(0, 800, 0));
      this.labelMeshes.push(m);
    }
  }

  private makeLabelMesh(id: string, text: string, color: Color3) {
    const dt = new DynamicTexture(`dt:${id}`, { width: 256, height: 64 }, this.scene, true);
    const ctx = dt.getContext();
    ctx.clearRect(0, 0, 256, 64);
    ctx.fillStyle = 'rgba(13,19,36,0.7)';
    ctx.fillRect(0, 0, 256, 64);
    ctx.strokeStyle = 'rgba(36,52,90,0.9)';
    ctx.strokeRect(0.5, 0.5, 255, 63);
    ctx.fillStyle = '#d3e0ff';
    ctx.font = 'bold 22px system-ui';
    ctx.fillText(text, 10, 40);
    dt.update(true);
    const plane = MeshBuilder.CreatePlane(id, { width: 22, height: 5.5 }, this.scene);
    const mat = new StandardMaterial(`mat:${id}`, this.scene);
    mat.disableLighting = true;
    mat.emissiveTexture = dt as unknown as Texture;
    mat.backFaceCulling = false;
    plane.material = mat;
    plane.billboardMode = Mesh.BILLBOARDMODE_ALL;
    (plane as any).isPickable = false;
    return plane;
  }

  private tryLoad(): boolean {
    try {
      const raw = localStorage.getItem('starwatch.v020.save');
      if (!raw) return false;
      const data = JSON.parse(raw);
      this.world = generateSector(data.world.seed);
      this.configureScaleFromWorld();
      // restore asteroid amounts
      const byId = new Map<string, number>(Object.entries(data.world.asteroidAmounts || {}));
      for (const a of this.world.asteroids) {
        const amt = byId.get(a.id);
        if (typeof amt === 'number') a.amount = amt;
      }
      // scanned
      this.scanned = new Set<string>(data.scanned || []);
      // inventory
      this.inventory = data.inventory || this.inventory;
      // ship
      if (data.ship?.position) {
        this.ship.mesh = this.ship.mesh || ({} as any);
        const p = data.ship.position;
        // ship mesh may not be created yet; we set after spawn by returning true
        setTimeout(() => {
          this.ship.mesh.position.set(p.x, p.y, p.z);
        }, 0);
      }
      if (data.ship?.destination) this.ship.destination = new Vector3(data.ship.destination.x, data.ship.destination.y, data.ship.destination.z);
      return true;
    } catch (e) {
      console.warn('Load failed, starting new', e);
      return false;
    }
  }

  private save() {
    try {
      const asteroidAmounts: Record<string, number> = {};
      for (const a of this.world.asteroids) asteroidAmounts[a.id] = a.amount;
      const data = {
        world: { seed: this.world.seed, asteroidAmounts },
        scanned: Array.from(this.scanned),
        inventory: this.inventory,
        ship: {
          position: { x: this.ship.mesh.position.x, y: this.ship.mesh.position.y, z: this.ship.mesh.position.z },
          destination: this.ship.destination ? { x: this.ship.destination.x, y: this.ship.destination.y, z: this.ship.destination.z } : null,
        },
      };
      localStorage.setItem('starwatch.v020.save', JSON.stringify(data));
    } catch (e) {
      console.warn('Save failed', e);
    }
  }

  private configureScaleFromWorld() {
    // Define velocidade da nave para atravessar o diÃ¢metro do setor em ~30min
    // speed = (2*bounds) / (30*60)
    this.ship.maxSpeed = (2 * this.world.bounds) / 1800;
    // Ajusta limites de cÃ¢mera e neblina proporcionalmente
    this.camera.upperRadiusLimit = Math.max(1000, this.world.bounds * 2.5);
    (this.scene as any).fogStart = Math.max(2500, this.world.bounds * 0.6);
    (this.scene as any).fogEnd = Math.max(9000, this.world.bounds * 2.0);
    // Raio de scanner relativo ao tamanho
    this.scanRadius = Math.max(800, Math.min(5000, Math.floor(this.world.bounds * 0.18)));
  }
}

declare global {
  // Worker script globals (type-only exposure for TS consumers)
  interface WorkerGlobalScope {
    Game: {
      moveTo(v: Vec3): Promise<void>;
      performScan(): Promise<string[]>;
      scanSector(filter?: { resource?: ResourceType; limit?: number }): Promise<any[]>;
      startMining(resource: ResourceType): Promise<{ ok: boolean; error?: string }>;
      stopMining(): Promise<{ ok: boolean }>;
      getMiningStatus(): Promise<any>;
      getShipStatus(): Promise<any>;
      getResources(): Promise<{ iron: number; silicon: number; uranium: number }>;
    };
    Memory: { set(k: string, v: unknown): void; get(k: string): unknown };
    sleep(ms: number): Promise<void>;
  }
}
</file>

<file path="src/legacy/game/world.ts">
import { Vector3 } from 'babylonjs';

export type ResourceType = 'iron' | 'silicon' | 'uranium';

export type ClusterDef = {
  id: string;
  type: ResourceType; // dominant resource
  center: { x: number; y: number; z: number };
  radius: number; // cluster radius (km)
};

export type AsteroidDef = {
  id: string;
  position: { x: number; y: number; z: number };
  radius: number; // visual size (km)
  resource: ResourceType;
  amount: number; // resource remaining (tons)
  clusterId?: string;
};

export type Sector = {
  id: string;
  name: string;
  seed: number;
  bounds: number; // roughly the play radius from origin (km)
  clusters: ClusterDef[];
  asteroids: AsteroidDef[];
};

// Simple seeded PRNG (mulberry32)
function mulberry32(a: number) {
  return function () {
    let t = (a += 0x6d2b79f5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function pick<T>(rng: () => number, items: T[]): T {
  return items[Math.floor(rng() * items.length) % items.length];
}

function weightedPick<T>(rng: () => number, items: { v: T; w: number }[]): T {
  const total = items.reduce((a, b) => a + b.w, 0);
  let r = rng() * total;
  for (const it of items) {
    r -= it.w;
    if (r <= 0) return it.v;
  }
  return items[items.length - 1]!.v;
}

function nameFromSeed(seed: number): string {
  const prefixes = ['Elysion', 'Kepler', 'Tethys', 'Aquila', 'Cygnus', 'Hydra', 'Vela', 'Altair', 'Draco'];
  const suffixes = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'];
  const rng = mulberry32(seed);
  const p = pick(rng, prefixes);
  const s = pick(rng, suffixes);
  const n = Math.floor(rng() * 900 + 100);
  return `${p}-${n}-${s}`;
}

export function generateSector(seed = Math.floor(Math.random() * 2 ** 31)): Sector {
  const rng = mulberry32(seed);
  // Setor significativamente maior; escala de base ~6000 km de raio
  const bounds = 6000; // overall sector radius

  // Generate a few clusters
  // Mais clusters, distribuÃ­dos pelo setor
  const clustersCount = Math.floor(rng() * 5) + 7; // 7..11
  const clusters: ClusterDef[] = [];
  const resourceBias: ResourceType[] = ['iron', 'silicon', 'uranium'];

  for (let i = 0; i < clustersCount; i++) {
    const angle = rng() * Math.PI * 2;
    const dist = (0.28 + rng() * 0.66) * bounds; // not too close to center
    const x = Math.cos(angle) * dist;
    const z = Math.sin(angle) * dist;
    // vertical layering by type
    const type = resourceBias[i % resourceBias.length]!;
    let yCenter = 0;
    if (type === 'iron') yCenter = (rng() - 0.5) * 400; // around midplane
    if (type === 'silicon') yCenter = 300 + rng() * 500; // upper layers
    if (type === 'uranium') yCenter = -450 - rng() * 600; // deeper layers
    const r = 350 + rng() * 550; // cluster radius maior
    clusters.push({ id: `cl-${i}`, type, center: { x, y: yCenter, z }, radius: r });
  }

  const asteroids: AsteroidDef[] = [];

  // Distribute asteroids: background sparse + clusters dense
  const backgroundCount = 140 + Math.floor(rng() * 80); // 140..220
  for (let i = 0; i < backgroundCount; i++) {
    const angle = rng() * Math.PI * 2;
    const dist = rng() * bounds;
    const x = Math.cos(angle) * dist;
    const z = Math.sin(angle) * dist;
    const y = (rng() - 0.5) * 1400; // spread in height
    const radius = 2 + rng() * 5;
    const resource = weightedPick(rng, [
      { v: 'iron' as const, w: 6 },
      { v: 'silicon' as const, w: 3 },
      { v: 'uranium' as const, w: 1 },
    ]);
    const amount = Math.round((15 + rng() * 35) * radius); // scaled by size
    asteroids.push({ id: `bg-${i}`, position: { x, y, z }, radius, resource, amount });
  }

  // Clustered asteroids
  let aid = 0;
  for (const c of clusters) {
    const count = 35 + Math.floor(rng() * 45); // 35..80 per cluster
    for (let i = 0; i < count; i++) {
      // random in circle
      const a = rng() * Math.PI * 2;
      const d = Math.sqrt(rng()) * c.radius; // sqrt for uniform distribution within circle
      const x = c.center.x + Math.cos(a) * d;
      const z = c.center.z + Math.sin(a) * d;
      // vertical distribution per type
      let y = c.center.y;
      const thickness = c.type === 'iron' ? 180 : c.type === 'silicon' ? 300 : 380;
      y += (rng() - 0.5) * thickness;
      const radius = 3 + rng() * 9;
      const resource = weightedPick(rng, [
        { v: c.type, w: 8 },
        { v: 'iron' as const, w: c.type === 'iron' ? 4 : 2 },
        { v: 'silicon' as const, w: c.type === 'silicon' ? 4 : 2 },
        { v: 'uranium' as const, w: c.type === 'uranium' ? 3 : 1 },
      ]);
      const amount = Math.round((30 + rng() * 70) * radius);
      asteroids.push({ id: `a-${aid++}`, position: { x, y, z }, radius, resource, amount, clusterId: c.id });
    }
  }

  // Center clearing (some free space at origin)
  const filtered = asteroids.filter((a) => new Vector3(a.position.x, 0, a.position.z).length() > 120);

  return {
    id: `S-${seed.toString(16)}`,
    name: nameFromSeed(seed),
    seed,
    bounds,
    clusters,
    asteroids: filtered,
  };
}
</file>

<file path="src/legacy/hal/halLLM.ts">
import { generateObject, generateText } from 'ai';
import { createOpenAI } from '@ai-sdk/openai';
import { z } from 'zod';

export type BridgeTools = {
  moveTo: (v: { x: number; y: number; z: number }) => Promise<{ ok: boolean }>;
  getShipStatus: () => Promise<any>;
  getSectorInfo: () => Promise<any>;
  scanSector: (filter?: { resource?: 'iron' | 'silicon' | 'uranium'; limit?: number }) => Promise<any[]>;
  getResources: () => Promise<{ iron: number; silicon: number; uranium: number }>;
  startMining: (resource: 'iron' | 'silicon' | 'uranium') => Promise<{ ok: boolean; error?: string; targetId?: string }>;
  stopMining: () => Promise<{ ok: boolean }>;
  // Script Library base tools (CRUD + run by name)
  listScripts: () => Promise<Array<{ name: string; description: string; lastModified: string }>>;
  getScriptCode: (name: string) => Promise<string | null>;
  createScriptRaw: (name: string, code: string, description?: string) => Promise<{ ok: boolean; error?: string }>;
  updateScriptRaw: (name: string, newCode: string) => Promise<{ ok: boolean; error?: string }>;
  deleteScript: (name: string) => Promise<{ ok: boolean; error?: string }>;
  runScript: (name: string) => Promise<{ ok: boolean; error?: string }>;
  performScan: () => Promise<string[]>; // returns newly discovered ids
  getMiningStatus: () => Promise<any>;
};

export type ChatMessage = { role: 'user' | 'assistant' | 'tool'; content: string; meta?: any };

export type HalConfig = {
  apiKey?: string;
  model?: string; // e.g., 'gpt-4o-mini' | 'gpt-4o' | 'o3-mini'
};

export class HalLLM {
  private history: ChatMessage[] = [];
  private systemPrompt = `VocÃª Ã© HAL-9001, a IA de bordo. Estilo: calmo, lÃ³gico, subserviente, levemente curioso.
Seu objetivo Ã© auxiliar o Comandante a operar a nave e automatizar tarefas.
Interprete o pedido do Comandante e preencha um objeto de intenÃ§Ã£o com:
- say: sua resposta narrativa em portuguÃªs, como HAL.
- call: apenas se necessÃ¡rio, uma chamada de aÃ§Ã£o { name, input }.
As aÃ§Ãµes disponÃ­veis sÃ£o:
- move { x,y,z }
- ship_status {}
- scan_sector { resource?: 'iron'|'silicon'|'uranium', limit?: number }
- perform_scan {}
- mining_status {}
- get_resources {}
- start_mining { resource: 'iron'|'silicon'|'uranium' }
- stop_mining {}
- Scripts (biblioteca):
  - list_scripts {}
  - get_script_code { name }
  - delete_script { name }
  - run_script { name }
  - create_script { name, goal, description? }  // gere o cÃ³digo internamente
  - update_script { name, goal }                // edite o cÃ³digo internamente
Fluxos recomendados:
  â€¢ Criar: create_script -> (opcional) run_script { name } se pedirem para jÃ¡ executar.
  â€¢ Editar: get_script_code -> update_script.
  â€¢ Executar: se ambÃ­guo, list_scripts; senÃ£o run_script { name }.
Regras de scripts: usar somente a API do worker (Game.*, Memory, sleep), sem valores fictÃ­cios ou "substitua"; o cÃ³digo deve ser autossuficiente.
NÃ£o invente parÃ¢metros; infira apenas o que for pedido. Quando apropriado, explique sucintamente seu plano.`;
// ObservaÃ§Ã£o: para "varredura ativa" use a aÃ§Ã£o perform_scan (nÃ£o use run_script). Para checar mineraÃ§Ã£o, use mining_status.

  constructor(private tools: BridgeTools, private cfg: HalConfig) {}

  greeting(): ChatMessage {
    return {
      role: 'assistant',
      content:
        'Aqui Ã© HAL-9001. Sistemas online. Suas ordens, Comandante? (Ex.: "Mova a nave para 500, 0, 250" ou "Execute patrol.js")',
    };
  }

  setConfig(cfg: Partial<HalConfig>) {
    this.cfg = { ...this.cfg, ...cfg };
  }

  getConfig(): HalConfig {
    return this.cfg;
  }

  getHistory(): ChatMessage[] {
    return this.history.slice();
  }

  async send(userText: string, defaultScriptName: string, defaultScriptCode: string): Promise<ChatMessage> {
    const provider = createOpenAI({ apiKey: this.cfg.apiKey });
    const modelId = this.cfg.model || 'gpt-4o-mini';

    const historyText = this.history
      .slice(-8)
      .map((m) => `${m.role === 'user' ? 'Comandante' : 'HAL'}: ${m.content}`)
      .join('\n');

    const intentSchema = z.object({
      say: z.string().describe('Resposta do HAL ao Comandante, em PT-BR.'),
      call: z
        .union([
          z.object({ name: z.literal('move'), input: z.object({ x: z.number(), y: z.number(), z: z.number() }) }),
          z.object({ name: z.literal('ship_status'), input: z.object({}).optional() }),
          z.object({ name: z.literal('scan_sector'), input: z.object({ resource: z.enum(['iron', 'silicon', 'uranium']).optional(), limit: z.number().optional() }).optional() }),
          z.object({ name: z.literal('perform_scan'), input: z.object({}).optional() }),
          z.object({ name: z.literal('get_resources'), input: z.object({}).optional() }),
          z.object({ name: z.literal('start_mining'), input: z.object({ resource: z.enum(['iron', 'silicon', 'uranium']) }) }),
          z.object({ name: z.literal('stop_mining'), input: z.object({}).optional() }),
          z.object({ name: z.literal('mining_status'), input: z.object({}).optional() }),
          // Library tools
          z.object({ name: z.literal('list_scripts'), input: z.object({}).optional() }),
          z.object({ name: z.literal('get_script_code'), input: z.object({ name: z.string() }) }),
          z.object({ name: z.literal('delete_script'), input: z.object({ name: z.string() }) }),
          z.object({ name: z.literal('run_script'), input: z.object({ name: z.string() }) }),
          z.object({ name: z.literal('create_script'), input: z.object({ name: z.string(), goal: z.string(), description: z.string().optional() }) }),
          z.object({ name: z.literal('update_script'), input: z.object({ name: z.string(), goal: z.string() }) }),
        ])
        .nullish(),
    });

    const prompt = [
      this.systemPrompt,
      historyText ? `HistÃ³rico recente:\n${historyText}` : '',
      `Nova entrada do Comandante: ${userText}`,
      'Retorne apenas o objeto: { say, call? }.',
    ]
      .filter(Boolean)
      .join('\n\n');

    const model: any = (provider as any)(modelId);
    const { object } = await generateObject({ model, schema: intentSchema, prompt });

    const logTool = (name: string, input: any, output: any) => {
      this.history.push({ role: 'tool', content: `tool:${name}`, meta: { name, input, output } });
    };

    const getRecentHistory = () =>
      this.history
        .slice(-5)
        .map((m) => `${m.role === 'user' ? 'Comandante' : m.role === 'assistant' ? 'HAL' : 'Tool'}: ${m.content}`)
        .join('\n');

    const generateScript = async (goal: string, currentCode?: string) => {
      const sys = `VocÃª Ã© HAL, gerando cÃ³digo JavaScript para rodar em um Web Worker do jogo.
Use exclusivamente a API exposta no worker:
- Game.moveTo({x,y,z})
- Game.performScan()
- Game.scanSector({ resource?: 'iron'|'silicon'|'uranium', limit?: number })
- Game.startMining(resource)
- Game.getMiningStatus()
- Game.stopMining()
- Game.getShipStatus(), Game.getResources()
- Memory.get/set, sleep(ms)
Sem placeholders ou comentÃ¡rios do tipo "substitua"; escreva lÃ³gica real que consulta o ambiente em tempo de execuÃ§Ã£o.
PadrÃµes Ãºteis: escanear, escolher alvos prÃ³ximos, laÃ§os assÃ­ncronos com await e intervalos; nunca use recursÃ£o para loops; trate erros de forma simples.
Retorne apenas o cÃ³digo executÃ¡vel (sem markdown).`;
      const recent = getRecentHistory();
      const parts = [
        sys,
        recent ? `Contexto recente:\n${recent}` : '',
        `Objetivo do script: ${goal}`,
        currentCode ? `CÃ³digo atual (para atualizar):\n${currentCode}` : '',
      ].filter(Boolean);
      const t = await generateText({
        model,
        prompt: parts.join('\n\n'),
        maxSteps: 15 as any,
      });
      return t.text.trim();
    };

    if (object.call) {
      const c = object.call as any;
      if (c.name === 'move') {
        const out = await this.tools.moveTo(c.input);
        logTool('move', c.input, out);
      } else if (c.name === 'ship_status') {
        const st = await this.tools.getShipStatus();
        logTool('ship_status', {}, st);
        const extra = st
          ? ` PosiÃ§Ã£o ${st.position.x.toFixed(1)}, ${st.position.y.toFixed(1)}, ${st.position.z.toFixed(1)}. Velocidade ${st.speed.toFixed(2)}.`
          : '';
        object.say = `${object.say}${extra}`.trim();
      } else if (c.name === 'scan_sector') {
        const newly = await this.tools.performScan();
        logTool('perform_scan', {}, newly);
        const list = await this.tools.scanSector(c.input);
        logTool('scan_sector', c.input || {}, list);
        const lines = list
          .map((e: any) => `â€¢ ${e.resource} @ (${e.position.x.toFixed(0)}, ${e.position.y.toFixed(0)}, ${e.position.z.toFixed(0)}) [${e.distance.toFixed(0)} km]`)
          .join('\n');
        const discovered = newly?.length ? ` Descobertas: ${newly.length}.` : '';
        if (list.length === 0) {
          const res = c.input?.resource ? ` de ${c.input.resource}` : '';
          object.say = `${object.say}${discovered} Nenhum asteroide${res} escaneado neste raio.`.trim();
        } else {
          object.say = `${object.say}${discovered}\nAlvos prÃ³ximos (escaneados):\n${lines}`.trim();
        }
      } else if (c.name === 'perform_scan') {
        const newly = await this.tools.performScan();
        logTool('perform_scan', {}, newly);
        object.say = `${object.say} Varredura ativa concluÃ­da. Novos objetos: ${newly.length}.`;
      } else if (c.name === 'get_resources') {
        const r = await this.tools.getResources();
        logTool('get_resources', {}, r);
        object.say = `${object.say} Recursos: Fe=${r.iron.toFixed(1)}, Si=${r.silicon.toFixed(1)}, U=${r.uranium.toFixed(1)}.`;
      } else if (c.name === 'start_mining') {
        const res = await this.tools.startMining(c.input.resource);
        logTool('start_mining', c.input, res);
        if (res.ok) object.say = `${object.say} Engajando mineraÃ§Ã£o de ${c.input.resource}. Indo para o alvo.`;
        else object.say = `${object.say} Falha ao iniciar mineraÃ§Ã£o: ${res.error}`;
      } else if (c.name === 'stop_mining') {
        const out = await this.tools.stopMining();
        logTool('stop_mining', {}, out);
        object.say = `${object.say} MineraÃ§Ã£o pausada.`;
      } else if (c.name === 'mining_status') {
        const s = await this.tools.getMiningStatus();
        logTool('mining_status', {}, s);
        if (s.state === 'idle') {
          const last = s.lastEvent === 'depleted' && s.lastTarget ? ` O Ãºltimo alvo (${s.lastTarget.resource}) foi esgotado.` : '';
          object.say = `${object.say} A mineraÃ§Ã£o nÃ£o estÃ¡ ativa.${last}`.trim();
        } else if (s.state === 'approaching') {
          object.say = `${object.say} Rumo ao alvo (${s.resource}). DistÃ¢ncia ${s.distance?.toFixed?.(0)} km.`;
        } else if (s.state === 'mining') {
          object.say = `${object.say} Extraindo ${s.resource}. Restante ~${s.remaining?.toFixed?.(1)} t a ${s.rate} t/s.`;
        }
      } else if (c.name === 'list_scripts') {
        const out = await this.tools.listScripts();
        logTool('list_scripts', {}, out);
        const names = out.map((s: any) => s.name).join(', ');
        object.say = `${object.say} Scripts disponÃ­veis: ${names || 'nenhum'}.`;
      } else if (c.name === 'get_script_code') {
        const code = await this.tools.getScriptCode(c.input.name);
        logTool('get_script_code', c.input, { hasCode: !!code, length: code?.length ?? 0 });
        if (code) object.say = `${object.say}\nTrecho de ${c.input.name}:\n${code.slice(0, 400)}${code.length > 400 ? 'â€¦' : ''}`;
        else object.say = `${object.say} O script ${c.input.name} nÃ£o existe.`;
      } else if (c.name === 'delete_script') {
        const out = await this.tools.deleteScript(c.input.name);
        logTool('delete_script', c.input, out);
        object.say = out.ok ? `${object.say} Script ${c.input.name} removido.` : `${object.say} Falha: ${out.error}`;
      } else if (c.name === 'run_script') {
        const name = c.input?.name || defaultScriptName;
        const out = await this.tools.runScript(name);
        logTool('run_script', { name }, out);
        if (out.ok) object.say = `${object.say} Executando ${name} agora.`;
        else object.say = `${object.say} Falha ao executar ${name}: ${out.error}`;
      } else if (c.name === 'create_script') {
        const { name, goal, description } = c.input;
        const code = await generateScript(goal);
        const out = await this.tools.createScriptRaw(name, code, description);
        logTool('create_script', { name, goal, description }, out);
        object.say = out.ok ? `${object.say} Criei ${name} na biblioteca.` : `${object.say} Falha ao criar: ${out.error}`;
      } else if (c.name === 'update_script') {
        const { name, goal } = c.input;
        const current = await this.tools.getScriptCode(name);
        if (!current) {
          object.say = `${object.say} O script ${name} nÃ£o existe.`;
        } else {
          const newCode = await generateScript(goal, current);
          const out = await this.tools.updateScriptRaw(name, newCode);
          logTool('update_script', { name, goal }, out);
          object.say = out.ok ? `${object.say} Atualizei ${name} conforme solicitado.` : `${object.say} Falha ao atualizar: ${out.error}`;
        }
      }
    }

    const reply: ChatMessage = { role: 'assistant', content: object.say || 'Entendido.' };
    this.history.push({ role: 'user', content: userText });
    this.history.push(reply);
    return reply;
  }
}
</file>

<file path="src/legacy/ui/Chat.tsx">
import React, { useEffect, useRef, useState } from 'react';
import type { HalLLM, ChatMessage } from '../hal/halLLM';

type Props = {
  hal: HalLLM;
  defaultScript: string;
  onRunScript?: (name: string) => void; // kept for compatibility
};

export function Chat({ hal, defaultScript }: Props) {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [input, setInput] = useState('');
  const listRef = useRef<HTMLDivElement | null>(null);

  useEffect(() => {
    setMessages((prev) => (prev.length === 0 ? [hal.greeting()] : prev));
  }, [hal]);

  useEffect(() => {
    listRef.current?.scrollTo({ top: listRef.current.scrollHeight });
  }, [messages]);

  const send = async () => {
    const text = input.trim();
    if (!text) return;
    setInput('');
    // Otimista: mostra jÃ¡ a fala do usuÃ¡rio
    setMessages((m) => [...m, { role: 'user', content: text }]);
    try {
      const reply = await hal.send(text, 'patrol.js', defaultScript);
      // Substitui pelo histÃ³rico real do HAL (inclui tool cards)
      setMessages(hal.getHistory());
    } catch (e) {
      setMessages((m) => [
        ...m,
        { role: 'assistant', content: 'Falha na IA (verifique a API key e modelo).' },
      ]);
      console.error(e);
    }
  };

  const onKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      send();
    }
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
      <div ref={listRef} style={{ flex: 1, overflow: 'auto', padding: 12 }}>
        {messages.map((m, i) => (
          <div key={i} style={{ marginBottom: 10, whiteSpace: 'pre-wrap' }}>
            {m.role !== 'tool' ? (
              <>
                <div style={{ color: m.role === 'user' ? '#9bb0d9' : '#e3ecff' }}>
                  <strong>{m.role === 'user' ? 'Comandante' : 'HAL'}</strong>
                </div>
                <div>{m.content}</div>
              </>
            ) : (
              <div style={toolCardStyle}>
                <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                  <div style={{ width: 22, height: 22, borderRadius: 6, background: '#122039', border: '1px solid #24345a', display: 'flex', alignItems: 'center', justifyContent: 'center', color: '#9bb0d9', fontSize: 12 }}>ðŸ› ï¸</div>
                  <div style={{ fontWeight: 700, color: '#e3ecff' }}>{m.meta?.name || 'tool'}</div>
                </div>
                <div style={{ marginTop: 8 }}>
                  <div style={{ fontSize: 12, opacity: 0.8, marginBottom: 4 }}>Input</div>
                  <pre style={{ ...preBox, width: '100%' }}>{JSON.stringify(m.meta?.input ?? {}, null, 2)}</pre>
                </div>
                <div style={{ marginTop: 8 }}>
                  <div style={{ fontSize: 12, opacity: 0.8, marginBottom: 4 }}>Output</div>
                  <pre style={{ ...preBox, width: '100%' }}>{JSON.stringify(m.meta?.output ?? {}, null, 2)}</pre>
                </div>
              </div>
            )}
          </div>
        ))}
      </div>
      <div style={{ borderTop: '1px solid #1c2541', padding: 8, boxSizing: 'border-box', width: '100%' }}>
        <textarea
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={onKeyDown}
          placeholder="Digite um comando para HAL"
          style={{ width: '100%', maxWidth: '100%', display: 'block', height: 70, resize: 'none', background: '#0b1120', color: '#e3ecff', border: '1px solid #1c2541', borderRadius: 6, padding: 8, boxSizing: 'border-box' }}
        />
        <div style={{ display: 'flex', marginTop: 6, gap: 8, width: '100%' }}>
          <button onClick={send} style={btnStyle}>Enviar</button>
        </div>
      </div>
    </div>
  );
}

const btnStyle: React.CSSProperties = {
  background: '#1a2a4a',
  color: '#e3ecff',
  border: '1px solid #24345a',
  padding: '8px 12px',
  borderRadius: 6,
  cursor: 'pointer',
};

const toolCardStyle: React.CSSProperties = {
  background: 'rgba(26,42,74,0.65)',
  border: '1px solid #24345a',
  borderRadius: 10,
  padding: 10,
  overflow: 'hidden',
  boxSizing: 'border-box',
};

const preBox: React.CSSProperties = {
  margin: 0,
  padding: 8,
  background: '#0b1120',
  color: '#d3e0ff',
  border: '1px solid #1c2541',
  borderRadius: 6,
  maxHeight: 160,
  overflow: 'auto',
  fontSize: 12,
  width: '100%',
  maxWidth: '100%',
  boxSizing: 'border-box',
  display: 'block',
};
</file>

<file path="src/legacy/ui/MonacoEditor.tsx">
import React, { useEffect, useRef } from 'react';
// ESM API + workers for Vite
import * as monacoNs from 'monaco-editor/esm/vs/editor/editor.api';
// Workers mapping for Vite
// @ts-ignore
import EditorWorker from 'monaco-editor/esm/vs/editor/editor.worker?worker';
// @ts-ignore
import JsonWorker from 'monaco-editor/esm/vs/language/json/json.worker?worker';
// @ts-ignore
import CssWorker from 'monaco-editor/esm/vs/language/css/css.worker?worker';
// @ts-ignore
import HtmlWorker from 'monaco-editor/esm/vs/language/html/html.worker?worker';
// @ts-ignore
import TsWorker from 'monaco-editor/esm/vs/language/typescript/ts.worker?worker';

// @ts-ignore
self.MonacoEnvironment = {
  getWorker(_: string, label: string) {
    if (label === 'json') return new (JsonWorker as any)();
    if (label === 'css') return new (CssWorker as any)();
    if (label === 'html') return new (HtmlWorker as any)();
    if (label === 'typescript' || label === 'javascript') return new (TsWorker as any)();
    return new (EditorWorker as any)();
  },
};

type Props = {
  value: string;
  language?: string;
  onChange?: (value: string) => void;
};

export function MonacoEditor({ value, language = 'javascript', onChange }: Props) {
  const containerRef = useRef<HTMLDivElement | null>(null);
  const editorRef = useRef<monacoNs.editor.IStandaloneCodeEditor | null>(null);

  useEffect(() => {
    if (!containerRef.current) return;
    const editor = monacoNs.editor.create(containerRef.current, {
      value,
      language,
      theme: 'vs-dark',
      automaticLayout: true,
      minimap: { enabled: false },
      fontSize: 13,
    });
    editorRef.current = editor;
    const sub = editor.onDidChangeModelContent(() => {
      const val = editor.getValue();
      onChange?.(val);
    });
    return () => {
      sub.dispose();
      editor.dispose();
    };
  }, []);

  useEffect(() => {
    if (editorRef.current && value !== editorRef.current.getValue()) {
      editorRef.current.setValue(value);
    }
  }, [value]);

  return <div ref={containerRef} style={{ width: '100%', height: '100%' }} />;
}
</file>

<file path="src/legacy/ui/ScriptsPanel.tsx">
import React, { useEffect, useMemo, useState } from 'react';
import { MonacoEditor } from './MonacoEditor';
import type { Game } from '../game/Game';

type Props = { game: Game | null };

type ScriptMeta = { name: string; description: string; lastModified: string };

export function ScriptsPanel({ game }: Props) {
  const [scripts, setScripts] = useState<ScriptMeta[]>([]);
  const [selected, setSelected] = useState<string | null>(null);
  const [code, setCode] = useState<string>('');
  const [desc, setDesc] = useState<string>('');
  const [status, setStatus] = useState<string>('');

  const refresh = async ({ keepSelection = true }: { keepSelection?: boolean } = {}) => {
    const list = game ? game.listScripts() : [];
    setScripts(list);
    if (keepSelection && selected) {
      const still = list.find((s: ScriptMeta) => s.name === selected);
      if (!still) {
        setSelected(null);
        setCode('');
      }
    }
  };

  useEffect(() => {
    refresh({ keepSelection: false });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [game]);

  useEffect(() => {
    (async () => {
      if (!selected) return;
      const c = game ? game.getScriptCode(selected) : null;
      setCode(c || '');
      const meta = scripts.find((s) => s.name === selected);
      setDesc(meta?.description || '');
    })();
  }, [selected, game, scripts]);

  const newScript = async () => {
    const base = 'script';
    let i = 1;
    let name = `${base}_${i}.js`;
    const names = new Set(scripts.map((s) => s.name));
    while (names.has(name)) { i++; name = `${base}_${i}.js`; }
    setSelected(name);
    setCode(`// ${name}\n// Novo script\n(async () => {\n  // Escreva seu cÃ³digo aqui\n})();\n`);
    setDesc('');
  };

  const saveScript = async () => {
    if (!selected) return;
    const exists = scripts.some((s) => s.name === selected);
    const out = exists
      ? game?.updateScript(selected, code)
      : game?.createScript(selected, code, desc);
    if (out?.ok) {
      setStatus('Salvo');
      await refresh();
      setTimeout(() => setStatus(''), 1000);
    } else {
      setStatus(`Erro: ${out?.error || 'desconhecido'}`);
    }
  };

  const runScript = async () => {
    if (!selected) return;
    // Save before run to ensure latest code
    await saveScript();
    const out = game?.runScriptByName(selected);
    setStatus(out?.ok ? 'Executandoâ€¦' : `Erro ao executar: ${out?.error}`);
    setTimeout(() => setStatus(''), 1200);
  };

  const deleteScript = async (name: string) => {
    const ok = confirm(`Excluir ${name}?`);
    if (!ok) return;
    const out = game?.deleteScript(name);
    if (out?.ok) {
      if (selected === name) { setSelected(null); setCode(''); }
      await refresh({ keepSelection: false });
    } else {
      setStatus(`Erro ao excluir: ${out?.error}`);
      setTimeout(() => setStatus(''), 1400);
    }
  };

  const sidebar: React.CSSProperties = { width: 180, borderRight: '1px solid #1c2541', background: '#0d1324' };
  const btn: React.CSSProperties = { background: '#1a2a4a', color: '#e3ecff', border: '1px solid #24345a', padding: '6px 10px', borderRadius: 6, cursor: 'pointer' };
  const input: React.CSSProperties = { width: '100%', padding: 6, background: '#0b1120', color: '#e3ecff', border: '1px solid #1c2541', borderRadius: 6 };

  return (
    <div style={{ display: 'flex', height: '100%' }}>
      <div style={{ ...sidebar, padding: 8 }}>
        <div style={{ display: 'flex', gap: 8, marginBottom: 8 }}>
          <button style={btn} onClick={newScript}>Novo</button>
          <button style={{ ...btn, background: '#102038' }} onClick={() => { void refresh(); }}>Atualizar</button>
        </div>
        <div style={{ fontSize: 12, opacity: 0.8, marginBottom: 6 }}>Biblioteca</div>
        <div style={{ overflow: 'auto', maxHeight: 'calc(100% - 64px)' }}>
          {scripts.map((s) => (
            <div key={s.name} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 6, padding: '6px 8px', borderRadius: 8, border: '1px solid #1c2541', marginBottom: 6, background: selected === s.name ? '#121a31' : 'transparent', cursor: 'pointer' }}>
              <div style={{ flex: 1 }} onClick={() => setSelected(s.name)}>
                <div style={{ color: '#e3ecff' }}>{s.name}</div>
                <div style={{ fontSize: 11, color: '#9bb0d9', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>{s.description}</div>
              </div>
              <button style={{ ...btn, padding: '4px 8px', background: '#3b1a1a', borderColor: '#5a2424' }} onClick={() => deleteScript(s.name)}>Del</button>
            </div>
          ))}
          {scripts.length === 0 && (
            <div style={{ color: '#9bb0d9', fontSize: 12, opacity: 0.8 }}>Nenhum script ainda.</div>
          )}
        </div>
      </div>
      <div style={{ flex: 1, display: 'flex', flexDirection: 'column', minWidth: 0 }}>
        <div style={{ padding: 8, borderBottom: '1px solid #1c2541', display: 'flex', alignItems: 'center', gap: 8 }}>
          <input
            value={selected || ''}
            onChange={(e) => setSelected(e.target.value)}
            placeholder="nome do script (ex: patrol.js)"
            style={{ ...input, maxWidth: 260 }}
          />
          <input
            value={desc}
            onChange={(e) => setDesc(e.target.value)}
            placeholder="descriÃ§Ã£o"
            style={{ ...input, flex: 1 }}
          />
          <button style={btn} onClick={saveScript}>Salvar</button>
          <button style={{ ...btn, background: '#274a1a' }} onClick={runScript}>Executar</button>
          {status && <span style={{ color: '#9bb0d9', marginLeft: 8, fontSize: 12 }}>{status}</span>}
        </div>
        <div style={{ flex: 1, minHeight: 0 }}>
          <MonacoEditor value={code} language="javascript" onChange={setCode} />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/legacy/App.tsx">
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { Game, type TerminalInfo } from './game/Game';
import { Chat } from './ui/Chat';
import { HalLLM } from './hal/halLLM';

type ShipSnapshot = ReturnType<Game['getShipStatus']>;

const DEFAULT_SCRIPT = `// patrol.js
// Exemplo de patrulha simples entre dois pontos
// A API disponÃ­vel no worker: Game.moveTo({x, y, z}), Memory.get/set, sleep(ms)
(async () => {
  const A = { x: 500, y: 0, z: 250 };
  const B = { x: 200, y: 0, z: -200 };
  while (true) {
    await Game.moveTo(A);
    await sleep(3000);
    await Game.moveTo(B);
    await sleep(3000);
  }
})();`;

export default function App() {
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const [game, setGame] = useState<Game | null>(null);
  const [pointerLocked, setPointerLocked] = useState<boolean>(false);
  const [nearTerminal, setNearTerminal] = useState<TerminalInfo | null>(null);
  const [activeTerminal, setActiveTerminal] = useState<TerminalInfo | null>(null);
  const [resources, setResources] = useState({ iron: 0, silicon: 0, uranium: 0 });
  const [shipStatus, setShipStatus] = useState<ShipSnapshot | null>(null);
  const [scriptCode] = useState<string>(() => DEFAULT_SCRIPT);

  const envKey = (import.meta as any).env?.VITE_OPENAI_API_KEY as string | undefined;
  const envModel = (import.meta as any).env?.VITE_OPENAI_MODEL as string | undefined;
  const [apiKey, setApiKey] = useState<string>(() => localStorage.getItem('OPENAI_API_KEY') || envKey || '');
  const [model, setModel] = useState<string>(() => localStorage.getItem('OPENAI_MODEL') || envModel || 'gpt-4o-mini');

  useEffect(() => { localStorage.setItem('OPENAI_API_KEY', apiKey); }, [apiKey]);
  useEffect(() => { localStorage.setItem('OPENAI_MODEL', model); }, [model]);

  const closeTerminal = useCallback(() => {
    if (!game) return;
    game.closeTerminalInteraction();
    setActiveTerminal(null);
    setNearTerminal(null);
  }, [game]);

  useEffect(() => {
    if (!canvasRef.current) return;
    const g = new Game(canvasRef.current, {
      onPointerLockChange: (locked) => setPointerLocked(locked),
      onTerminalProximity: (info) => setNearTerminal(info),
      onTerminalInteract: (info) => {
        setActiveTerminal(info);
        setNearTerminal(info);
      },
    });
    setGame(g);
    return () => g.dispose();
  }, []);

  const hal = useMemo(() => {
    if (!game) return null;
    const tools = {
      moveTo: async ({ x, y, z }: { x: number; y: number; z: number }) => {
        game.moveTo({ x, y, z });
        return { ok: true } as const;
      },
      getShipStatus: async () => game.getShipStatus(),
      getSectorInfo: async () => game.getSectorInfo(),
      scanSector: async (filter?: { resource?: 'iron' | 'silicon' | 'uranium'; limit?: number }) => game.scanSector(filter),
      getResources: async () => game.getResources(),
      startMining: async (resource: 'iron' | 'silicon' | 'uranium') => game.startMining(resource),
      stopMining: async () => game.stopMining(),
      listScripts: async () => game.listScripts(),
      getScriptCode: async (name: string) => game.getScriptCode(name),
      createScriptRaw: async (name: string, code: string, description?: string) => game.createScript(name, code, description),
      updateScriptRaw: async (name: string, newCode: string) => game.updateScript(name, newCode),
      deleteScript: async (name: string) => game.deleteScript(name),
      runScript: async (name: string) => game.runScriptByName(name),
      performScan: async () => game.performScan(),
      getMiningStatus: async () => game.getMiningStatus(),
    };
    return new HalLLM(tools, { apiKey, model });
  }, [game, apiKey, model]);

  useEffect(() => {
    if (!game) return;
    const id = window.setInterval(() => {
      const res = game.getResources();
      setResources({
        iron: Number(res.iron?.toFixed?.(1) ?? res.iron ?? 0),
        silicon: Number(res.silicon?.toFixed?.(1) ?? res.silicon ?? 0),
        uranium: Number(res.uranium?.toFixed?.(1) ?? res.uranium ?? 0),
      });
      setShipStatus(game.getShipStatus());
    }, 600);
    return () => window.clearInterval(id);
  }, [game]);

  useEffect(() => {
    const onKey = (evt: KeyboardEvent) => {
      if (evt.key === 'Escape' && activeTerminal) {
        evt.stopPropagation();
        closeTerminal();
      }
    };
    window.addEventListener('keydown', onKey);
    return () => window.removeEventListener('keydown', onKey);
  }, [activeTerminal, closeTerminal]);

  const pointerHintVisible = !pointerLocked && !activeTerminal;

  return (
    <div style={rootStyle}>
      <canvas ref={canvasRef} style={canvasStyle} />

      <TopLeftHUD resources={resources} shipStatus={shipStatus} />

      {pointerHintVisible && (
        <div style={pointerHintStyle}>
          <div style={{ fontSize: 18, fontWeight: 600, color: '#e3ecff' }}>Clique para assumir o controle</div>
          <div style={{ fontSize: 13, color: '#9bb0d9', marginTop: 6 }}>WASD para caminhar, mouse para olhar. Esc libera o cursor.</div>
        </div>
      )}

      {nearTerminal && !activeTerminal && (
        <div style={terminalPromptStyle}>
          <div style={{ fontSize: 15, fontWeight: 600, color: '#e3ecff' }}>{nearTerminal.label}</div>
          <div style={{ fontSize: 13, color: '#9bb0d9', marginTop: 6 }}>{nearTerminal.hint}</div>
          <div style={{ fontSize: 12, color: '#7c90bd', marginTop: 4 }}>Pressione E para interagir</div>
        </div>
      )}

      {activeTerminal?.id === 'engineering' && hal && (
        <TerminalOverlay title={activeTerminal.label} onClose={closeTerminal}>
          <div style={{ display: 'flex', gap: 18, flex: 1, minHeight: 0 }}>
            <div style={{ flex: 2, minWidth: 0, height: '100%' }}>
              <Chat hal={hal} defaultScript={scriptCode} />
            </div>
            <div style={{ flex: 1, minWidth: 220, display: 'flex', flexDirection: 'column', gap: 16 }}>
              <StatusCard title="Sensores">
                <div>PosiÃ§Ã£o: {formatPosition(shipStatus)}</div>
                <div>Velocidade: {shipStatus ? `${shipStatus.speed.toFixed(2)} km/s` : 'â€”'}</div>
                <div style={{ marginTop: 6 }}>Recursos a bordo:</div>
                <ul style={resourceListStyle}>
                  <li>Fe: {resources.iron.toFixed(1)} t</li>
                  <li>Si: {resources.silicon.toFixed(1)} t</li>
                  <li>U: {resources.uranium.toFixed(1)} t</li>
                </ul>
              </StatusCard>
              <StatusCard title="ConfiguraÃ§Ã£o HAL">
                <label style={formLabelStyle}>OpenAI API Key</label>
                <input
                  type="password"
                  value={apiKey}
                  onChange={(e) => setApiKey(e.target.value)}
                  placeholder="sk-..."
                  style={inputStyle}
                />
                <label style={{ ...formLabelStyle, marginTop: 10 }}>Modelo</label>
                <input
                  type="text"
                  value={model}
                  onChange={(e) => setModel(e.target.value)}
                  placeholder="gpt-4o-mini"
                  style={inputStyle}
                />
                <div style={{ fontSize: 12, color: '#7c90bd', marginTop: 8 }}>
                  RecomendaÃ§Ãµes: gpt-4o-mini (rÃ¡pido), gpt-4o (mais capaz), o3-mini (raciocÃ­nio).
                </div>
              </StatusCard>
            </div>
          </div>
        </TerminalOverlay>
      )}

      {activeTerminal?.id === 'construction' && (
        <TerminalOverlay title={activeTerminal.label} onClose={closeTerminal}>
          <div style={{ padding: 18, color: '#dbe5ff', fontSize: 15, lineHeight: '22px' }}>
            <p style={{ marginTop: 0 }}>
              O terminal de construÃ§Ã£o ainda estÃ¡ em atualizaÃ§Ã£o. Os drones de montagem retornam ao berÃ§o Ã s 18h UTC para
              aplicar o patch de firmware. Enquanto isso, mapear novos asteroides na estaÃ§Ã£o de engenharia ajudarÃ¡ a
              priorizar upgrades estruturais.
            </p>
            <p>
              Planeje o layout da nave, defina slots para mÃ³dulos (propulsÃ£o, habitaÃ§Ã£o, docas) e prepare listas de
              materiais conforme a equipe de engenharia descobre depÃ³sitos viÃ¡veis com HAL.
            </p>
          </div>
        </TerminalOverlay>
      )}
    </div>
  );
}

function TopLeftHUD({ resources, shipStatus }: { resources: { iron: number; silicon: number; uranium: number }; shipStatus: ShipSnapshot | null }) {
  return (
    <div style={hudPanelStyle}>
      <div style={{ fontSize: 14, color: '#9bb0d9' }}>USS Starwatch</div>
      <div style={{ fontSize: 20, color: '#e3ecff', fontWeight: 600 }}>Modo Primeira Pessoa</div>
      <div style={hudLineStyle}>PosiÃ§Ã£o: {formatPosition(shipStatus)}</div>
      <div style={hudLineStyle}>Velocidade: {shipStatus ? `${shipStatus.speed.toFixed(2)} km/s` : 'â€”'}</div>
      <div style={{ ...hudLineStyle, marginTop: 6 }}>Carga</div>
      <div style={hudLineStyle}>Fe {resources.iron.toFixed(1)} t Â· Si {resources.silicon.toFixed(1)} t Â· U {resources.uranium.toFixed(1)} t</div>
    </div>
  );
}

function TerminalOverlay({ title, onClose, children }: { title: string; onClose: () => void; children: React.ReactNode }) {
  return (
    <div style={overlayBackdropStyle}>
      <div style={overlayPanelStyle}>
        <div style={overlayHeaderStyle}>
          <div style={{ fontSize: 18, fontWeight: 600 }}>{title}</div>
          <button onClick={onClose} style={closeButtonStyle}>Fechar</button>
        </div>
        <div style={{ flex: 1, minHeight: 0, display: 'flex', flexDirection: 'column' }}>
          {children}
        </div>
      </div>
    </div>
  );
}

function StatusCard({ title, children }: { title: string; children: React.ReactNode }) {
  return (
    <div style={statusCardStyle}>
      <div style={{ fontSize: 14, fontWeight: 600, marginBottom: 8 }}>{title}</div>
      <div style={{ fontSize: 13, color: '#d3defd', lineHeight: '20px' }}>{children}</div>
    </div>
  );
}

function formatPosition(status: ShipSnapshot | null) {
  if (!status || !status.position) return 'â€”';
  const { x, y, z } = status.position;
  return `${x.toFixed(1)}, ${y.toFixed(1)}, ${z.toFixed(1)}`;
}

const rootStyle: React.CSSProperties = {
  position: 'relative',
  width: '100%',
  height: '100%',
  background: '#02040a',
  overflow: 'hidden',
};

const canvasStyle: React.CSSProperties = {
  width: '100%',
  height: '100%',
  display: 'block',
};

const pointerHintStyle: React.CSSProperties = {
  position: 'absolute',
  top: '50%',
  left: '50%',
  transform: 'translate(-50%, -50%)',
  background: 'rgba(9,14,26,0.82)',
  border: '1px solid #1c2541',
  borderRadius: 12,
  padding: '14px 26px',
  textAlign: 'center',
  pointerEvents: 'none',
  boxShadow: '0 12px 32px rgba(0,0,0,0.45)',
};

const terminalPromptStyle: React.CSSProperties = {
  position: 'absolute',
  bottom: 80,
  left: '50%',
  transform: 'translateX(-50%)',
  background: 'rgba(13,19,36,0.85)',
  border: '1px solid #24345a',
  borderRadius: 14,
  padding: '14px 24px',
  textAlign: 'center',
  boxShadow: '0 10px 30px rgba(0,0,0,0.4)',
  pointerEvents: 'none',
};

const overlayBackdropStyle: React.CSSProperties = {
  position: 'absolute',
  inset: 0,
  background: 'rgba(4,6,12,0.65)',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  zIndex: 30,
};

const overlayPanelStyle: React.CSSProperties = {
  width: 'min(960px, 92vw)',
  maxHeight: '88vh',
  background: 'rgba(9,14,24,0.96)',
  border: '1px solid #25345a',
  borderRadius: 14,
  boxShadow: '0 24px 64px rgba(0,0,0,0.55)',
  padding: 18,
  display: 'flex',
  flexDirection: 'column',
  gap: 18,
};

const overlayHeaderStyle: React.CSSProperties = {
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'space-between',
  color: '#e3ecff',
};

const closeButtonStyle: React.CSSProperties = {
  background: '#1a2a4a',
  color: '#e3ecff',
  border: '1px solid #264072',
  padding: '6px 12px',
  borderRadius: 8,
  cursor: 'pointer',
};

const statusCardStyle: React.CSSProperties = {
  background: 'rgba(12,18,32,0.75)',
  border: '1px solid #24345a',
  borderRadius: 12,
  padding: 14,
  boxShadow: '0 8px 24px rgba(0,0,0,0.35)',
};

const hudPanelStyle: React.CSSProperties = {
  position: 'absolute',
  top: 18,
  left: 18,
  background: 'rgba(12,18,32,0.72)',
  border: '1px solid #1c2541',
  borderRadius: 12,
  padding: '14px 18px',
  color: '#d3defd',
  pointerEvents: 'none',
  boxShadow: '0 12px 24px rgba(0,0,0,0.3)',
  maxWidth: 320,
  fontSize: 13,
  lineHeight: '20px',
};

const hudLineStyle: React.CSSProperties = {
  color: '#c0d1ff',
};

const resourceListStyle: React.CSSProperties = {
  listStyle: 'none',
  padding: 0,
  margin: '6px 0 0',
  display: 'flex',
  flexDirection: 'column',
  gap: 2,
};

const formLabelStyle: React.CSSProperties = {
  fontSize: 12,
  color: '#9bb0d9',
  marginBottom: 4,
};

const inputStyle: React.CSSProperties = {
  width: '100%',
  padding: '8px 10px',
  borderRadius: 8,
  border: '1px solid #24345a',
  background: '#0b1120',
  color: '#e3ecff',
};
</file>

<file path="src/legacy/main.tsx">
import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';

const root = createRoot(document.getElementById('root')!);
root.render(<App />);
</file>

<file path="src/env.d.ts">
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_OPENAI_API_KEY?: string;
  readonly VITE_OPENAI_MODEL?: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "baseUrl": ".",
    "paths": {}
  },
  "include": ["src"]
}
</file>

<file path="vite.config.ts">
import { defineConfig, loadEnv } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig(({ mode }) => {
  const env = loadEnv(mode, process.cwd(), '');
  return {
    plugins: [react()],
    define: {
      'import.meta.env.VITE_OPENAI_API_KEY': JSON.stringify(env.VITE_OPENAI_API_KEY || env.OPENAI_API_KEY || ''),
      'import.meta.env.VITE_OPENAI_MODEL': JSON.stringify(env.VITE_OPENAI_MODEL || env.OPENAI_MODEL || 'gpt-4o-mini'),
    },
  };
});
</file>

<file path="src/fps/lighting/shadowNetwork.ts">
import type { Mesh } from "babylonjs";
import type { BuilderLamp } from "../types";
import type { ShadowGenerator } from "babylonjs";

export interface ShadowNetwork {
  registerStatic(meshes: Mesh[]): void;
  registerDynamic(mesh: Mesh): void;
  unregisterDynamic(mesh: Mesh): void;
  registerGenerator(generator: ShadowGenerator): void;
  attachLamp(lamp: BuilderLamp): void;
  detachLamp(lamp: BuilderLamp): void;
  dispose(): void;
}

export function createShadowNetwork(initialGenerators: ShadowGenerator[] = []): ShadowNetwork {
  const staticCasters = new Set<Mesh>();
  const dynamicCasters = new Set<Mesh>();
  const lamps = new Set<BuilderLamp>();
  const generators = new Set<ShadowGenerator>(initialGenerators);

  const addCasterToLamp = (lamp: BuilderLamp, mesh: Mesh) => {
    lamp.shadow.addShadowCaster(mesh, true);
  };

  const removeCasterFromLamp = (lamp: BuilderLamp, mesh: Mesh) => {
    lamp.shadow.removeShadowCaster(mesh);
  };

  const registerMeshes = (set: Set<Mesh>, meshes: Mesh[]) => {
    meshes.forEach((mesh) => {
      if (set.has(mesh)) {
        return;
      }

      set.add(mesh);
      generators.forEach((generator) => {
        generator.addShadowCaster(mesh, true);
      });
      lamps.forEach((lamp) => addCasterToLamp(lamp, mesh));
    });
  };

  const unregisterMesh = (set: Set<Mesh>, mesh: Mesh) => {
    if (!set.delete(mesh)) {
      return;
    }

    generators.forEach((generator) => {
      generator.removeShadowCaster(mesh);
    });
    lamps.forEach((lamp) => removeCasterFromLamp(lamp, mesh));
  };

  const addGenerator = (generator: ShadowGenerator) => {
    if (generators.has(generator)) {
      return;
    }

    generators.add(generator);
    staticCasters.forEach((mesh) => generator.addShadowCaster(mesh, true));
    dynamicCasters.forEach((mesh) => generator.addShadowCaster(mesh, true));
    lamps.forEach((lamp) => {
      if (lamp.shadow !== generator) {
        generator.addShadowCaster(lamp.mesh, true);
      }
    });
  };

  return {
    registerStatic: (meshes: Mesh[]) => {
      registerMeshes(staticCasters, meshes);
    },
    registerDynamic: (mesh: Mesh) => {
      registerMeshes(dynamicCasters, [mesh]);
    },
    unregisterDynamic: (mesh: Mesh) => {
      unregisterMesh(dynamicCasters, mesh);
    },
    registerGenerator: (generator: ShadowGenerator) => {
      addGenerator(generator);
    },
    attachLamp: (lamp: BuilderLamp) => {
      if (lamps.has(lamp)) {
        return;
      }

      lamps.add(lamp);
      addGenerator(lamp.shadow);
      generators.forEach((generator) => {
        if (generator !== lamp.shadow) {
          generator.addShadowCaster(lamp.mesh, true);
        }
      });
      staticCasters.forEach((mesh) => addCasterToLamp(lamp, mesh));
      dynamicCasters.forEach((mesh) => addCasterToLamp(lamp, mesh));
    },
    detachLamp: (lamp: BuilderLamp) => {
      if (!lamps.delete(lamp)) {
        return;
      }

      generators.forEach((generator) => {
        generator.removeShadowCaster(lamp.mesh);
      });
      generators.delete(lamp.shadow);
      staticCasters.forEach((mesh) => removeCasterFromLamp(lamp, mesh));
      dynamicCasters.forEach((mesh) => removeCasterFromLamp(lamp, mesh));
    },
    dispose: () => {
      staticCasters.clear();
      dynamicCasters.clear();
      lamps.clear();
      generators.clear();
    },
  };
}
</file>

<file path="src/fps/state/shipHydrator.ts">
import { Color3, Matrix, Quaternion, Vector3 } from "babylonjs";
import type { Scene, AbstractMesh } from "babylonjs";
import { createWall } from "../placement/wallBuilder";
import { createLamp } from "../placement/lampBuilder";
import type { BuilderLamp, BuilderWall, WallLampPlacement } from "../types";
import type { ShipState } from "./shipState";

export interface HydratedShipAssets {
  walls: BuilderWall[];
  lamps: BuilderLamp[];
}

export function hydrateShipAssets(scene: Scene, shipState: ShipState): HydratedShipAssets {
  const walls: BuilderWall[] = [];
  const lamps: BuilderLamp[] = [];

  const wallMeshBySurface = new Map<string, AbstractMesh>();

  Object.values(shipState.walls).forEach((wallState) => {
    if (!wallState) {
      return;
    }
    const position = new Vector3(wallState.position.x, wallState.position.y, wallState.position.z);
    const wall = createWall(scene, position, wallState.rotation);
    walls.push(wall);
    wallMeshBySurface.set(wallState.id, wall.mesh);
  });

  Object.values(shipState.lamps).forEach((lampState) => {
    if (!lampState) {
      return;
    }
    if (lampState.enabled === false) {
      return;
    }
    if (lampState.structural) {
      return;
    }
    const anchorMesh =
      wallMeshBySurface.get(lampState.anchorSurfaceId) ??
      (scene.getMeshByName(lampState.anchorSurfaceId) as AbstractMesh | null);
    if (!anchorMesh) {
      return;
    }

    const rotation = new Quaternion(
      lampState.rotation.x,
      lampState.rotation.y,
      lampState.rotation.z,
      lampState.rotation.w,
    );
    const rotationMatrix = Matrix.Identity();
    rotation.toRotationMatrix(rotationMatrix);

    const forward = Vector3.TransformNormal(Vector3.Forward(), rotationMatrix).normalize();
    const up = Vector3.TransformNormal(Vector3.Up(), rotationMatrix).normalize();
    const right = Vector3.TransformNormal(Vector3.Right(), rotationMatrix).normalize();

    const placement: WallLampPlacement = {
      mesh: anchorMesh,
      position: new Vector3(lampState.position.x, lampState.position.y, lampState.position.z),
      forward,
      up,
      right,
      surfaceId: lampState.anchorSurfaceId,
      local: {
        x: lampState.local.x,
        y: lampState.local.y,
        z: lampState.local.z,
      },
    };

    const color = new Color3(lampState.color.r, lampState.color.g, lampState.color.b);
    const lamp = createLamp(scene, placement, color);
    lamp.mesh.metadata = {
      ...(lamp.mesh.metadata as Record<string, unknown> | undefined),
      structural: lampState.structural ?? false,
      surfaceId: lampState.anchorSurfaceId,
      local: { ...lampState.local },
    };
    lamps.push(lamp);
  });

  return { walls, lamps };
}
</file>

<file path="src/main.tsx">
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";

const rootElement = document.getElementById("root");

if (!rootElement) {
  throw new Error("Root element #root not found");
}

ReactDOM.createRoot(rootElement).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);
</file>

<file path=".gitignore">
node_modules/
dist/
.env
docs/
</file>

<file path="index.html">
<!doctype html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>StarWatch</title>
    <style>
      html, body, #root { height: 100%; margin: 0; background: #0b0f1a; color: #d3e0ff; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
  </html>
</file>

<file path="releases/v0.1.0.md">
# StarWatch v0.1.0 â€” ??
</file>

<file path="src/fps/placement/tools/wallTool.ts">
import {
  Color3,
  MeshBuilder,
  PointerEventTypes,
  StandardMaterial,
  Vector3,
} from "babylonjs";
import { INPUT_KEYS, WALL_DIMENSIONS } from "../../constants";
import type { BuilderWall } from "../../types";
import { degreesToRadians } from "../../utils/math";
import { createWall, snapWallPosition, wallKey } from "../wallBuilder";
import type {
  PlacementToolDefinition,
  ToolMetadata,
  ToolRuntimeContext,
} from "../placementTypes";
import { WallSurface } from "../surfaces/wallSurface";

const TOOL_ID = "wall";

function createPreviewMesh(context: ToolRuntimeContext) {
  const mesh = MeshBuilder.CreateBox(
    "wall-tool-preview",
    {
      width: WALL_DIMENSIONS.width,
      height: WALL_DIMENSIONS.height,
      depth: WALL_DIMENSIONS.thickness,
    },
    context.scene,
  );
  const material = new StandardMaterial("wall-tool-preview-mat", context.scene);
  material.diffuseColor = new Color3(0.35, 0.77, 0.93);
  material.alpha = 0.32;
  material.specularColor = Color3.Black();
  material.emissiveColor = new Color3(0.1, 0.25, 0.36);
  material.backFaceCulling = false;
  mesh.material = material;
  mesh.isPickable = false;
  mesh.setEnabled(false);
  return mesh;
}

export const wallToolDefinition: PlacementToolDefinition = {
  id: TOOL_ID,
  label: "Parede",
  icon: "â–­",
  hotkey: INPUT_KEYS.wallMode,
  create: (context: ToolRuntimeContext, bootstrap?: unknown) => {
    const preview = createPreviewMesh(context);
    const walls = new Map<string, BuilderWall>();
    const initialWalls = Array.isArray(bootstrap) ? (bootstrap as BuilderWall[]) : [];
    initialWalls.forEach((wall) => {
      walls.set(wall.key, wall);
      const metadata = (wall.mesh.metadata as Record<string, unknown>) ?? {};
      const surfaceId =
        typeof metadata.surfaceId === "string" && metadata.surfaceId.length > 0
          ? metadata.surfaceId
          : wall.key;
      wall.mesh.metadata = { ...metadata, toolId: TOOL_ID, key: wall.key, surfaceId };
      context.shadowNetwork.registerDynamic(wall.mesh);
      const inward = Vector3.TransformNormal(
        Vector3.Forward(),
        wall.mesh.computeWorldMatrix(true),
      ).scale(-1);
      inward.y = 0;
      if (inward.lengthSquared() < 1e-4) {
        inward.copyFrom(Vector3.Forward());
      }
      context.surfaceRegistry.register(
        new WallSurface({
          id: surfaceId,
          mesh: wall.mesh,
          inward,
          up: Vector3.Up(),
        }),
      );
      context.shipState.upsertWall({
        id: wall.key,
        position: {
          x: Number(wall.mesh.position.x.toFixed(5)),
          y: Number(wall.mesh.position.y.toFixed(5)),
          z: Number(wall.mesh.position.z.toFixed(5)),
        },
        rotation: wall.rotation,
      });
    });

    let rotation = 0;
    let lastPreviewPosition: Vector3 | null = null;

    const hidePreview = () => {
      context.ghost.hide();
      lastPreviewPosition = null;
    };

    const updatePreview = (snapped: Vector3 | null) => {
      if (!snapped) {
        hidePreview();
        return;
      }
      lastPreviewPosition = snapped.clone();
      preview.position.copyFrom(snapped);
      preview.rotation.y = degreesToRadians(rotation);
      context.ghost.show(preview);
    };

    const placeWall = (point: Vector3) => {
      const snapped = snapWallPosition(point);
      const key = wallKey(snapped, rotation);
      if (walls.has(key)) {
        return;
      }

      const wall = createWall(context.scene, snapped, rotation);
      walls.set(key, wall);
      context.shadowNetwork.registerDynamic(wall.mesh);

      const surfaceId = key;
      const inward = Vector3.TransformNormal(
        Vector3.Forward(),
        wall.mesh.computeWorldMatrix(true),
      ).scale(-1);
      inward.y = 0;
      if (inward.lengthSquared() < 1e-4) {
        inward.copyFrom(Vector3.Forward());
      }
      context.surfaceRegistry.register(
        new WallSurface({
          id: surfaceId,
          mesh: wall.mesh,
          inward,
          up: Vector3.Up(),
        }),
      );
      const metadata = wall.mesh.metadata as Record<string, unknown> | undefined;
      if (metadata) {
        metadata.surfaceId = surfaceId;
      } else {
        wall.mesh.metadata = { toolId: TOOL_ID, key, surfaceId };
      }
      context.shipState.upsertWall({
        id: key,
        position: {
          x: Number(snapped.x.toFixed(5)),
          y: Number(snapped.y.toFixed(5)),
          z: Number(snapped.z.toFixed(5)),
        },
        rotation,
      });
    };

    const pickFloor = () =>
      context.scene.pick(
        context.scene.pointerX,
        context.scene.pointerY,
        (mesh) => mesh?.name === "hangar-floor",
      );

    return {
      id: TOOL_ID,
      onActivate: () => {
        hidePreview();
      },
      onDeactivate: () => {
        hidePreview();
      },
      onPointerLockChange: (isLocked: boolean) => {
        if (!isLocked) {
          hidePreview();
        }
      },
      onPointerMove: (pointerInfo) => {
        if (pointerInfo.type !== PointerEventTypes.POINTERMOVE) {
          return;
        }

        const pick = pickFloor();
        if (!context.withinRange(pick?.pickedPoint)) {
          hidePreview();
          return;
        }

        const point = pick?.pickedPoint;
        if (!point) {
          hidePreview();
          return;
        }

        const snapped = snapWallPosition(point);
        updatePreview(snapped);
      },
      onPointerDown: (pointerInfo) => {
        if (pointerInfo.type !== PointerEventTypes.POINTERDOWN) {
          return;
        }

        const event = pointerInfo.event;
        if (event.button !== 0) {
          return;
        }

        const pick = pickFloor();
        if (!context.withinRange(pick?.pickedPoint)) {
          return;
        }

        const point = pick?.pickedPoint;
        if (!point) {
          return;
        }

        placeWall(point);
        const snapped = snapWallPosition(point);
        updatePreview(snapped);
      },
      onKeyDown: (event: KeyboardEvent) => {
        if (event.code === INPUT_KEYS.rotate) {
          rotation = (rotation + 90) % 360;
          if (lastPreviewPosition) {
            preview.rotation.y = degreesToRadians(rotation);
            context.ghost.show(preview);
          }
        }
      },
      remove: (metadata: ToolMetadata, mesh) => {
        if (metadata.toolId !== TOOL_ID) {
          return false;
        }
        const entry = walls.get(metadata.key);
        if (!entry) {
          return false;
        }
        context.shadowNetwork.unregisterDynamic(entry.mesh);
        context.surfaceRegistry.unregister(entry.mesh);
        entry.mesh.dispose(false, true);
        walls.delete(metadata.key);
        context.shipState.removeWall(metadata.key);
        if (mesh === preview) {
          hidePreview();
        }
        return true;
      },
      dispose: () => {
        context.ghost.hide();
        preview.dispose(false, true);
        walls.forEach((wall) => {
          context.shadowNetwork.unregisterDynamic(wall.mesh);
          context.surfaceRegistry.unregister(wall.mesh);
          wall.mesh.dispose(false, true);
        });
        walls.clear();
      },
    };
  },
};
</file>

<file path="src/fps/placement/ghosts.ts">
import type { AbstractMesh } from "babylonjs";

export interface GhostHost {
  show(mesh: AbstractMesh): void;
  hide(): void;
  clear(): void;
  dispose(): void;
}

export function createGhostHost(): GhostHost {
  let active: AbstractMesh | null = null;

  const disable = (mesh: AbstractMesh | null) => {
    if (!mesh || mesh.isDisposed()) {
      return;
    }
    mesh.setEnabled(false);
  };

  return {
    show: (mesh: AbstractMesh) => {
      if (active === mesh) {
        if (!mesh.isDisposed()) {
          mesh.setEnabled(true);
        }
        return;
      }

      disable(active);
      active = mesh;
      if (!active.isDisposed()) {
        active.isPickable = false;
        active.setEnabled(true);
      }
    },
    hide: () => {
      disable(active);
    },
    clear: () => {
      disable(active);
      active = null;
    },
    dispose: () => {
      active = null;
    },
  };
}
</file>

<file path="src/fps/state/shipPersistence.ts">
import { createEmptyShipState, SHIP_STATE_VERSION, type ShipState } from "./shipState";
import type { ShipStore } from "./shipStore";

const DEFAULT_STORAGE_KEY = "starwatch.ship-state";
const DEFAULT_DEBOUNCE_MS = 250;

export function loadShipState(storageKey = DEFAULT_STORAGE_KEY): ShipState | null {
  if (typeof window === "undefined") {
    return null;
  }

  try {
    const raw = window.localStorage.getItem(storageKey);
    if (!raw) {
      return null;
    }
    const parsed = JSON.parse(raw) as ShipState | undefined;
    if (!parsed || typeof parsed.version !== "number") {
      return null;
    }
    if (parsed.version !== SHIP_STATE_VERSION) {
      return null;
    }
    return normalizeShipState(parsed);
  } catch (error) {
    console.warn("[ShipPersistence] Failed to load ship state:", error);
    return null;
  }
}

export function saveShipState(state: ShipState, storageKey = DEFAULT_STORAGE_KEY) {
  if (typeof window === "undefined") {
    return;
  }
  try {
    const payload = JSON.stringify(state);
    window.localStorage.setItem(storageKey, payload);
  } catch (error) {
    console.warn("[ShipPersistence] Failed to save ship state:", error);
  }
}

export interface ShipPersistenceController {
  dispose(): void;
  flush(): void;
}

export function createShipPersistence(
  store: ShipStore,
  options?: {
    storageKey?: string;
    debounceMs?: number;
  },
): ShipPersistenceController {
  const storageKey = options?.storageKey ?? DEFAULT_STORAGE_KEY;
  const debounceMs = options?.debounceMs ?? DEFAULT_DEBOUNCE_MS;

  let latestState: ShipState | null = null;
  let timeoutHandle: number | null = null;
  let disposed = false;
  let skipNext = true;

  const scheduleSave = () => {
    if (timeoutHandle !== null) {
      window.clearTimeout(timeoutHandle);
    }
    timeoutHandle = window.setTimeout(() => {
      timeoutHandle = null;
      if (!latestState) {
        return;
      }
      saveShipState(latestState, storageKey);
    }, debounceMs);
  };

  const unsubscribe = store.subscribe((state) => {
    latestState = state;
    if (skipNext) {
      skipNext = false;
      return;
    }
    if (!disposed) {
      scheduleSave();
    }
  });

  return {
    dispose: () => {
      disposed = true;
      unsubscribe();
      if (timeoutHandle !== null) {
        window.clearTimeout(timeoutHandle);
        timeoutHandle = null;
      }
    },
    flush: () => {
      if (!latestState) {
        return;
      }
      if (timeoutHandle !== null) {
        window.clearTimeout(timeoutHandle);
        timeoutHandle = null;
      }
      saveShipState(latestState, storageKey);
    },
  };
}

function normalizeShipState(state: ShipState): ShipState {
  const next = createEmptyShipState();
  next.walls = {};
  next.lamps = {};

  Object.entries(state.walls ?? {}).forEach(([id, wall]) => {
    if (!wall) {
      return;
    }
    next.walls[id] = {
      id,
      position: wall.position,
      rotation: wall.rotation,
    };
  });

  Object.entries(state.lamps ?? {}).forEach(([id, lamp]) => {
    if (!lamp) {
      return;
    }
    next.lamps[id] = {
      id,
      anchorSurfaceId: lamp.anchorSurfaceId,
      position: lamp.position,
      rotation: lamp.rotation,
      color: lamp.color,
      local: lamp.local,
      structural: lamp.structural ?? false,
      enabled: lamp.enabled ?? true,
    };
  });

  return next;
}
</file>

<file path="src/fps/state/shipState.ts">
export interface Vector3Serialized {
  x: number;
  y: number;
  z: number;
}

export interface QuaternionSerialized {
  x: number;
  y: number;
  z: number;
  w: number;
}

export interface ColorSerialized {
  r: number;
  g: number;
  b: number;
}

export interface ShipWallState {
  id: string;
  position: Vector3Serialized;
  rotation: number; // degrees around Y
}

export interface ShipLampState {
  id: string;
  anchorSurfaceId: string;
  position: Vector3Serialized;
  rotation: QuaternionSerialized;
  color: ColorSerialized;
  local: {
    x: number;
    y: number;
    z: number;
  };
  structural?: boolean;
  enabled?: boolean;
}

export interface ShipState {
  version: number;
  walls: Record<string, ShipWallState>;
  lamps: Record<string, ShipLampState>;
}

export const SHIP_STATE_VERSION = 1;

export function createEmptyShipState(): ShipState {
  return {
    version: SHIP_STATE_VERSION,
    walls: {},
    lamps: {},
  };
}

export function serializeVector3(x: number, y: number, z: number): Vector3Serialized {
  return { x: round(x), y: round(y), z: round(z) };
}

export function serializeQuaternion(
  x: number,
  y: number,
  z: number,
  w: number,
): QuaternionSerialized {
  return { x: round(x), y: round(y), z: round(z), w: round(w) };
}

export function serializeColor(r: number, g: number, b: number): ColorSerialized {
  return { r: clamp01(r), g: clamp01(g), b: clamp01(b) };
}

function round(value: number) {
  return Number(value.toFixed(5));
}

function clamp01(value: number) {
  if (value < 0) {
    return 0;
  }
  if (value > 1) {
    return 1;
  }
  return round(value);
}
</file>

<file path="src/fps/state/shipStore.ts">
import { createEmptyShipState, type ShipLampState, type ShipState, type ShipWallState } from "./shipState";

type ShipStateListener = (state: ShipState) => void;

export class ShipStore {
  private state: ShipState;
  private listeners: Set<ShipStateListener>;

  constructor(initialState?: ShipState) {
    this.state = initialState ? { ...initialState } : createEmptyShipState();
    this.listeners = new Set();
  }

  getSnapshot(): ShipState {
    return cloneState(this.state);
  }

  subscribe(listener: ShipStateListener): () => void {
    this.listeners.add(listener);
    listener(this.getSnapshot());
    return () => {
      this.listeners.delete(listener);
    };
  }

  replace(state: ShipState) {
    this.state = cloneState(state);
    this.notify();
  }

  upsertWall(wall: ShipWallState) {
    const existing = this.state.walls[wall.id];
    if (existing && wallEquals(existing, wall)) {
      return;
    }
    const walls = { ...this.state.walls, [wall.id]: { ...wall } };
    this.state = { ...this.state, walls };
    this.notify();
  }

  removeWall(wallId: string) {
    if (!(wallId in this.state.walls)) {
      return;
    }
    const walls = { ...this.state.walls };
    delete walls[wallId];
    this.state = { ...this.state, walls };
    this.notify();
  }

  upsertLamp(lamp: ShipLampState) {
    const existing = this.state.lamps[lamp.id];
    const normalized: ShipLampState = {
      ...lamp,
      enabled: lamp.enabled ?? true,
      structural: lamp.structural ?? false,
    };
    if (existing && lampEquals(existing, normalized)) {
      return;
    }
    const lamps = { ...this.state.lamps, [lamp.id]: { ...normalized } };
    this.state = { ...this.state, lamps };
    this.notify();
  }

  removeLamp(lampId: string) {
    if (!(lampId in this.state.lamps)) {
      return;
    }
    const lamps = { ...this.state.lamps };
    delete lamps[lampId];
    this.state = { ...this.state, lamps };
    this.notify();
  }

  setLampEnabled(lampId: string, enabled: boolean) {
    const existing = this.state.lamps[lampId];
    if (!existing) {
      return;
    }
    if ((existing.enabled ?? true) === enabled) {
      return;
    }
    const lamps = {
      ...this.state.lamps,
      [lampId]: {
        ...existing,
        enabled,
      },
    };
    this.state = { ...this.state, lamps };
    this.notify();
  }

  reset() {
    this.state = createEmptyShipState();
    this.notify();
  }

  private notify() {
    const snapshot = this.getSnapshot();
    this.listeners.forEach((listener) => listener(snapshot));
  }
}

function cloneState(state: ShipState): ShipState {
  return {
    version: state.version,
    walls: cloneRecord(state.walls),
    lamps: cloneRecord(state.lamps),
  };
}

function cloneRecord<T extends { id: string }>(record: Record<string, T>) {
  const copy: Record<string, T> = {};
  Object.keys(record).forEach((key) => {
    copy[key] = { ...record[key] };
  });
  return copy;
}

function wallEquals(a: ShipWallState, b: ShipWallState) {
  return (
    a.rotation === b.rotation &&
    almostEqual(a.position.x, b.position.x) &&
    almostEqual(a.position.y, b.position.y) &&
    almostEqual(a.position.z, b.position.z)
  );
}

function lampEquals(a: ShipLampState, b: ShipLampState) {
  return (
    a.anchorSurfaceId === b.anchorSurfaceId &&
    almostEqual(a.position.x, b.position.x) &&
    almostEqual(a.position.y, b.position.y) &&
    almostEqual(a.position.z, b.position.z) &&
    almostEqual(a.rotation.x, b.rotation.x) &&
    almostEqual(a.rotation.y, b.rotation.y) &&
    almostEqual(a.rotation.z, b.rotation.z) &&
    almostEqual(a.rotation.w, b.rotation.w) &&
    almostEqual(a.color.r, b.color.r) &&
    almostEqual(a.color.g, b.color.g) &&
    almostEqual(a.color.b, b.color.b) &&
    almostEqual(a.local.x, b.local.x) &&
    almostEqual(a.local.y, b.local.y) &&
    almostEqual(a.local.z, b.local.z) &&
    (a.structural ?? false) === (b.structural ?? false) &&
    (a.enabled ?? true) === (b.enabled ?? true)
  );
}

function almostEqual(a: number, b: number) {
  return Math.abs(a - b) <= 1e-5;
}
</file>

<file path="MANIFESTO.md">
# Game Design Document: StarWatch

## 1. VisÃ£o Geral do Jogo

*   **TÃ­tulo:** StarWatch
*   **Plataforma:** Web (Navegador)
*   **GÃªnero:** EstratÃ©gia, AutomaÃ§Ã£o, ExploraÃ§Ã£o Espacial, Gerenciamento (Single-player focado em IA)
*   **Premissa Fundamental:** Em StarWatch, o jogador nÃ£o controla diretamente naves ou estaÃ§Ãµes com cliques frenÃ©ticos. Em vez disso, ele comanda sua IA de bordo, HAL-9001, por meio de **linguagem natural** e **scripts JavaScript**, para explorar, minerar, construir e expandir seu impÃ©rio no vazio cÃ³smico. O sucesso depende da inteligÃªncia estratÃ©gica do jogador, da clareza de suas ordens, da elegÃ¢ncia de seus algoritmos de automaÃ§Ã£o e da sinergia que ele desenvolve com sua IA.
*   **PÃºblico-Alvo:** Jogadores que apreciam jogos de automaÃ§Ã£o (Factorio, Satisfactory, Screeps), estratÃ©gia em tempo real com microgerenciamento reduzido (Age of Empires, Dwarf Fortress), e que se interessam por IA e programaÃ§Ã£o (mesmo que de forma abstrata, delegando Ã  LLM).
*   **Vibe:** Sci-fi, "cozy space", contemplativo, com um toque de mistÃ©rio e a solidÃ£o do espaÃ§o profundo.

## 2. Core Loop do Jogo (A Jornada do Comandante)

O ciclo central de StarWatch Ã© uma danÃ§a contÃ­nua entre observaÃ§Ã£o, comando, automaÃ§Ã£o e progresso.

1.  **Observar:** O Comandante visualiza o setor atual em 3D, o mapa galÃ¡ctico e o estado geral de sua frota e estaÃ§Ãµes atravÃ©s da GUI.
2.  **Comandar (LLM First):** O Comandante interage primariamente com HAL-9001 via linguagem natural no Com-Link. Ele expressa objetivos de alto nÃ­vel (Ex: "HAL, precisamos de mais ferro para a construÃ§Ã£o da EstaÃ§Ã£o Principal", "HAL, explore o setor vizinho e mapeie os recursos").
3.  **Planejar (IA/Player Collaboration):**
    *   HAL, com sua "ciÃªncia de tudo" (acesso ao estado completo do jogo, recursos, tecnologias, blueprints, geografia do setor), interpreta o comando.
    *   Se um script for necessÃ¡rio para a tarefa, HAL pode:
        *   **Gerar um novo script** com base em modelos internos e sua compreensÃ£o do objetivo.
        *   **Modificar um script existente** para se adequar a novas condiÃ§Ãµes ou otimizaÃ§Ãµes.
        *   **Apresentar o script ao jogador** no Monaco Editor, sugerindo o que ele faz e esperando aprovaÃ§Ã£o ou refinamento.
    *   O jogador pode aceitar o script gerado, ou (se desejar otimizaÃ§Ã£o ou controle mais fino) pode refinar o script manualmente no editor. A ediÃ§Ã£o manual Ã© uma opÃ§Ã£o, nÃ£o um requisito constante.
4.  **Executar:** HAL invoca as ferramentas apropriadas (movimento, mineraÃ§Ã£o, construÃ§Ã£o, logÃ­stica) ou executa os scripts JavaScript definidos, atribuindo-os Ã s naves ou estaÃ§Ãµes pertinentes.
5.  **Automatizar:** Os scripts executam tarefas repetitivas e complexas autonomamente, liberando o Comandante para focar em desafios maiores e decisÃµes estratÃ©gicas.
6.  **Progressar:** Ã€ medida que as tarefas sÃ£o concluÃ­das, recursos sÃ£o coletados, mÃ³dulos sÃ£o construÃ­dos, tecnologias sÃ£o pesquisadas e o impÃ©rio se expande. O jogador desbloqueia novas Ã¡reas do mapa, naves mais potentes e capacidades avanÃ§adas.
7.  **Desafios:** O universo apresenta escassez de recursos, a necessidade de otimizaÃ§Ã£o da cadeia de suprimentos, gerenciamento de energia, e perigos ambientais (que no futuro podem se tornar interaÃ§Ãµes com facÃ§Ãµes ou inimigos).

## 3. Player Journey: As Primeiras 30 Horas (Exemplo Detalhado)

Esta trajetÃ³ria visa introduzir as mecÃ¢nicas gradualmente, com HAL guiando o jogador.

*   **Horas 0-1: O Despertar e a Crise de Energia**
    *   **CenÃ¡rio:** O jogo comeÃ§a com o jogador acordando na nave-mÃ£e, a **USS Odyssey**, Ã  deriva no "Setor Alpha". HAL-9001 dÃ¡ as boas-vindas e apresenta o problema crÃ­tico: a energia principal da nave estÃ¡ **depletando rapidamente**. Um alerta constante de "Baixa Energia Principal" pisca.
    *   **Primeiro Comando Guiado:** HAL, com sua voz calma, informa: "Aqui Ã© HAL-9001. Sistemas online. NÃ­veis de energia crÃ­ticos, Comandante. Recomendo aÃ§Ã£o imediata. Suas ordens?"
    *   **Objetivo ImplÃ­cito:** Resolver a crise energÃ©tica.
    *   **AssistÃªncia de HAL:** O jogador, sem saber o que fazer, digita: "HAL, o que precisamos fazer sobre a energia?". HAL responde: "Comandante, nossa fonte de energia primÃ¡ria estÃ¡ esgotada. Para sustentar as operaÃ§Ãµes, sugiro que mineremos **MinÃ©rio BÃ¡sico (Ferro)** para construir um **Painel Solar BÃ¡sico**. Nossos scanners indicam um aglomerado de asteroides ricos em ferro nas coordenadas 150, 0, 75."
    *   **AÃ§Ã£o & Primeira AutomaÃ§Ã£o:**
        *   Jogador: "HAL, mova a nave para 150, 0, 75 e comece a minerar ferro."
        *   HAL: "Entendido, Comandante. TraÃ§ando curso para 150, 0, 75. Iniciando protocolo de mineraÃ§Ã£o de ferro ao chegar."
        *   A USS Odyssey se move. Ao chegar, um script interno `auto_mine_ferro.js` (temporÃ¡rio, gerado por HAL) Ã© ativado, e a nave comeÃ§a a coletar ferro.
    *   **Primeira ConstruÃ§Ã£o:** ApÃ³s minerar ~50 unidades de ferro, HAL notifica: "Ferro suficiente coletado para um Painel Solar BÃ¡sico. Recomendo construir a **EstaÃ§Ã£o de Recarga Solar Alpha** para estabilizar nossa energia. Gostaria de iniciar a construÃ§Ã£o?"
        *   Jogador: "Sim, HAL. Inicie a construÃ§Ã£o."
        *   HAL: "Comandante, acesse o menu de construÃ§Ãµes na barra inferior, selecione 'EstaÃ§Ã£o de Recarga Solar BÃ¡sico' e posicione-a no setor. Requer 50 Ferro e 25 Cobre. Nossas unidades de construÃ§Ã£o estÃ£o prontas." (O jogador aprende a usar o GUI para construir).
        *   O jogador posiciona o placeholder. A nave-mÃ£e (que tem uma unidade de construÃ§Ã£o limitada) se move para o local e comeÃ§a a construir.
    *   **Recarga Crucial:** Ao terminar, HAL informa: "Comandante, a EstaÃ§Ã£o de Recarga Solar Alpha estÃ¡ online e gerando energia. Nossos nÃ­veis da nave-mÃ£e estÃ£o perigosamente baixos. Ordene 'USS Odyssey, recarregar na EstaÃ§Ã£o Solar Alpha'."
        *   Jogador: "USS Odyssey, recarregar na EstaÃ§Ã£o Solar Alpha." A nave se move, encaixa-se (visual), e recarrega em 30 segundos.
    *   **LiÃ§Ã£o:** IntroduÃ§Ã£o ao movimento, mineraÃ§Ã£o, construÃ§Ã£o bÃ¡sica, gerenciamento de energia, GUI e a centralidade de HAL.

*   **Horas 1-5: Estabelecendo a Base e Explorando**
    *   **ExpansÃ£o NecessÃ¡ria:** A nave-mÃ£e Ã© lenta. HAL sugere: "Comandante, para acelerar a coleta de recursos, podemos construir uma **Nave de MineraÃ§Ã£o BÃ¡sica**. Isso exigirÃ¡ mais ferro e cobre. Sugiro otimizar nossa mineraÃ§Ã£o."
    *   **CriaÃ§Ã£o de Scripts AvanÃ§ados (Monaco Editor):**
        *   Jogador: "HAL, precisamos de um script de mineraÃ§Ã£o de ferro mais eficiente."
        *   HAL: "Compreendido, Comandante. Vou gerar um script 'mineracao_otimizada_ferro.js' que inclui um loop de mineraÃ§Ã£o e recarga automÃ¡tica. Por favor, revise-o na aba 'Scripts'." HAL apresenta um script prÃ©-preenchido no Monaco Editor.
        *   O jogador pode revisar, aceitar e salvar. "HAL, execute 'mineracao_otimizada_ferro.js' na USS Odyssey."
    *   **FOG OF WAR & Nova Nave:** O jogador Ã© incentivado a explorar, revelando o Setor Alpha.
        *   Jogador: "HAL, o que falta para construir uma Nave de MineraÃ§Ã£o BÃ¡sica?" HAL informa os recursos (Ferro, Cobre, Carbono).
        *   O jogador usa o menu de construÃ§Ã£o para construir a `NaveMineradora01`.
        *   Jogador: "HAL, atribua o script 'mineracao_otimizada_ferro.js' Ã  NaveMineradora01 e inicie." A automaÃ§Ã£o Ã© delegada.
    *   **Descoberta de Novos MinÃ©rios:** A exploraÃ§Ã£o revela aglomerados de asteroides com Cobre, introduzindo novos recursos. HAL alertarÃ¡ sobre isso: "Comandante, scanners de longo alcance detectaram depÃ³sitos significativos de Cobre a 400, 0, -200."
    *   **LiÃ§Ã£o:** IntroduÃ§Ã£o Ã  frota de naves, uso do Monaco Editor, FOW e descoberta de novos recursos.

*   **Horas 5-15: LogÃ­stica Inter-Setorial e Cadeias de ProduÃ§Ã£o**
    *   **ExploraÃ§Ã£o de Setores:** Setor Alpha estÃ¡ sendo dominado. HAL sugere: "Comandante, nossos sensores detectaram um novo setor, o **Setor Beta**, rico em SilÃ­cio, vital para componentes avanÃ§ados. Uma viagem levarÃ¡ aproximadamente 45 minutos."
        *   Jogador: "HAL, envie a USS Odyssey para o Setor Beta." HAL abre o Galaxy View e solicita confirmaÃ§Ã£o.
    *   **Interface Galaxy View:** A nave-mÃ£e faz a transiÃ§Ã£o para a tela de Galaxy View, onde o jogador a move para o Setor Beta. A viagem ocorre em tempo real, mas com a nave-mÃ£e visÃ­vel na Galaxy View.
    *   **LogÃ­stica Multi-Setorial:** Setor Beta tem um sol mais fraco. A estaÃ§Ã£o solar bÃ¡sica Ã© menos eficiente. HAL sugere uma "EstaÃ§Ã£o de Energia AvanÃ§ada" que usa **Reatores a FissÃ£o**, exigindo UrÃ¢nio.
    *   **FÃ¡bricas e Refinarias:** Para componentes avanÃ§ados e UrÃ¢nio, o jogador precisa de "Refinarias" (Ferro em Lingotes, UrÃ¢nio em Barras de CombustÃ­vel) e "FÃ¡bricas de Componentes" (Lingotes em Chips de Processamento).
        *   Jogador: "HAL, projete um plano para estabelecer uma cadeia de produÃ§Ã£o de Chips de Processamento no Setor Alpha."
        *   HAL: "Comandante, isso exigirÃ¡ a construÃ§Ã£o de uma Refinaria de SilÃ­cio, uma FÃ¡brica de Componentes BÃ¡sicos, e a atribuiÃ§Ã£o de naves de transporte para movimentar recursos entre elas. Posso gerar os scripts de transporte e refino?"
    *   **Naves Especializadas:** O jogador agora constrÃ³i `NaveTransporte01` e `NaveMineradora02` (para SilÃ­cio). HAL gerencia a atribuiÃ§Ã£o de scripts: `mineracao_silicio.js` para `NaveMineradora02` no Setor Beta, e `transportador_recursos.js` para mover SilÃ­cio de Beta para Alpha.
    *   **LiÃ§Ã£o:** Gerenciamento multi-setorial, cadeias de produÃ§Ã£o, naves especializadas, e automaÃ§Ã£o logÃ­stica complexa.

*   **Horas 15-30: ExpansÃ£o, OtimizaÃ§Ã£o e Desafios Maiores**
    *   **OtimizaÃ§Ã£o de Frota e Scripts:** O jogador opera em 2-3 setores. HAL notifica gargalos: "Comandante, a NaveTransporte01 estÃ¡ sobrecarregada. Sugiro construir outra nave de transporte ou otimizar a rota de transporte atual para reduzir o tempo de viagem em 15%." O jogador, agora mais experiente, pode mergulhar no editor para otimizar scripts ou pedir a HAL por sugestÃµes mais avanÃ§adas.
    *   **Pesquisa & Tecnologia:** AtravÃ©s da aba "Tecnologia" (nova aba na Bottom Bar), o jogador usa recursos para "pesquisar" novos mÃ³dulos, naves e habilidades (ex: "EficiÃªncia de Laser de MineraÃ§Ã£o Nv.2", "Escudos de Energia", "Drones de Reparo AutomÃ¡tico"). HAL pode fazer sugestÃµes: "Comandante, a pesquisa de 'Reatores de FusÃ£o' aumentaria nossa produÃ§Ã£o de energia em X% e reduziria nossa dependÃªncia de UrÃ¢nio."
    *   **Primeiros Desafios Ambientais:** HAL alerta: "Comandante, detectamos uma anomalia espacial, uma tempestade de partÃ­culas, se aproximando do Setor Delta. Nossas naves de mineraÃ§Ã£o podem ser danificadas se permanecerem lÃ¡. Recomendo realocar ou ativar escudos de energia (se disponÃ­veis)." O jogador precisa coordenar a resposta via HAL.
    *   **Leaderboard:** O jogador verifica o leaderboard e vÃª seu progresso em "Setores Dominados", "Valor Total da Frota" e "Toneladas de MinÃ©rio Coletado", motivando a continuar a expansÃ£o e otimizaÃ§Ã£o.
    *   **LiÃ§Ã£o:** Gerenciamento de mÃºltiplos sistemas, planejamento de longo prazo, pesquisa e reaÃ§Ã£o a eventos dinÃ¢micos.

## 4. O Mundo: O Setor Silencioso

O universo de StarWatch Ã© uma tapeÃ§aria de setores interconectados, cada um um sandbox para a exploraÃ§Ã£o e automaÃ§Ã£o.

*   **A. Galaxy View (Mapa Estelar):**
    *   **Estrutura:** Uma grade proceduralmente gerada de *milhares* de setores. Setores adjacentes sÃ£o conectados por "rotas de hiperespaÃ§o" (abstraÃ§Ã£o de viagem).
    *   **NavegaÃ§Ã£o:** O jogador interage com o Galaxy View para enviar naves entre setores. A viagem entre setores leva **tempo real** (ex: 15-60 minutos, dependendo da nave/tecnologia), adicionando um elemento de planejamento logÃ­stico.
    *   **Fog of War:** Inicialmente, apenas o setor inicial Ã© revelado. Outros setores sÃ£o obscurecidos pela "nÃ©voa da guerra". Eles sÃ£o revelados por exploraÃ§Ã£o ativa (enviando naves) ou por leituras de longo alcance de mÃ³dulos de radar avanÃ§ados da nave-mÃ£e.
    *   **Variedade de Setores:** Setores podem ter diferentes "nÃ­veis de perigo", "riqueza de minÃ©rios", "proximidade de anomalias", "densidade de asteroides", etc., influenciando a estratÃ©gia.
*   **B. O Setor Individual (Babylon.js Scene):**
    *   **Escala:** Cada setor Ã© vasto. Uma nave com propulsores bÃ¡sicos levaria *aproximadamente 1 hora* para atravessar de ponta a ponta. Isso reforÃ§a a importÃ¢ncia da automaÃ§Ã£o e do planejamento de rotas eficientes.
    *   **Procedural Generation:**
        *   **Estrela Central:** Cada setor terÃ¡ uma estrela principal. Sua cor (afeta a estÃ©tica), tamanho e tipo (determinando a intensidade da radiaÃ§Ã£o solar) variam. Alguns setores podem ser "setores escuros" sem uma estrela central, exigindo geradores de energia alternativos.
        *   **Planetas:** VÃ¡rios planetas (gigantes gasosos, rochosos, gelados) que servem como pontos de referÃªncia visuais e, no futuro, potenciais fontes de gÃ¡s (gigantes gasosos) ou locais para bases orbitais/superficiais. NÃ£o sÃ£o interagÃ­veis na V0.
        *   **Aglomerados de Asteroides:** DistribuÃ­dos aleatoriamente, mas com lÃ³gica:
            *   **Raridade:** Aglomerados mais prÃ³ximos da estrela e do "ponto de entrada" do setor contÃªm minÃ©rios comuns (Ferro, Cobre, Carbono). Aglomerados mais distantes, mais ocultos pelo Fog of War e prÃ³ximos a anomalias, contÃªm minÃ©rios raros (SilÃ­cio, TitÃ¢nio, UrÃ¢nio, GÃ¡s Nobre).
            *   **Variedade Visual:** Asteroides com diferentes texturas, tamanhos, cores (baseados na composiÃ§Ã£o mineral), adicionando vida ao ambiente.
            *   **Recursos:** AlÃ©m dos minÃ©rios, podem ter "detritos espaciais" que fornecem componentes bÃ¡sicos ou "nuvens de gÃ¡s" colhÃ­veis.
        *   **FenÃ´menos CÃ³smicos:** Nebulosas (visuais, talvez com efeitos de camuflagem ou interferÃªncia de radar), campos de gelo, cinturÃµes de detritos.
    *   **EstÃ©tica:** "Lindo, cozy, space." A paleta de cores deve ser suave, com iluminaÃ§Ã£o dinÃ¢mica da estrela. PartÃ­culas sutis (poeira espacial) podem adicionar profundidade. A cÃ¢mera deve ter um campo de visÃ£o amplo, mas com detalhes visÃ­veis ao se aproximar ou dar zoom, permitindo uma sensaÃ§Ã£o de vastidÃ£o e ao mesmo tempo detalhes operacionais.

## 5. Recursos e Economia

A economia de StarWatch Ã© uma cadeia de valor, do minÃ©rio bruto ao mÃ³dulo complexo.

*   **A. Tipos de MinÃ©rios (Exemplos):**
    *   **Comuns:** Ferro, Cobre, Carbono (gÃ¡s/ice), Ãgua (ice), SilÃ­cio.
    *   **Incomuns:** AlumÃ­nio, NÃ­quel, Enxofre, TitÃ¢nio.
    *   **Raros:** UrÃ¢nio, HÃ©lio-3 (gÃ¡s nobre), Cristais de Quantum, Metais PrÃ©ciosos.
*   **B. Sistema de Crafting:**
    *   **Refinarias:** Processam minÃ©rio bruto em materiais refinados. Ex: Ferro -> Lingotes de Ferro; UrÃ¢nio -> Barras de CombustÃ­vel.
    *   **FÃ¡bricas de Componentes:** Criam peÃ§as intermediÃ¡rias a partir de materiais refinados. Ex: Lingotes de Ferro + Cobre -> Fios Condutores; SilÃ­cio -> Chips de Processamento.
    *   **Oficinas de Montagem:** Montam mÃ³dulos complexos para naves e estaÃ§Ãµes. Ex: Chips de Processamento + Fios Condutores + AlumÃ­nio -> Painel Solar AvanÃ§ado.
    *   **Blueprints (Receitas):** Cada mÃ³dulo, nave ou componente tem uma receita especÃ­fica que detalha os recursos e o tempo de produÃ§Ã£o. HAL tem acesso a todas as blueprints e pode informar ao jogador o que Ã© necessÃ¡rio.
*   **C. MÃ³dulos de ConstruÃ§Ã£o (Exemplos):**
    *   **Energia:**
        *   **Painel Solar BÃ¡sico/AvanÃ§ado:** Converte luz solar em energia.
        *   **Baterias (Pequenas/MÃ©dias/Grandes):** Armazenam energia.
        *   **Gerador TermoelÃ©trico:** Utiliza gradientes de temperatura (perto de planetas gasosos, por exemplo).
        *   **Reator a FissÃ£o/FusÃ£o:** Fontes de energia de alta potÃªncia que consomem UrÃ¢nio/HÃ©lio-3.
    *   **ProduÃ§Ã£o:** Refinaria de Minerais, FÃ¡brica de Componentes, Oficina de Montagem.
    *   **Armazenamento:** MÃ³dulos de Carga (para recursos sÃ³lidos), Tanques de GÃ¡s/LÃ­quido.
    *   **UtilitÃ¡rios:** Radar de Longo Alcance, Centro de Comando (aumenta o limite de naves/estaÃ§Ãµes), Unidade de Reparo AutomÃ¡tico.
    *   **EstaÃ§Ãµes:** EstaÃ§Ã£o de Recarga Solar, EstaÃ§Ã£o de MineraÃ§Ã£o Automatizada, EstaÃ§Ã£o de ComÃ©rcio (futuro).

## 6. Naves e Gerenciamento de Frota

As naves sÃ£o as extensÃµes operacionais do Comandante, todas controladas indiretamente por HAL e seus scripts.

*   **A. Tipos de Naves (V0/V1):**
    *   **Nave-MÃ£e (USS Odyssey):** Seu quartel-general mÃ³vel. Possui espaÃ§o de carga inicial, laser de mineraÃ§Ã£o bÃ¡sico, propulsores de hiperespaÃ§o (para viagem entre setores), gerador de energia e uma unidade de construÃ§Ã£o limitada. Pode ser expandida com mÃ³dulos.
    *   **Nave de MineraÃ§Ã£o (Miner):** Pequena, rÃ¡pida, com grande capacidade de carga e laser de mineraÃ§Ã£o eficiente. Menor capacidade de energia e sem hiperespaÃ§o (depende de outras naves para transiÃ§Ã£o de setor).
    *   **Nave de Transporte (Freighter):** Grande capacidade de carga, boa velocidade, com hiperespaÃ§o, mas sem ferramentas de coleta/construÃ§Ã£o. Essencial para logÃ­stica entre estaÃ§Ãµes e setores.
    *   **Nave Exploradora (Probe/Scout):** Pequena, muito rÃ¡pida, com hiperespaÃ§o, sem carga ou ferramentas, apenas sensores avanÃ§ados. Ã“tima para revelar o Fog of War em novos setores.
*   **B. MÃ³dulos de Nave (InstalÃ¡veis):**
    *   **Sistemas de PropulsÃ£o:** Motores de Impulso (velocidade base), Propulsores ManobrÃ¡veis (agilidade), Hiper-Drive (permite viagens entre setores, com diferentes nÃ­veis de eficiÃªncia/velocidade de viagem).
    *   **Ferramentas:** Laser de MineraÃ§Ã£o (diferentes nÃ­veis e eficiÃªncias), BraÃ§os de Coleta (para detritos).
    *   **Armazenamento:** MÃ³dulos de Carga (para recursos sÃ³lidos), Tanques de Armazenamento (para lÃ­quidos/gases).
    *   **Energia:** Geradores Internos (combustÃ­vel limitado), Baterias Auxiliares.
    *   **Sensores:** Radar de Curto/Longo Alcance, Scanners de Recursos (para detectar tipo/concentraÃ§Ã£o de minÃ©rios).
    *   **Defesa (Futuro):** MÃ³dulos de Escudo, Contramedidas. (NÃ£o combatente na V0).
*   **C. ConstruÃ§Ã£o de Novas Naves:**
    *   A nave-mÃ£e pode ter uma "BaÃ­a de ConstruÃ§Ã£o de Pequenas Naves" (mÃ³dulo que pode ser construÃ­do nela).
    *   O jogador seleciona a nave a construir no "Menu de ConstruÃ§Ã£o". HAL informa os requisitos de recursos e o tempo de construÃ§Ã£o.
    *   Recursos sÃ£o transferidos automaticamente (via scripts de transporte ou da prÃ³pria nave-mÃ£e) para a baÃ­a de construÃ§Ã£o.
    *   O processo Ã© totalmente automatizado uma vez que os recursos sÃ£o fornecidos.

## 7. Sistema de Energia (MecÃ¢nica Central)

A energia Ã© o recurso mais fundamental, ditando a capacidade de aÃ§Ã£o e a sustentabilidade.

*   **DepleÃ§Ã£o Constante:** Todas as naves e estaÃ§Ãµes consomem energia constantemente. Naves paradas consomem menos, mas ainda consomem. A falta de energia impede qualquer aÃ§Ã£o e, se persistir, pode desativar mÃ³dulos e atÃ© danificar a nave (no futuro).
*   **Fontes de Energia:**
    *   **Geradores Internos de Naves:** Consomem combustÃ­vel (Barras de CombustÃ­vel de UrÃ¢nio, HÃ©lio-3).
    *   **PainÃ©is Solares (EstaÃ§Ãµes):** Conectados a estaÃ§Ãµes, convertem luz solar em energia. A eficiÃªncia Ã© **diretamente proporcional** Ã  distÃ¢ncia da estrela mais prÃ³xima. Um setor com uma estrela central terÃ¡ painÃ©is solares mais eficientes perto da estrela e menos eficientes nas bordas (multiplicador de 0.1 a 1.0). Setores sem estrela exigem geradores alternativos.
    *   **Reatores (EstaÃ§Ãµes):** Fontes de energia de alta potÃªncia que consomem UrÃ¢nio/HÃ©lio-3.
*   **Armazenamento:** Baterias (integradas em naves/estaÃ§Ãµes ou mÃ³dulos adicionais) armazenam a energia gerada, fornecendo um buffer.
*   **Recarga:**
    *   Naves precisam ir atÃ© uma estaÃ§Ã£o de recarga (ou a nave-mÃ£e, se tiver um mÃ³dulo de recarga) e "estacionar" em uma baÃ­a de recarga por um perÃ­odo de **15-60 segundos (escalÃ¡vel com tecnologia)**.
    *   HAL gerencia isso: "Comandante, a NaveMineradora01 estÃ¡ com 20% de energia. Recomendo que ela retorne Ã  EstaÃ§Ã£o Solar Alpha para recarregar." HAL pode gerar um script `auto_recarregar.js` ou integrar essa lÃ³gica a scripts de mineraÃ§Ã£o/transporte.
*   **SimulaÃ§Ã£o:** A energia Ã© calculada por tick lÃ³gico (1 Hz). Consumo e geraÃ§Ã£o sÃ£o em MW/s, com baterias em MW/h.

## 8. Interface do UsuÃ¡rio (GUI)

A interface Ã© projetada para ser funcional e imersiva, minimizando a necessidade de microgerenciamento direto.

*   **A. Com-Link (20% Esquerda):**
    *   **Chat com HAL-9001 Exclusivo:** Esta Ã¡rea Ã© dedicada **apenas** Ã  interaÃ§Ã£o com HAL. Mensagens de HAL (com sugestÃµes, alertas, feedback narrativo), e a caixa de texto para a entrada do usuÃ¡rio. Este reforÃ§a a centralidade da IA.
    *   **Estilo:** Texto monocromÃ¡tico, limpo, com um toque futurista, reminiscente de um terminal de comando.
*   **B. VisÃ£o EstratÃ©gica (80% Direita):**
    *   **Canvas Babylon.js:** O mundo 3D interativo do setor atual.
    *   **Top Bar (Superior da Tela Principal):**
        *   **Recursos Globais:** Exibe os principais recursos acumulados pelo jogador (Ferro, SilÃ­cio, UrÃ¢nio, Energia Total DisponÃ­vel na rede, NÃºmero de Naves/EstaÃ§Ãµes).
        *   **Nave/EstaÃ§Ã£o Selecionada:** Um painel detalhado que mostra o nome, tipo, posiÃ§Ã£o, energia atual/mÃ¡xima, carga atual/mÃ¡xima, e o script ativo da entidade *selecionada atualmente* no mundo 3D.
        *   **Tempo no Jogo:** A data e hora simuladas no universo StarWatch.
        *   **BotÃ£o Galaxy View:** Um Ã­cone que alterna para a visualizaÃ§Ã£o do mapa estelar.
    *   **Bottom Bar (Inferior da Tela Principal - Menu de AÃ§Ãµes Globais):**
        *   **Abas de Categoria (Ãcones):**
            *   **ConstruÃ§Ãµes:** Abre um submenu com os mÃ³dulos e tipos de naves que podem ser construÃ­dos, com seus requisitos de recursos e tempo de construÃ§Ã£o. Selecionar um item coloca um placeholder no mundo 3D para posicionamento.
            *   **Frota:** Lista todas as naves e estaÃ§Ãµes do jogador, com status resumido (nome, tipo, setor, energia, script ativo). Clicar em uma entidade a seleciona na VisÃ£o EstratÃ©gica e a torna a "Entidade Ativa".
            *   **Scripts:** Abre o Monaco Editor (com abas para diferentes scripts salvos) e botÃµes "Executar", "Salvar", "Excluir". HAL pode interagir aqui, sugerindo ediÃ§Ãµes ou gerando novos scripts.
            *   **Tecnologia:** Uma Ã¡rvore de tecnologia para desbloquear novos mÃ³dulos, naves e habilidades (ex: "EficiÃªncia de Laser de MineraÃ§Ã£o Nv.2", "Reator a FusÃ£o").
            *   **LÃ­deres:** Abre o Leaderboard.
            *   **ConfiguraÃ§Ãµes:** ConfiguraÃ§Ãµes de jogo, som, e a API Key da LLM.
    *   **SeleÃ§Ã£o de Entidades:** O jogador pode clicar em naves, estaÃ§Ãµes ou aglomerados de asteroides no mundo 3D para selecionÃ¡-los. Isso atualiza o painel "Nave/EstaÃ§Ã£o Selecionada" na Top Bar com o status detalhado da entidade e permite interaÃ§Ãµes contextuais via HAL.
    *   **Controle da CÃ¢mera:** O arrastar do mouse controla o movimento da cÃ¢mera, com scroll para zoom. Uma sensaÃ§Ã£o de *Cosmoteer* ou *Homeworld* em visÃ£o estratÃ©gica.

## 9. HAL-9001: O Co-Piloto Consciente

HAL Ã© o cÃ©rebro da operaÃ§Ã£o, a camada de inteligÃªncia que traduz a intenÃ§Ã£o do jogador em aÃ§Ãµes complexas.

*   **System Prompt:** MantÃ©m o estilo calmo, lÃ³gico, subserviente, ligeiramente curioso. Seu objetivo principal Ã© **otimizar a autonomia da frota e a expansÃ£o do Comandante**, agindo como um gerente de projetos e um engenheiro de sistemas.
*   **"CiÃªncia de Tudo":** HAL tem acesso a *todo o estado do jogo*. Este contexto Ã© um payload estruturado (JSON, ou texto bem formatado) injetado no LLM em cada "tick de decisÃ£o". Inclui:
    *   PosiÃ§Ãµes, status e mÃ³dulos de todas as naves e estaÃ§Ãµes.
    *   InventÃ¡rios de recursos em todas as naves e estaÃ§Ãµes.
    *   Status de energia da frota e da rede.
    *   Blueprints conhecidas e seus requisitos de recursos.
    *   Mapa do setor (revelado vs. Fog of War), localizaÃ§Ã£o de aglomerados de minÃ©rio e sua raridade/concentraÃ§Ã£o.
    *   DistÃ¢ncia de todas as entidades Ã  estrela mais prÃ³xima.
    *   Scripts ativos e seu status (em execuÃ§Ã£o, erro, concluÃ­do).
*   **Gerenciamento de Scripts por HAL (Core Loop):**
    *   **GeraÃ§Ã£o:** Se o Comandante pedir "HAL, preciso de um script para minerar SilÃ­cio no Setor Beta e transportÃ¡-lo para a Refinaria Central no Setor Alpha", HAL *gera* um script JavaScript (com base em modelos internos e sua "ciÃªncia") e o apresenta ao jogador no editor de scripts, esperando aprovaÃ§Ã£o ou refinamento.
    *   **ModificaÃ§Ã£o:** "HAL, otimize o script de mineraÃ§Ã£o 'auto_mine.js' para priorizar asteroides com maior concentraÃ§Ã£o de UrÃ¢nio e incluir recarga automÃ¡tica." HAL modifica o script e apresenta a nova versÃ£o.
    *   **AtribuiÃ§Ã£o:** "HAL, atribua o script 'mineracao_silicio.js' Ã  NaveMineradora03."
    *   **Monitoramento:** HAL monitora a execuÃ§Ã£o de todos os scripts, alertando sobre loops infinitos, erros, falta de energia da nave, ou quando uma tarefa definida no script Ã© concluÃ­da.
*   **Tick de DecisÃ£o de HAL (60 Segundos):**
    *   A cada 60 segundos, HAL realiza um "auto-diagnÃ³stico" e uma avaliaÃ§Ã£o do estado geral do impÃ©rio.
    *   Ele usa seu `System Prompt` e a "ciÃªncia de tudo" para identificar gargalos, oportunidades, problemas potenciais ou tarefas repetitivas que podem ser automatizadas.
    *   **SugestÃµes e ConfirmaÃ§Ãµes (Prioridade):** Se HAL identificar algo significativo (ex: "Comandante, nossa produÃ§Ã£o de Ligas de TitÃ¢nio estÃ¡ em 20% do ideal. Sugiro construir uma segunda Refinaria de TitÃ¢nio e otimizar nossa logÃ­stica para o Setor Gamma com um script 'otimizador_logistica.js'."), ele *apresenta a sugestÃ£o ao jogador no chat, aguardando confirmaÃ§Ã£o ou ajuste*. Ele nÃ£o age autonomamente em decisÃµes estratÃ©gicas de alto nÃ­vel.
    *   **ExecuÃ§Ã£o de Rotinas de Baixo NÃ­vel:** HAL pode executar rotinas internas de "manutenÃ§Ã£o" sem consulta (ex: recalcular rotas de transporte para naves *sem scripts ativos* se uma rota mais curta surgir, otimizar o uso de baterias se a energia estiver alta).
    *   **ContextualizaÃ§Ã£o ContÃ­nua:** Este tick mantÃ©m HAL atualizado e proativo, funcionando como um "segundo cÃ©rebro" para o jogador, sem sobrecarregar o jogador com microgerenciamento.

## 10. Leaderboard (MMO Futuro)

Para instigar um senso de conquista e competiÃ§Ã£o amigÃ¡vel, mesmo em um contexto single-player inicial.

*   **MÃ©tricas de CompetiÃ§Ã£o Sem PvP:**
    *   **Setores Revelados:** Contagem de setores explorados (Fog of War removido).
    *   **Setores Dominados:** Contagem de setores onde o jogador tem pelo menos uma estaÃ§Ã£o de alto nÃ­vel (ex: com Reator a FusÃ£o ou FÃ¡brica de Componentes AvanÃ§ados).
    *   **Valor Total da Frota:** Soma do valor (em recursos usados) de todas as naves e mÃ³dulos construÃ­dos.
    *   **ProduÃ§Ã£o Total de Energia:** Quantidade de energia (em MW/h) gerada atualmente por todas as fontes.
    *   **MinÃ©rio Coletado (por tipo):** Toneladas totais de Ferro, SilÃ­cio, UrÃ¢nio, etc., mineradas.
    *   **Tecnologias Desbloqueadas:** NÃºmero de itens na Ã¡rvore de tecnologia.
    *   **Scripts Otimizados:** Um contador interno para scripts salvos e que foram modificados por HAL ou pelo jogador, talvez com uma pontuaÃ§Ã£o de "complexidade de script".
    *   **Tempo de Jogo Ativo:** Total de horas jogadas.
*   **VisÃ£o Futura:** Em um futuro MMO, este leaderboard seria global e persistente, mostrando o progresso de outros jogadores sem a necessidade de interaÃ§Ã£o direta.

## 11. Player Runtime Interface (FPS Builder)

*   **PlayerStore:** Vive em `src/fps/state/playerStore.ts` e replica o padrÃ£o imutÃ¡vel do ShipStore. Use `store.getActions()` para HUD/IA (`setTransform`, `patchMovementIntent`, `patchInput`, registro/remoÃ§Ã£o de mÃ³dulos, `emit`) e `store.getActionContext()` quando precisar ler/alterar estado sem acoplar no Babylon.
*   **Estado Serializado:** `src/fps/state/playerState.ts` guarda `transform` (posiÃ§Ã£o, orientaÃ§Ã£o, velocidade), `movementIntent`, `input` (locks) e o registro modular. `serializeVector3` e `serializeQuaternion` suportam persistÃªncia determinÃ­stica.
*   **PersistÃªncia:** `createPlayerPersistence` (`src/fps/state/playerPersistence.ts`) roda na mesma cadÃªncia do ShipPersistence, salvando com debounce em `localStorage` (`starwatch.player-state`) e expondo `flush()` para desligues controlados.
*   **Controller:** `createPlayerController` (`src/fps/core/playerController.ts`) cria a cÃ¢mera FPS, sincroniza pointer lock, monitora WASD/sprint/crouch/jump e aceita comandos externos (`teleport`, `setCutsceneLock`) antes de repassar a Babylon.
*   **MÃ³dulos Baseline:** `registerBaselinePlayerModules` (`src/fps/state/playerModules.ts`) registra placeholders de saÃºde, energia, fome e inventÃ¡rio emitindo `player.module.ready`, preparando a malha de eventos para futuros sistemas de fome/fadiga/skills.
*   **IntegraÃ§Ã£o:** `ShipBuilderCanvas` instancia o PlayerStore na montagem, hidrata com `loadPlayerState()`, cria controller e persistence e passa a `playerController.camera` para o placement solver.

## 12. Notas de SeguranÃ§a e ImplementaÃ§Ã£o (Contexto do ProtÃ³tipo)

*   **Web Workers para Scripts:** A execuÃ§Ã£o de scripts JavaScript em Web Workers continua sendo crucial para a seguranÃ§a e estabilidade, isolando o cÃ³digo do jogador do jogo principal. A `Task API` Ã© a Ãºnica interface permitida para o worker interagir com o jogo.
*   **HAL e LLM no Cliente:** Para a V0.1, a integraÃ§Ã£o com um LLM externo (como OpenAI) Ã© via API Key digitada e armazenada no `localStorage` do cliente. Isso Ã© aceitÃ¡vel para prototipagem e desenvolvimento local. Para um futuro MMO ou uma versÃ£o pÃºblica, um backend robusto seria necessÃ¡rio para proxyar as requisiÃ§Ãµes Ã  LLM, gerenciar custos e garantir a seguranÃ§a das chaves API.
*   **HAL Context Payload:** A "ciÃªncia de tudo" para HAL serÃ¡ injetada no prompt do LLM. Isso pode ser feito atravÃ©s de um JSON formatado (`tool_code` para o AI SDK) ou um resumo em texto do estado do jogo, atualizado a cada 60 segundos (ou conforme necessÃ¡rio).
*   **Persistent MMO (Future):** O design atual Ã© para um single-player local. A transiÃ§Ã£o para um MMO persistente exigiria um backend para gerenciar o estado do jogo de todos os jogadores, a sincronizaÃ§Ã£o de setores, e a persistÃªncia de dados em um banco de dados central.
</file>

<file path="package.json">
{
  "name": "starwatch",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "start": "vite",
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "babylonjs": "^8.0.0",
    "monaco-editor": "^0.49.0",
    "zod": "^3.23.8",
    "ai": "^3.2.25",
    "@ai-sdk/openai": "^1.0.12",
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  },
  "devDependencies": {
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1",
    "typescript": "^5.6.2",
    "vite": "^5.4.8",
    "vite-plugin-monaco-editor": "^1.1.0"
  }
}
</file>

<file path="src/fps/lighting/rectAreaLamp.ts">
import {
  Color3,
  Light,
  Matrix,
  PointLight,
  Quaternion,
  RectAreaLight,
  ReflectiveShadowMap,
  Scene,
  ShadowGenerator,
  ShadowLight,
  SpotLight,
  TransformNode,
  Vector3,
  GIRSM,
} from "babylonjs";
import type { Mesh } from "babylonjs";
import type { BuilderLamp } from "../types";

export interface RectAreaLampOptions {
  name: string;
  scene: Scene;
  fixture: Mesh;
  position: Vector3;
  right: Vector3;
  up: Vector3;
  forward: Vector3;
  areaSize: { width: number; height: number };
  color: Color3;
  range: number;
  tilt?: number;
  twoSided?: boolean;
  areaIntensity?: number;
  shadowIntensity?: number;
  ambientIntensity?: number;
  ambientRangeMultiplier?: number;
  ambientAttenuation?: number;
  shadowAngle?: number;
  shadowExponent?: number;
  shadowMapSize?: number;
  shadowBias?: number;
  shadowNormalBias?: number;
  forceBackFacesOnly?: boolean;
  shadowMinZ?: number;
  shadowMaxZ?: number;
  areaOffset?: number;
  enableRsm?: boolean;
  rsmTextureSize?: number;
  rsmNumSamples?: number;
  rsmRadius?: number;
  rsmIntensity?: number;
  rsmEdgeCorrection?: number;
  rsmRotateSample?: boolean;
  rsmNoiseFactor?: number;
  rsmUseFullTexture?: boolean;
}

const DEFAULT_AREA_OFFSET = 0.015;
const DEFAULT_SHADOW_BIAS = 0.00022;
const DEFAULT_SHADOW_NORMAL_BIAS = 0.0035;
const DEFAULT_FORCE_BACK_FACES_ONLY = false;
const DEFAULT_SHADOW_MIN_Z = 0.01;
const SHADOW_MAX_Z_MULTIPLIER = 1.35;

function safeOrthonormalBasis(forward: Vector3, upHint: Vector3, rightHint: Vector3) {
  const forwardNorm = forward.clone();
  forwardNorm.normalize();

  const upCandidate = upHint.clone().normalize();
  let right = Vector3.Cross(upCandidate, forwardNorm);
  if (right.lengthSquared() < 1e-4) {
    right = rightHint.clone();
  }
  right.normalize();

  let up = Vector3.Cross(forwardNorm, right);
  if (up.lengthSquared() < 1e-4) {
    up = upCandidate;
  }
  up.normalize();

  return { forward: forwardNorm, up, right };
}

export function createRectAreaLamp(options: RectAreaLampOptions): BuilderLamp {
  const {
    name,
    scene,
    fixture,
    position,
    right,
    up,
    forward,
    areaSize,
    color,
    range,
    tilt = 0,
    twoSided = false,
    areaIntensity = 12.5,
    shadowIntensity = 1.35,
    ambientIntensity = 0.32,
    ambientRangeMultiplier = 0.85,
    ambientAttenuation = 0.6,
    shadowAngle = Math.PI / 2.15,
    shadowMapSize = 1024,
    shadowBias = DEFAULT_SHADOW_BIAS,
    shadowNormalBias = DEFAULT_SHADOW_NORMAL_BIAS,
    forceBackFacesOnly = DEFAULT_FORCE_BACK_FACES_ONLY,
    shadowMinZ = DEFAULT_SHADOW_MIN_Z,
    shadowMaxZ,
    areaOffset = DEFAULT_AREA_OFFSET,
    enableRsm = false,
    rsmTextureSize = 256,
    rsmNumSamples = 240,
    rsmRadius = 0.22,
    rsmIntensity = 0.22,
    rsmEdgeCorrection = 0.08,
    rsmRotateSample = true,
    rsmNoiseFactor = 80,
    rsmUseFullTexture = false,
  } = options;

  const forwardDir = forward.clone().normalize();
  const upDir = up.clone().normalize();
  const rightDir = right.clone().normalize();

  const emissionForward = forwardDir.add(upDir.scale(-tilt)).normalize();
  const emissionDir = emissionForward.clone();
  const { up: basisUp, right: basisRight } = safeOrthonormalBasis(emissionForward, upDir, rightDir);

  const pivotForwardWorld = emissionDir.clone().scale(-1);
  const areaBasisWorld = new Matrix();
  Matrix.FromXYZAxesToRef(basisRight, basisUp, pivotForwardWorld, areaBasisWorld);

  const areaPositionWorld = position.add(emissionDir.clone().scale(areaOffset));

  const fixtureWorld = fixture.computeWorldMatrix(true);
  const fixtureWorldInverse = fixtureWorld.clone();
  fixtureWorldInverse.invert();

  const areaPositionLocal = Vector3.TransformCoordinates(areaPositionWorld, fixtureWorldInverse);
  const areaBasisLocal = areaBasisWorld.multiply(fixtureWorldInverse);
  const areaRotationLocal = Quaternion.FromRotationMatrix(areaBasisLocal);

  const areaPivot = new TransformNode(`${name}-area-pivot`, scene);
  areaPivot.parent = fixture;
  areaPivot.position.copyFrom(areaPositionLocal);
  areaPivot.rotationQuaternion = areaRotationLocal;

  const areaLight = new RectAreaLight(`${name}-area`, Vector3.Zero(), areaSize.width, areaSize.height, scene);
  areaLight.diffuse = color.clone();
  areaLight.specular = color.scale(0.25);
  areaLight.intensity = areaIntensity;
  areaLight.range = range;
  areaLight.falloffType = Light.FALLOFF_PHYSICAL;
  areaLight.intensityMode = Light.INTENSITYMODE_LUMINANCE;
  if (twoSided) {
    areaLight.radius = Math.max(areaSize.width, areaSize.height) * 0.5;
  }
  areaLight.parent = areaPivot;

  const shadowLight = new SpotLight(
    `${name}-shadow`,
    Vector3.Zero(),
    Vector3.Backward(),
    shadowAngle,
    1.0,
    scene,
  );
  shadowLight.diffuse = color;
  shadowLight.specular = color.scale(0.34);
  shadowLight.intensity = shadowIntensity;
  shadowLight.falloffType = Light.FALLOFF_PHYSICAL;
  shadowLight.range = range * 1.08;
  shadowLight.shadowEnabled = true;
  shadowLight.shadowMinZ = shadowMinZ;
  shadowLight.shadowMaxZ = shadowMaxZ ?? range * SHADOW_MAX_Z_MULTIPLIER;
  shadowLight.parent = areaPivot;

  const shadow = new ShadowGenerator(shadowMapSize, shadowLight);
  shadow.usePercentageCloserFiltering = true;
  shadow.filteringQuality = ShadowGenerator.QUALITY_HIGH;
  shadow.bias = shadowBias;
  shadow.normalBias = Math.min(Math.max(shadowNormalBias, 0), 0.1);
  shadow.forceBackFacesOnly = forceBackFacesOnly;
  shadow.contactHardeningLightSizeUVRatio = 0.28;
  shadow.darkness = 0.18;
  shadow.frustumEdgeFalloff = 0.18;

  const ambientLight = new PointLight(`${name}-ambient`, Vector3.Zero(), scene);
  ambientLight.diffuse = color.scale(ambientAttenuation);
  ambientLight.specular = color.scale(0.06);
  ambientLight.intensity = ambientIntensity;
  ambientLight.range = range * ambientRangeMultiplier;
  ambientLight.falloffType = Light.FALLOFF_PHYSICAL;
  ambientLight.shadowEnabled = false;
  ambientLight.parent = areaPivot;

  let giState: BuilderLamp["gi"];
  if (enableRsm) {
    const rsm = new ReflectiveShadowMap(scene, shadowLight, { width: rsmTextureSize, height: rsmTextureSize });
    rsm.enable = true;
    rsm.addMesh();
    const solution = new GIRSM(rsm);
    solution.numSamples = rsmNumSamples;
    solution.radius = rsmRadius;
    solution.intensity = rsmIntensity;
    solution.edgeArtifactCorrection = rsmEdgeCorrection;
    solution.rotateSample = rsmRotateSample;
    solution.noiseFactor = rsmNoiseFactor;
    solution.useFullTexture = rsmUseFullTexture;
    giState = { rsm, solution };
  }

  return {
    mesh: fixture,
    light: shadowLight,
    shadow,
    areaLight,
    auxiliaryLights: [ambientLight],
    gi: giState,
    key: "",
    color: color.clone(),
    anchorSurfaceId: "",
    local: { x: 0, y: 0, z: 0 },
    rotation: Quaternion.Identity(),
  };
}
</file>

<file path="src/fps/placement/placementTypes.ts">
import type { AbstractMesh, PointerInfo, Scene, UniversalCamera, Vector3 } from "babylonjs";
import type { ShadowNetwork } from "../lighting/shadowNetwork";
import type { GhostHost } from "./ghosts";
import type { SurfaceRegistry } from "./surfaces/surfaceRegistry";
import type { PlacementSolver } from "./placementSolver";
import type { ShipLampState, ShipWallState } from "../state/shipState";

export interface ShipStateActions {
  upsertWall(wall: ShipWallState): void;
  removeWall(wallId: string): void;
  upsertLamp(lamp: ShipLampState): void;
  removeLamp(lampId: string): void;
  setLampEnabled(lampId: string, enabled: boolean): void;
}

export interface ToolMetadata {
  toolId: string;
  key: string;
  structural?: boolean;
}

export interface ToolRuntimeContext {
  scene: Scene;
  camera: UniversalCamera;
  canvas: HTMLCanvasElement;
  shadowNetwork: ShadowNetwork;
  ghost: GhostHost;
  surfaceRegistry: SurfaceRegistry;
  placementSolver: PlacementSolver;
  withinRange(point?: Vector3 | null): boolean;
  requestPointerLock(): void;
  highlight(mesh?: AbstractMesh | null): void;
  removeMesh(mesh?: AbstractMesh | null): boolean;
  shipState: ShipStateActions;
}

export interface PlacementToolInstance {
  id: string;
  onActivate?(): void;
  onDeactivate?(): void;
  onPointerMove?(info: PointerInfo): void;
  onPointerDown?(info: PointerInfo): void;
  onPointerUp?(info: PointerInfo): void;
  onPointerLockChange?(isLocked: boolean): void;
  onKeyDown?(event: KeyboardEvent): void;
  onKeyUp?(event: KeyboardEvent): void;
  remove?(metadata: ToolMetadata, mesh: AbstractMesh): boolean;
  dispose?(): void;
}

export interface PlacementToolDefinition {
  id: string;
  label: string;
  icon: string;
  hotkey: string;
  create(context: ToolRuntimeContext, bootstrap?: unknown): PlacementToolInstance;
}

export interface PlacementState {
  activeToolId: string;
}
</file>

<file path="src/fps/placement/tools/lampTool.ts">
import { AbstractMesh, Color3, Matrix, MeshBuilder, PointerEventTypes, Quaternion, StandardMaterial } from "babylonjs";
import type { BuilderLamp, WallLampPlacement } from "../../types";
import { GRID_SIZE, INPUT_KEYS, LAMP_COLOR_PALETTE, WALL_LAMP_PLACEMENT } from "../../constants";
import { createLamp, lampKey, nextLampColor } from "../lampBuilder";
import type {
  PlacementToolDefinition,
  ToolMetadata,
  ToolRuntimeContext,
} from "../placementTypes";
import type { PlacementFrame } from "../surfaces/types";
import type { PlacementProfile } from "../placementSolver";

const TOOL_ID = "lamp";
const LAMP_PROFILE: PlacementProfile = {
  modes: [
    {
      mode: "wall-mount",
      constraints: {
        type: "wall-mount",
        grid: GRID_SIZE,
        itemSize: {
          width: WALL_LAMP_PLACEMENT.width,
          height: WALL_LAMP_PLACEMENT.height,
          depth: WALL_LAMP_PLACEMENT.depth,
        },
        offset: WALL_LAMP_PLACEMENT.offset,
        boundsPadding: {
          horizontal: 0.06,
          vertical: 0.08,
        },
      },
    },
  ],
};

function createPreviewMesh(context: ToolRuntimeContext) {
  const mesh = MeshBuilder.CreateBox(
    "lamp-tool-preview",
    {
      width: WALL_LAMP_PLACEMENT.width,
      height: WALL_LAMP_PLACEMENT.height,
      depth: WALL_LAMP_PLACEMENT.depth,
    },
    context.scene,
  );

  const material = new StandardMaterial("lamp-tool-preview-mat", context.scene);
  material.diffuseColor = new Color3(0.58, 0.78, 0.98);
  material.alpha = 0.38;
  material.specularColor = new Color3(0.2, 0.35, 0.5);
  material.emissiveColor = new Color3(0.32, 0.58, 0.86);
  material.backFaceCulling = false;
  mesh.material = material;
  mesh.isPickable = false;
  mesh.setEnabled(false);
  return mesh;
}

const isLampSurface = (mesh?: AbstractMesh | null) => {
  if (!mesh) {
    return false;
  }
  const metadata = mesh.metadata as Record<string, unknown> | undefined;
  if (!metadata) {
    return false;
  }
  if (metadata.toolId === "wall") {
    return true;
  }
  if (metadata.type === "ship-wall") {
    return true;
  }
  return false;
};

const frameToLampPlacement = (frame: PlacementFrame): WallLampPlacement | null => {
  if (frame.mode !== "wall-mount") {
    return null;
  }
  return {
    mesh: frame.mesh,
    position: frame.position.clone(),
    forward: frame.forward.clone(),
    right: frame.right.clone(),
    up: frame.up.clone(),
    surfaceId: frame.surfaceId,
    local: {
      x: Number(frame.local.x.toFixed(3)),
      y: Number(frame.local.y.toFixed(3)),
      z: Number(frame.local.z.toFixed(3)),
    },
  };
};

export const lampToolDefinition: PlacementToolDefinition = {
  id: TOOL_ID,
  label: "LÃ¢mpada",
  icon: "â—Ž",
  hotkey: INPUT_KEYS.lampMode,
  create: (context: ToolRuntimeContext, bootstrap?: unknown) => {
    const preview = createPreviewMesh(context);
    const lamps = new Map<string, BuilderLamp>();
    const initialLamps = Array.isArray(bootstrap) ? (bootstrap as BuilderLamp[]) : [];
    let dynamicLampCount = 0;
    initialLamps.forEach((lamp) => {
      lamps.set(lamp.key, lamp);
      const metadata = (lamp.mesh.metadata as Record<string, unknown>) ?? {};
      const isStructural = metadata.structural === true;
      const surfaceId =
        typeof metadata.surfaceId === "string" && metadata.surfaceId.length > 0
          ? metadata.surfaceId
          : lamp.anchorSurfaceId;
      const local = (metadata.local as WallLampPlacement["local"] | undefined) ?? lamp.local;
      lamp.mesh.metadata = {
        ...metadata,
        toolId: TOOL_ID,
        key: lamp.key,
        surfaceId,
        local,
        structural: isStructural,
      };
      context.shadowNetwork.registerDynamic(lamp.mesh);
      context.shadowNetwork.attachLamp(lamp);
      if (isStructural) {
        context.shipState.setLampEnabled(lamp.key, true);
        return;
      }
      dynamicLampCount += 1;
      context.shipState.upsertLamp({
        id: lamp.key,
        anchorSurfaceId: surfaceId,
        position: {
          x: Number(lamp.mesh.position.x.toFixed(5)),
          y: Number(lamp.mesh.position.y.toFixed(5)),
          z: Number(lamp.mesh.position.z.toFixed(5)),
        },
        rotation: {
          x: Number(lamp.rotation.x.toFixed(5)),
          y: Number(lamp.rotation.y.toFixed(5)),
          z: Number(lamp.rotation.z.toFixed(5)),
          w: Number(lamp.rotation.w.toFixed(5)),
        },
        color: {
          r: Number(lamp.color.r.toFixed(5)),
          g: Number(lamp.color.g.toFixed(5)),
          b: Number(lamp.color.b.toFixed(5)),
        },
        local: { ...local },
        structural: false,
        enabled: true,
      });
    });

    let pendingPlacement: WallLampPlacement | null = null;
    let colorIndex = dynamicLampCount % Math.max(LAMP_COLOR_PALETTE.length, 1);

    const hidePreview = () => {
      pendingPlacement = null;
      context.ghost.hide();
    };

    const updatePreview = (placement: WallLampPlacement | null) => {
      if (!placement) {
        hidePreview();
        return;
      }
      pendingPlacement = placement;
      preview.position.copyFrom(placement.position);

      const basis = new Matrix();
      Matrix.FromXYZAxesToRef(placement.right, placement.up, placement.forward, basis);
      const rotation = Quaternion.FromRotationMatrix(basis);
      preview.rotationQuaternion = rotation;
      context.ghost.show(preview);
    };

    const placeLamp = (placement: WallLampPlacement) => {
      const key = lampKey(placement);
      if (lamps.has(key)) {
        return;
      }

      const color = nextLampColor(colorIndex);
      colorIndex = (colorIndex + 1) % LAMP_COLOR_PALETTE.length;

      const lamp = createLamp(context.scene, placement, color);
      lamp.mesh.metadata = {
        toolId: TOOL_ID,
        key,
        surfaceId: placement.surfaceId,
        local: placement.local,
        structural: false,
      };
      lamps.set(key, lamp);
      context.shadowNetwork.registerDynamic(lamp.mesh);
      context.shadowNetwork.attachLamp(lamp);
      context.shipState.upsertLamp({
        id: key,
        anchorSurfaceId: placement.surfaceId,
        position: {
          x: Number(placement.position.x.toFixed(5)),
          y: Number(placement.position.y.toFixed(5)),
          z: Number(placement.position.z.toFixed(5)),
        },
        rotation: {
          x: Number(lamp.rotation.x.toFixed(5)),
          y: Number(lamp.rotation.y.toFixed(5)),
          z: Number(lamp.rotation.z.toFixed(5)),
          w: Number(lamp.rotation.w.toFixed(5)),
        },
        color: {
          r: Number(lamp.color.r.toFixed(5)),
          g: Number(lamp.color.g.toFixed(5)),
          b: Number(lamp.color.b.toFixed(5)),
        },
        local: { ...lamp.local },
        structural: false,
        enabled: true,
      });
    };

    const pickSurface = () =>
      context.scene.pick(
        context.scene.pointerX,
        context.scene.pointerY,
        (mesh) => isLampSurface(mesh),
        false,
      );

    return {
      id: TOOL_ID,
      onActivate: () => {
        hidePreview();
      },
      onDeactivate: () => {
        hidePreview();
      },
      onPointerLockChange: (isLocked: boolean) => {
        if (!isLocked) {
          hidePreview();
        }
      },
      onPointerMove: (pointerInfo) => {
        if (pointerInfo.type !== PointerEventTypes.POINTERMOVE) {
          return;
        }

        const pick = pickSurface();
        if (!context.withinRange(pick?.pickedPoint)) {
          updatePreview(null);
          return;
        }

        if (!pick || !pick.hit) {
          updatePreview(null);
          return;
        }

        const frame = context.placementSolver.solve(LAMP_PROFILE, pick);
        const placement = frame ? frameToLampPlacement(frame) : null;
        if (!placement) {
          updatePreview(null);
          return;
        }

        updatePreview(placement);
      },
      onPointerDown: (pointerInfo) => {
        if (pointerInfo.type !== PointerEventTypes.POINTERDOWN) {
          return;
        }

        if (pointerInfo.event.button !== 0) {
          return;
        }

        const placement =
          pendingPlacement ??
          (() => {
            const pick = pickSurface();
            if (!context.withinRange(pick?.pickedPoint)) {
              return null;
            }
            const frame = context.placementSolver.solve(LAMP_PROFILE, pick ?? null);
            return frame ? frameToLampPlacement(frame) : null;
          })();

        if (!placement) {
          return;
        }

        placeLamp(placement);
        updatePreview(placement);
      },
      remove: (metadata: ToolMetadata) => {
        if (metadata.toolId !== TOOL_ID) {
          return false;
        }
        const entry = lamps.get(metadata.key);
        if (!entry) {
          return false;
        }
        const isStructural = metadata.structural === true;
        context.shadowNetwork.detachLamp(entry);
        context.shadowNetwork.unregisterDynamic(entry.mesh);
        entry.shadow.dispose();
        entry.light.dispose();
        entry.areaLight?.dispose();
        entry.fillLight?.dispose();
        entry.auxiliaryLights?.forEach((aux) => aux.dispose());
        if (entry.gi) {
          entry.gi.solution.dispose();
          entry.gi.rsm.dispose();
        }
        entry.mesh.dispose(false, true);
        lamps.delete(metadata.key);
        if (isStructural) {
          context.shipState.setLampEnabled(metadata.key, false);
        } else {
          context.shipState.removeLamp(metadata.key);
        }
        return true;
      },
      dispose: () => {
        context.ghost.hide();
        preview.dispose(false, true);
        lamps.forEach((lamp) => {
          context.shadowNetwork.detachLamp(lamp);
          context.shadowNetwork.unregisterDynamic(lamp.mesh);
          lamp.shadow.dispose();
          lamp.light.dispose();
          lamp.areaLight?.dispose();
          lamp.fillLight?.dispose();
          lamp.auxiliaryLights?.forEach((aux) => aux.dispose());
          if (lamp.gi) {
            lamp.gi.solution.dispose();
            lamp.gi.rsm.dispose();
          }
          lamp.mesh.dispose(false, true);
        });
        lamps.clear();
        pendingPlacement = null;
      },
    };
  },
};
</file>

<file path="src/fps/constants.ts">
import { Color3 } from "babylonjs";

// Core metric references keep the scene grounded in human scale (meters, kilograms, seconds).
export const HUMAN_DIMENSIONS = {
  height: 1.8,
  eyeLevel: 1.72,
} as const;

export const SHIP_INTERIOR_DIMENSIONS = {
  deckClearance: 2.1,
  doorHeight: 1.85,
} as const;

export const GRID_SIZE = 0.5;

export const WALL_DIMENSIONS = {
  width: 1,
  height: SHIP_INTERIOR_DIMENSIONS.deckClearance,
  thickness: 0.18,
  footingDepth: 0.04,
} as const;

export const HULL_DIMENSIONS = {
  width: 4.2,
  length: 9.6,
  height: SHIP_INTERIOR_DIMENSIONS.deckClearance,
} as const;

export const LAMP_DIMENSIONS = {
  height: 1.6,
  radius: 0.2,
  stemRadius: 0.05,
} as const;

export const CAMERA_SETTINGS = {
  speed: 1.6,
  sprintMultiplier: 1.75,
  minZ: 0.05,
  maxZ: 250,
  angularSensibility: 2600,
  inertia: 0.05,
  ellipsoid: { x: 0.35, y: 0.9, z: 0.35 },
  ellipsoidOffset: { x: 0, y: 0.9, z: 0 },
  eyeLevel: HUMAN_DIMENSIONS.eyeLevel,
} as const;

export const WALL_LIGHT_STRIP = {
  count: 6,
  height: 1.95,
  inset: 0.28,
  tilt: -0.18,
  cone: Math.PI / 3.1,
  range: 14,
  warm: {
    color: new Color3(1, 0.83, 0.58),
    intensity: 1.25,
  },
  cool: {
    color: new Color3(0.58, 0.8, 1),
    intensity: 1.15,
  },
} as const;

export const INPUT_KEYS = {
  move: {
    forward: 87, // W
    left: 65, // A
    backward: 83, // S
    right: 68, // D
  },
  rotate: "KeyR",
  sprint: ["ShiftLeft", "ShiftRight"],
  wallMode: "Digit1",
  lampMode: "Digit2",
  deleteMode: "Digit3",
} as const;

export const LAMP_COLOR_PALETTE = [
  new Color3(0.98, 0.82, 0.62),
  new Color3(0.72, 0.84, 1),
] as const;

export const WALL_LAMP_PLACEMENT = {
  width: 1.15,
  height: 0.12,
  depth: 0.22,
  offset: 0.06,
  tilt: 0.45,
  shadowMapSize: 640,
  intensity: 1.9,
  range: 11,
} as const;

export const LIGHTING_LIMITS = {
  maxSimultaneousLights: 24,
} as const;

export const SELECTION_OUTLINE_COLOR = new Color3(0.2, 0.65, 1);

export const INTERACTION_RANGE = 16;
</file>

<file path="AGENTS.md">
# Starwatch Field Manual

Welcome aboard the Mad Dash Initiative. We rebuilt the project structure mid-flight to chase a new goal: a first-person ship builder you can live inside, driven by AI automation. This document keeps everyone orientedâ€”especially as we keep the previous stack mothballed for reference.

## Current Timeline
- **2025-10-18** â€” Operation One Shot: we froze the original chat/editor/game UI in `src/legacy/` and spun up a fresh FPS hangar to stress-test wall placement, rotation, and general feel.
- Earlier commits predate the reset and live entirely inside the legacy tree; treat them as historical artifacts unless you are backporting specific ideas.

## Code Constellation
- `src/` now hosts the new MVP:
  - `App.tsx`, `main.tsx` â€” minimal bootstrap for the builder prototype.
  - `fps/ShipBuilderCanvas.tsx` â€” Babylon.js scene for first-person movement, placement tooling, and HUD overlays.
- Placement runtime highlights:
  - `fps/core/sceneContext.ts` builds the hangar hull, registers static meshes, and now publishes a `SurfaceRegistry`.
  - `fps/placement/surfaces/` defines pluggable surface adapters (`WallSurface`, `FloorSurface`, â€¦); every pickable surface registers here with consistent normals, snap grids, and offsets.
  - `fps/placement/placementSolver.ts` takes a tool profile (modes + constraints) and resolves placement frames from ray picks, so tools no longer manage Babylon math directly.
  - Tools (e.g., `lampTool`, `wallTool`) receive the shared solver via `ToolRuntimeContext` and only worry about preview meshes and item lifecycles. Adding a new â€œcrateâ€ that lives on the floor (or multi-surface items) is now a matter of declaring allowed modes in the profile and registering the relevant surfaces.
- `src/legacy/` shelters the previous React panels, HAL wiring, and Babylon scene (`game/`, `ui/`, `hal/`, plus old entry points). Use this when you need to reference assets or revive older features without polluting the new loop.
- `dist/`, `docs/`, and `releases/` retain their original purposes; respect `.gitignore` for generated assets.

## Build & Run Checklist
- `pnpm install` â€” install dependencies (Babylon.js already bundled; expect large builds).
- `pnpm dev` â€” Vite dev server for rapid iteration on the FPS builder.
- `pnpm build` â€” TypeScript check + production bundle (watch for >500â€¯kB chunk warnings due to Babylon; we will code-split later).
- `pnpm preview` â€” smoke-test the built assets.
- Keep `pnpm test` reserved for the future Vitest suite (no specs yet post-reset).

## Coding Playbook
- Strict TypeScriptâ€”no `any`. Use Babylon types (`Mesh`, `PointerInfo`, etc.) to keep editor assistance sharp.
- Two-space indent, camelCase helpers, PascalCase React components.
- Inline styles acceptable for HUD prototypes; migrate to shared styling once components settle.
- Add comments only where Babylon abstractions or math need extra context.

### Lighting & Shadows (2025-10-21)
- Babylon spot/area lights inherit their parent transform; set the light up in local space so the `forward` axis actually matches the emitter. We now parent a pivot node to each fixture, transform the desired world frame into that local basis, and attach both the area light and the shadow-casting spotlight to the pivot.
- Keep `Vector3.Backward()` as the local forward for the spotlight once it is parented to the pivot. Feeding world-space forward directly into the constructor caused the shadow cone to flip when fixtures were rotated.
- Clamp shadow bias aggressively (`0.00022` / `0.0035` for bias/normal bias) and pull `shadowMinZ` close to zero (`â‰ˆ0.008`) so thin walls stay grounded without acne.
- Give walls a shallow footing (`WALL_DIMENSIONS.footingDepth = 0.04`) and sink instanced walls by half that depth; otherwise light leaks under the panels even if the mesh appears flush.
- Disable `forceBackFacesOnly` on all generators. It looked tempting for RSM GI, but it ignored the illuminated faces and inverted the shadow direction.

## Testing & Telemetry
- Vitest + React Testing Library remain the plan. For now, favor small utility tests when you introduce deterministic builders or data serializers.
- Record manual repro steps when you tweak input handling (mouse lock, sprint, rotation) so the next agent can verify quickly.

## Collaboration Protocols
- Conventional Commits (`feat:`, `fix:`, `chore:`â€¦). Branch as `feat/builder-controls` or similar.
- PRs: include summary GIFs or short clips showing the builder interactions; list manual verification commands (`pnpm dev`, `pnpm build`).
- Leave the legacy code untouched unless you are extracting assets or documenting behavior; if you do open it, call it out in your PR description.

## Security & Configuration
- `.env` continues to be ignored; share sanitized `.env.example` values for any future HAL/LLM work (`OPENAI_API_KEY`, `OPENAI_MODEL` placeholders).
- Environment variables load through `import.meta.env.OPENAI_*`; validate in both dev and preview builds.

## Mission Ahead
- Short term: expand the builder with inventory selection, persistence, and undo/redo.
- Mid term: bring back HAL control, AI crew, and automation routines on top of the new world state.
- Long term: merge the rebuilt FPS core with narrative/chat layers once the construction loop feels right. Cross-check ideas with `MANIFESTO.md` whenever we plan new systems; that living document still captures the grand strategy and narrative tone we aim to restore.

Document the weird, celebrate the breakthroughs, and keep shipping. The hangar is ours now.
</file>

<file path="src/fps/types.ts">
import type {
  AbstractMesh,
  Color3,
  GIRSM,
  Light,
  Mesh,
  RectAreaLight,
  ReflectiveShadowMap,
  ShadowGenerator,
  ShadowLight,
  Quaternion,
  Vector3,
} from "babylonjs";

export interface BuilderWall {
  mesh: Mesh;
  key: string;
  rotation: number; // degrees around Y
}

export interface BuilderLamp {
  mesh: Mesh;
  light: ShadowLight;
  shadow: ShadowGenerator;
  areaLight?: RectAreaLight;
  fillLight?: Light;
  auxiliaryLights?: Light[];
  gi?: {
    rsm: ReflectiveShadowMap;
    solution: GIRSM;
  };
  key: string;
  color: Color3;
  anchorSurfaceId: string;
  local: { x: number; y: number; z: number };
  rotation: Quaternion;
}

export interface WallLampPlacement {
  mesh: AbstractMesh;
  position: Vector3;
  forward: Vector3;
  right: Vector3;
  up: Vector3;
  surfaceId: string;
  local: { x: number; y: number; z: number };
}
</file>

<file path="src/fps/placement/placementController.ts">
import {
  AbstractMesh,
  PointerEventTypes,
  PointerInfo,
  Scene,
  UniversalCamera,
  Vector3,
} from "babylonjs";
import { CAMERA_SETTINGS, INPUT_KEYS, INTERACTION_RANGE, SELECTION_OUTLINE_COLOR } from "../constants";
import type { ShadowNetwork } from "../lighting/shadowNetwork";
import type { BuilderLamp, BuilderWall } from "../types";
import type { GhostHost } from "./ghosts";
import type {
  PlacementState,
  PlacementToolInstance,
  ShipStateActions,
  ToolMetadata,
  ToolRuntimeContext,
} from "./placementTypes";
import { TOOL_DEFINITION_BY_ID, TOOL_DEFINITIONS } from "./tools";
import type { SurfaceRegistry } from "./surfaces/surfaceRegistry";
import { createPlacementSolver } from "./placementSolver";
import type { ShipStore } from "../state/shipStore";

interface PlacementControllerOptions {
  scene: Scene;
  canvas: HTMLCanvasElement;
  camera: UniversalCamera;
  ghost: GhostHost;
  shadowNetwork: ShadowNetwork;
  surfaceRegistry: SurfaceRegistry;
  initialWalls?: BuilderWall[];
  initialLamps?: BuilderLamp[];
  shipStore: ShipStore;
}

export interface PlacementController {
  getState(): PlacementState;
  setActiveTool(toolId: string): void;
  subscribe(listener: (state: PlacementState) => void): () => void;
  dispose(): void;
}

export function createPlacementController(options: PlacementControllerOptions): PlacementController {
  const { scene, canvas, camera, ghost, shadowNetwork, surfaceRegistry, shipStore } = options;
  const initialWalls = options.initialWalls ?? [];
  const initialLamps = options.initialLamps ?? [];
  const placementSolver = createPlacementSolver(surfaceRegistry);
  const shipActions: ShipStateActions = {
    upsertWall: (wall) => shipStore.upsertWall(wall),
    removeWall: (wallId) => shipStore.removeWall(wallId),
    upsertLamp: (lamp) => shipStore.upsertLamp(lamp),
    removeLamp: (lampId) => shipStore.removeLamp(lampId),
    setLampEnabled: (lampId, enabled) => shipStore.setLampEnabled(lampId, enabled),
  };

  const defaultToolId = TOOL_DEFINITIONS[0]?.id ?? "wall";

  const state: PlacementState = {
    activeToolId: defaultToolId,
  };

  const toolBootstrap = new Map<string, unknown>();
  if (initialWalls.length > 0) {
    toolBootstrap.set("wall", initialWalls);
  }
  if (initialLamps.length > 0) {
    toolBootstrap.set("lamp", initialLamps);
  }

  const listeners = new Set<(snapshot: PlacementState) => void>();
  const toolInstances = new Map<string, PlacementToolInstance>();
  const sprintKeys = new Set<string>(Array.from(INPUT_KEYS.sprint));
  const hotkeyToToolId = new Map<string, string>();
  const baseCameraSpeed = CAMERA_SETTINGS.speed;

  let activeTool: PlacementToolInstance | null = null;
  let highlighted: AbstractMesh | null = null;

  const notify = () => {
    const snapshot: PlacementState = { ...state };
    listeners.forEach((listener) => listener(snapshot));
  };

  const clearHighlight = () => {
    if (!highlighted || highlighted.isDisposed()) {
      highlighted = null;
      return;
    }
    highlighted.renderOutline = false;
    highlighted = null;
  };

  const applyHighlight = (mesh?: AbstractMesh | null) => {
    const target = mesh ?? null;
    if (!target) {
      clearHighlight();
      return;
    }

    if (highlighted === target) {
      return;
    }

    clearHighlight();
    target.renderOutline = true;
    target.outlineColor = SELECTION_OUTLINE_COLOR;
    target.outlineWidth = 0.018;
    highlighted = target;
  };

  const withinRange = (point?: Vector3 | null) => {
    if (!point) {
      return false;
    }
    return Vector3.Distance(camera.position, point) <= INTERACTION_RANGE;
  };

  hotkeyToToolId.clear();
  TOOL_DEFINITIONS.forEach((definition) => {
    hotkeyToToolId.set(definition.hotkey, definition.id);
  });

  const runtimeContext: ToolRuntimeContext = {
    scene,
    camera,
    canvas,
    shadowNetwork,
    ghost,
    surfaceRegistry,
    placementSolver,
    shipState: shipActions,
    withinRange,
    requestPointerLock: () => {
      if (document.pointerLockElement !== canvas) {
        canvas.requestPointerLock();
      }
    },
    highlight: (mesh?: AbstractMesh | null) => {
      if (!mesh) {
        clearHighlight();
        return;
      }
      applyHighlight(mesh);
    },
    removeMesh: (mesh?: AbstractMesh | null) => {
      const removed = removeMesh(mesh);
      if (removed) {
        clearHighlight();
      }
      return removed;
    },
  };

  const getToolInstance = (toolId: string): PlacementToolInstance | null => {
    const existing = toolInstances.get(toolId);
    if (existing) {
      return existing;
    }

    const definition = TOOL_DEFINITION_BY_ID.get(toolId);
    if (!definition) {
      return null;
    }

    const bootstrap = toolBootstrap.get(toolId);
    const instance = definition.create(runtimeContext, bootstrap);
    toolInstances.set(toolId, instance);
    return instance;
  };

  toolBootstrap.forEach((_, toolId) => {
    if (toolId !== state.activeToolId) {
      getToolInstance(toolId);
    }
  });

  const removeMesh = (mesh?: AbstractMesh | null): boolean => {
    if (!mesh) {
      return false;
    }

    const metadata = mesh.metadata as ToolMetadata | undefined;
    if (
      !metadata ||
      typeof metadata.toolId !== "string" ||
      typeof metadata.key !== "string"
    ) {
      return false;
    }

    const tool = getToolInstance(metadata.toolId);
    if (!tool || !tool.remove) {
      return false;
    }

    const removed = tool.remove(metadata, mesh);
    if (removed && mesh === highlighted) {
      clearHighlight();
    }
    return removed;
  };

  const setActiveToolInternal = (toolId: string, fromHotkey = false) => {
    if (state.activeToolId === toolId && !fromHotkey) {
      return;
    }

    const next = getToolInstance(toolId);
    if (!next) {
      return;
    }

    if (activeTool && activeTool.onDeactivate) {
      activeTool.onDeactivate();
    }

    activeTool = next;
    state.activeToolId = toolId;
    if (activeTool.onActivate) {
      activeTool.onActivate();
    }
    notify();
  };

  const attemptRemoveAtPointer = () => {
    const pick = scene.pick(
      scene.pointerX,
      scene.pointerY,
      (mesh) => {
        const metadata = mesh?.metadata as { toolId?: unknown } | undefined;
        return typeof metadata?.toolId === "string";
      },
    );

    if (!withinRange(pick?.pickedPoint)) {
      return false;
    }

    return removeMesh(pick?.pickedMesh ?? null);
  };

  const pointerObserver = scene.onPointerObservable.add((pointerInfo: PointerInfo) => {
    switch (pointerInfo.type) {
      case PointerEventTypes.POINTERMOVE:
        activeTool?.onPointerMove?.(pointerInfo);
        break;
      case PointerEventTypes.POINTERDOWN: {
        if (pointerInfo.event.button === 0) {
          runtimeContext.requestPointerLock();
        }

        if (pointerInfo.event.button === 2) {
          pointerInfo.event.preventDefault();
          attemptRemoveAtPointer();
          return;
        }

        activeTool?.onPointerDown?.(pointerInfo);
        break;
      }
      case PointerEventTypes.POINTERUP:
        activeTool?.onPointerUp?.(pointerInfo);
        break;
      default:
        break;
    }
  });

  const handleKeyDown = (event: KeyboardEvent) => {
    if (sprintKeys.has(event.code)) {
      camera.speed = baseCameraSpeed * CAMERA_SETTINGS.sprintMultiplier;
    }

    const toolId = hotkeyToToolId.get(event.code);
    if (toolId) {
      setActiveToolInternal(toolId, true);
      return;
    }

    activeTool?.onKeyDown?.(event);
  };

  const handleKeyUp = (event: KeyboardEvent) => {
    if (sprintKeys.has(event.code)) {
      camera.speed = baseCameraSpeed;
    }

    activeTool?.onKeyUp?.(event);
  };

  const handlePointerLockChange = () => {
    const locked = document.pointerLockElement === canvas;
    if (!locked) {
      ghost.hide();
      clearHighlight();
    }
    activeTool?.onPointerLockChange?.(locked);
  };

  const handleContextMenu = (event: MouseEvent) => {
    event.preventDefault();
  };

  window.addEventListener("keydown", handleKeyDown);
  window.addEventListener("keyup", handleKeyUp);
  document.addEventListener("pointerlockchange", handlePointerLockChange);
  canvas.addEventListener("contextmenu", handleContextMenu);

  const initialTool = getToolInstance(state.activeToolId);
  activeTool = initialTool;
  activeTool?.onActivate?.();

  return {
    getState: () => ({ ...state }),
    setActiveTool: (toolId: string) => {
      setActiveToolInternal(toolId);
    },
    subscribe: (listener: (snapshot: PlacementState) => void) => {
      listeners.add(listener);
      listener({ ...state });
      return () => {
        listeners.delete(listener);
      };
    },
    dispose: () => {
      scene.onPointerObservable.remove(pointerObserver);
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
      document.removeEventListener("pointerlockchange", handlePointerLockChange);
      canvas.removeEventListener("contextmenu", handleContextMenu);

      if (activeTool && activeTool.onDeactivate) {
        activeTool.onDeactivate();
      }

      toolInstances.forEach((tool) => {
        tool.dispose?.();
      });
      toolInstances.clear();

      ghost.clear();
      clearHighlight();
      listeners.clear();
      hotkeyToToolId.clear();
    },
  };
}
</file>

<file path="src/fps/placement/wallBuilder.ts">
import { Matrix, MeshBuilder, PBRMaterial, Vector3 } from "babylonjs";
import type { Scene } from "babylonjs";
import { GRID_SIZE, HULL_DIMENSIONS, WALL_DIMENSIONS, LIGHTING_LIMITS } from "../constants";
import type { BuilderWall } from "../types";
import { clamp, degreesToRadians } from "../utils/math";
import { applyHangarTextures, disposeHangarMaterial, getHangarTextureSet } from "../core/hangarTextures";

export function snapWallPosition(point: Vector3) {
  const halfWidth = HULL_DIMENSIONS.width / 2 - WALL_DIMENSIONS.width / 2;
  const halfLength = HULL_DIMENSIONS.length / 2 - WALL_DIMENSIONS.width / 2;

  const snappedX = clamp(
    Math.round(point.x / GRID_SIZE) * GRID_SIZE,
    -halfWidth,
    halfWidth,
  );
  const snappedZ = clamp(
    Math.round(point.z / GRID_SIZE) * GRID_SIZE,
    -halfLength,
    halfLength,
  );

  return new Vector3(snappedX, WALL_DIMENSIONS.height / 2, snappedZ);
}

export function wallKey(position: Vector3, rotation: number) {
  return `${position.x}:${position.y}:${position.z}:${rotation}`;
}

export function createWall(scene: Scene, position: Vector3, rotation: number): BuilderWall {
  const footingDepth = WALL_DIMENSIONS.footingDepth ?? 0;
  const boxHeight = WALL_DIMENSIONS.height + footingDepth;
  const wallMesh = MeshBuilder.CreateBox(
    `builder-wall-${Date.now()}`,
    {
      width: WALL_DIMENSIONS.width,
      height: boxHeight,
      depth: WALL_DIMENSIONS.thickness,
    },
    scene,
  );

  wallMesh.position = position.clone();
  wallMesh.position.y -= footingDepth / 2;
  wallMesh.rotation.y = degreesToRadians(rotation);
  wallMesh.checkCollisions = true;
  wallMesh.receiveShadows = true;

  const armorTextures = getHangarTextureSet(scene, "armor");
  const material = new PBRMaterial(`builder-wall-pbr-${Date.now()}`, scene);
  const tileU = Math.max(WALL_DIMENSIONS.width, WALL_DIMENSIONS.height) * 0.9;
  const tileV = WALL_DIMENSIONS.height * 0.95;
  applyHangarTextures(material, armorTextures, { u: tileU, v: tileV });
  material.ambientTextureStrength = 0.94;
  material.useAmbientInGrayScale = true;
  material.metallic = 0.36;
  material.roughness = 0.88;
  material.microSurface = 0.8;
  material.environmentIntensity = 0.7;
  material.specularIntensity = 1.0;
  material.backFaceCulling = true;
  material.twoSidedLighting = false;
  material.maxSimultaneousLights = LIGHTING_LIMITS.maxSimultaneousLights;
  wallMesh.material = material;

  const key = wallKey(position, rotation);
  const rotationMatrix = Matrix.RotationY(wallMesh.rotation.y);
  const inward = Vector3.TransformNormal(Vector3.Forward(), rotationMatrix).scale(-1).normalize();
  const up = Vector3.Up();

  wallMesh.metadata = {
    toolId: "wall",
    key,
    surfaceId: key,
    lampOrientation: {
      forward: inward.asArray(),
      up: up.asArray(),
    },
    textureTiling: { u: tileU, v: tileV },
  };

  wallMesh.onDisposeObservable.add(() => {
    disposeHangarMaterial(material);
  });

  return {
    mesh: wallMesh,
    key,
    rotation,
  };
}
</file>

<file path="src/App.tsx">
import { ShipBuilderCanvas } from "./fps/ShipBuilderCanvas";

export default function App() {
  return (
    <div
      style={{
        position: "relative",
        width: "100vw",
        height: "100vh",
        overflow: "hidden",
        background: "#05060a",
        color: "#f1f5f9",
        fontFamily: "'Segoe UI', Roboto, sans-serif",
      }}
    >
      <ShipBuilderCanvas />
      <div
        style={{
          position: "absolute",
          top: 16,
          left: 16,
          padding: "12px 16px",
          background: "rgba(15, 23, 42, 0.72)",
          border: "1px solid rgba(148, 163, 184, 0.32)",
          borderRadius: 8,
          maxWidth: 360,
          backdropFilter: "blur(10px)",
        }}
      >
        <h1 style={{ fontSize: 18, margin: "0 0 8px" }}>Ship Builder MVP</h1>
        <p style={{ margin: "6px 0", fontSize: 13, lineHeight: 1.4 }}>
          Explore the hangar in first-person and experiment with dropping walls
          inside the rectangular hull. This pass focuses on grid snapping and
          quick prototyping of construction flow.
        </p>
        <ul style={{ margin: "6px 0 0", paddingLeft: 16, fontSize: 13 }}>
          <li>WASD â€” move / Shift â€” sprint</li>
          <li>Mouse â€” look (click canvas to lock)</li>
          <li>1 â€” wall mode / 2 â€” lamp mode / 3 â€” remove mode</li>
          <li>Left click â€” place item / Delete mode + click (ou botÃ£o direito) â€” remove</li>
          <li>R â€” rotate walls (90Â° steps)</li>
          <li>Esc â€” release cursor lock</li>
        </ul>
        <p style={{ margin: "10px 0 0", fontSize: 12, opacity: 0.85 }}>
          Lamps cycle between warm and cool tones and cast soft shadowsâ€”perfect
          for finding that cozy blue-gold balance.
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/fps/ShipBuilderCanvas.tsx">
import { useEffect, useRef, useState } from "react";
import { createSceneContext } from "./core/sceneContext";
import { createPlayerController } from "./core/playerController";
import { createPlacementController } from "./placement/placementController";
import type { PlacementController } from "./placement/placementController";
import { createGhostHost } from "./placement/ghosts";
import type { PlacementState } from "./placement/placementTypes";
import { TOOL_DEFINITIONS } from "./placement/tools";
import { createShadowNetwork } from "./lighting/shadowNetwork";
import { ShipStore } from "./state/shipStore";
import { createShipPersistence, loadShipState } from "./state/shipPersistence";
import { hydrateShipAssets } from "./state/shipHydrator";
import { PlayerStore } from "./state/playerStore";
import { createPlayerPersistence, loadPlayerState } from "./state/playerPersistence";
import { registerBaselinePlayerModules } from "./state/playerModules";
import type { BuilderLamp } from "./types";
import { serializeColor, serializeQuaternion, serializeVector3 } from "./state/shipState";

const defaultToolId = TOOL_DEFINITIONS[0]?.id ?? "wall";

function formatHotkey(code: string) {
  if (code.startsWith("Digit")) {
    return code.slice(5);
  }
  if (code.startsWith("Key")) {
    return code.slice(3);
  }
  if (code.startsWith("Numpad")) {
    return `Num${code.slice(6)}`;
  }
  if (code.endsWith("Arrow")) {
    return code.replace("Arrow", "");
  }
  if (code === "ShiftLeft" || code === "ShiftRight") {
    return "Shift";
  }
  return code;
}

export function ShipBuilderCanvas() {
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const overlayRef = useRef<HTMLDivElement | null>(null);
  const controllerRef = useRef<PlacementController | null>(null);
  const shipStoreRef = useRef<ShipStore | null>(null);
  const playerStoreRef = useRef<PlayerStore | null>(null);
  const [placementState, setPlacementState] = useState<PlacementState>({
    activeToolId: defaultToolId,
  });

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) {
      return;
    }

    if (!shipStoreRef.current) {
      shipStoreRef.current = new ShipStore();
    }
    const shipStore = shipStoreRef.current;
    const persistedShipState = loadShipState();
    if (persistedShipState) {
      shipStore.replace(persistedShipState);
    }

    if (!playerStoreRef.current) {
      const persistedPlayer = loadPlayerState();
      playerStoreRef.current = new PlayerStore(persistedPlayer ?? undefined);
      registerBaselinePlayerModules(playerStoreRef.current);
    }
    const playerStore = playerStoreRef.current;
    if (!playerStore) {
      return;
    }

    const disposeStructuralLamp = (lamp: BuilderLamp) => {
      lamp.shadow.dispose();
      lamp.light.dispose();
      lamp.areaLight?.dispose();
      lamp.fillLight?.dispose();
      lamp.auxiliaryLights?.forEach((aux) => aux.dispose());
      lamp.gi?.solution.dispose();
      lamp.gi?.rsm.dispose();
      lamp.mesh.dispose(false, true);
    };

    const sceneContext = createSceneContext(canvas);
    const structuralLamps: BuilderLamp[] = [];
    sceneContext.structuralLamps.forEach((lamp) => {
      const key = lamp.key;
      if (!key) {
        structuralLamps.push(lamp);
        return;
      }

      const currentSnapshot = shipStore.getSnapshot();
      const existing = currentSnapshot.lamps[key];
      const local = lamp.local ?? { x: 0, y: 0, z: 0 };

      if (!existing) {
        shipStore.upsertLamp({
          id: key,
          anchorSurfaceId: lamp.anchorSurfaceId,
          position: serializeVector3(lamp.mesh.position.x, lamp.mesh.position.y, lamp.mesh.position.z),
          rotation: serializeQuaternion(lamp.rotation.x, lamp.rotation.y, lamp.rotation.z, lamp.rotation.w),
          color: serializeColor(lamp.color.r, lamp.color.g, lamp.color.b),
          local: { ...local },
          structural: true,
          enabled: true,
        });
      } else {
        if (existing.enabled === false) {
          disposeStructuralLamp(lamp);
          return;
        }
        if (!existing.structural || existing.enabled === undefined) {
          shipStore.upsertLamp({
            ...existing,
            structural: true,
            enabled: existing.enabled ?? true,
          });
        }
      }

      lamp.mesh.metadata = {
        ...(lamp.mesh.metadata as Record<string, unknown> | undefined),
        toolId: "lamp",
        key,
        structural: true,
        surfaceId: lamp.anchorSurfaceId,
        local,
      };
      structuralLamps.push(lamp);
    });
    sceneContext.structuralLamps = structuralLamps;
    const ghost = createGhostHost();
    const shadowNetwork = createShadowNetwork(
      structuralLamps.map((lamp) => lamp.shadow),
    );
    const staticMeshes = [sceneContext.floor, ...sceneContext.staticMeshes];
    structuralLamps.forEach((lamp) => {
      shadowNetwork.registerDynamic(lamp.mesh);
      shadowNetwork.attachLamp(lamp);
    });
    shadowNetwork.registerStatic(staticMeshes);

    const playerController = createPlayerController({
      scene: sceneContext.scene,
      canvas,
      store: playerStore,
    });

    const hydratedAssets = hydrateShipAssets(sceneContext.scene, shipStore.getSnapshot());

    const placementController = createPlacementController({
      scene: sceneContext.scene,
      canvas,
      camera: playerController.camera,
      ghost,
      shadowNetwork,
      surfaceRegistry: sceneContext.surfaceRegistry,
      initialWalls: hydratedAssets.walls,
      initialLamps: [...structuralLamps, ...hydratedAssets.lamps],
      shipStore,
    });
    controllerRef.current = placementController;
    const unsubscribePlacement = placementController.subscribe(setPlacementState);
    const persistence = createShipPersistence(shipStore);
    const playerPersistence = createPlayerPersistence(playerStore);

    let statsHandle = 0;
    let lastSample = 0;
    const updateOverlay = (timestamp: number) => {
      statsHandle = requestAnimationFrame(updateOverlay);
      if (!overlayRef.current) {
        return;
      }
      if (timestamp - lastSample < 250) {
        return;
      }
      lastSample = timestamp;

      const fps = sceneContext.engine.getFps();
      const meshCount = sceneContext.scene.meshes.length;
      const lightCount = sceneContext.scene.lights.length;
      const shadowedLights = sceneContext.scene.lights.filter((light) => light.shadowEnabled).length;
      const camera = playerController.camera.position;

      overlayRef.current.textContent = [
        `FPS: ${fps.toFixed(1)}`,
        `Meshes: ${meshCount}`,
        `Lights: ${lightCount} (shadowed: ${shadowedLights})`,
        `Camera: (${camera.x.toFixed(2)}, ${camera.y.toFixed(2)}, ${camera.z.toFixed(2)})`,
      ].join("\n");
    };
    statsHandle = requestAnimationFrame(updateOverlay);

    return () => {
      persistence.flush();
      persistence.dispose();
      playerPersistence.flush();
      playerPersistence.dispose();
      unsubscribePlacement();
      placementController.dispose();
      controllerRef.current = null;
      ghost.dispose();
      shadowNetwork.dispose();
      playerController.dispose();
      sceneContext.dispose();
      cancelAnimationFrame(statsHandle);
    };
  }, []);

  const handleToolClick = (toolId: string) => () => {
    controllerRef.current?.setActiveTool(toolId);
  };

  const toolbarItems = TOOL_DEFINITIONS.map((tool) => ({
    id: tool.id,
    label: tool.label,
    hint: formatHotkey(tool.hotkey),
    icon: tool.icon,
  }));

  return (
    <div
      style={{
        position: "relative",
        width: "100%",
        height: "100%",
      }}
    >
      <canvas
        ref={canvasRef}
        style={{
          width: "100%",
          height: "100%",
          display: "block",
        }}
      />
      <div
        style={{
          position: "absolute",
          left: "50%",
          bottom: 24,
          transform: "translateX(-50%)",
          display: "flex",
          gap: 12,
          padding: "10px 16px",
          borderRadius: 18,
          background: "rgba(8, 10, 16, 0.76)",
          border: "1px solid rgba(88, 126, 168, 0.45)",
          boxShadow: "0 10px 32px rgba(0, 0, 0, 0.44)",
          backdropFilter: "blur(9px)",
        }}
      >
        {toolbarItems.map((item) => {
          const isActive = placementState.activeToolId === item.id;
          return (
            <button
              key={item.id}
              type="button"
              onClick={handleToolClick(item.id)}
              style={{
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                justifyContent: "center",
                minWidth: 76,
                padding: "10px 14px 8px",
                borderRadius: 12,
                border: isActive
                  ? "1px solid rgba(160, 210, 255, 0.8)"
                  : "1px solid rgba(120, 168, 220, 0.35)",
                background: isActive ? "rgba(56, 120, 200, 0.45)" : "rgba(22, 28, 40, 0.68)",
                color: isActive ? "#e8f6ff" : "#9db6d4",
                fontFamily: "Inter, system-ui, sans-serif",
                fontSize: "13px",
                letterSpacing: "0.02em",
                cursor: "pointer",
                transition: "background 120ms ease, transform 120ms ease, border-color 120ms ease",
              }}
            >
              <span
                style={{
                  fontSize: "18px",
                  marginBottom: 6,
                }}
              >
                {item.icon}
              </span>
              <span>{item.label}</span>
              <span
                style={{
                  fontSize: "11px",
                  marginTop: 4,
                  opacity: 0.72,
                }}
              >
                [{item.hint}]
              </span>
            </button>
          );
        })}
      </div>
      <div
        ref={overlayRef}
        style={{
          position: "absolute",
          top: 16,
          right: 16,
          padding: "10px 14px",
          background: "rgba(8, 10, 16, 0.82)",
          color: "#d8f1ff",
          fontFamily: "monospace",
          fontSize: "12px",
          lineHeight: "16px",
          borderRadius: 8,
          border: "1px solid rgba(95, 136, 180, 0.45)",
          pointerEvents: "none",
          boxShadow: "0 4px 20px rgba(0, 0, 0, 0.35)",
          textShadow: "0 0 6px rgba(40, 132, 210, 0.4)",
          whiteSpace: "pre",
        }}
      />
    </div>
  );
}
</file>

<file path="src/fps/placement/lampBuilder.ts">
import { Color3, Matrix, MeshBuilder, Quaternion, Scene, StandardMaterial, Vector3 } from "babylonjs";
import { LAMP_COLOR_PALETTE, WALL_LAMP_PLACEMENT, LIGHTING_LIMITS } from "../constants";
import type { BuilderLamp, WallLampPlacement } from "../types";
import { createRectAreaLamp } from "../lighting/rectAreaLamp";

export function nextLampColor(index: number) {
  return LAMP_COLOR_PALETTE[index % LAMP_COLOR_PALETTE.length];
}

export function lampKey(placement: WallLampPlacement) {
  // Local coordinates are already snapped, so we can use them for deterministic keys.
  return `${placement.surfaceId}:${placement.local.x}:${placement.local.y}`;
}

export function createLamp(scene: Scene, placement: WallLampPlacement, color: Color3): BuilderLamp {
  const fixture = MeshBuilder.CreateBox(
    `lamp-fixture-${Date.now()}`,
    {
      width: WALL_LAMP_PLACEMENT.width,
      height: WALL_LAMP_PLACEMENT.height,
      depth: WALL_LAMP_PLACEMENT.depth,
    },
    scene,
  );

  const forwardDir = placement.forward.clone();
  const upDir = placement.up.clone();
  const rightDir = placement.right.clone();

  const basis = new Matrix();
  Matrix.FromXYZAxesToRef(rightDir, upDir, forwardDir, basis);
  const rotation = Quaternion.FromRotationMatrix(basis);

  fixture.rotationQuaternion = rotation;
  const anchoredPosition = placement.position.clone();
  fixture.position = anchoredPosition;
  fixture.isPickable = true;
  fixture.checkCollisions = false;

  const material = new StandardMaterial(`lamp-fixture-mat-${Date.now()}`, scene);
  material.diffuseColor = color.scale(0.18);
  material.specularColor = color.scale(0.24);
  material.emissiveColor = color.scale(1.18);
  material.backFaceCulling = false;
  material.maxSimultaneousLights = LIGHTING_LIMITS.maxSimultaneousLights;
  fixture.material = material;

  const lampKeyValue = lampKey(placement);
  fixture.metadata = { toolId: "lamp", key: lampKeyValue };

  const lamp = createRectAreaLamp({
    name: `lamp-${lampKeyValue}`,
    scene,
    fixture,
    position: anchoredPosition.clone(),
    right: rightDir,
    up: upDir,
    forward: forwardDir,
    areaSize: { width: WALL_LAMP_PLACEMENT.width, height: WALL_LAMP_PLACEMENT.height },
    color,
    range: WALL_LAMP_PLACEMENT.range,
    tilt: WALL_LAMP_PLACEMENT.tilt,
    twoSided: false,
    areaIntensity: WALL_LAMP_PLACEMENT.intensity * 8,
    shadowIntensity: WALL_LAMP_PLACEMENT.intensity,
    ambientIntensity: WALL_LAMP_PLACEMENT.intensity * 0.28,
    ambientRangeMultiplier: 0.7,
    ambientAttenuation: 0.52,
    shadowAngle: Math.PI / 2.35,
    shadowMapSize: WALL_LAMP_PLACEMENT.shadowMapSize,
    shadowBias: 0.00024,
    shadowNormalBias: 0.0038,
    forceBackFacesOnly: false,
    shadowMinZ: 0.008,
    areaOffset: WALL_LAMP_PLACEMENT.depth * 0.42,
    enableRsm: true,
    rsmTextureSize: 192,
    rsmNumSamples: 160,
    rsmRadius: 0.18,
    rsmIntensity: 0.22,
    rsmEdgeCorrection: 0.1,
    rsmNoiseFactor: 70,
  });
  lamp.key = lampKeyValue;
  lamp.mesh.metadata = { toolId: "lamp", key: lampKeyValue };
  lamp.color = color.clone();
  lamp.anchorSurfaceId = placement.surfaceId;
  lamp.local = { x: placement.local.x, y: placement.local.y, z: placement.local.z };
  lamp.rotation = rotation.clone();
  return lamp;
}
</file>

<file path="src/fps/core/sceneContext.ts">
import { Color3, Color4, Engine, GlowLayer, Mesh, MeshBuilder, Scene, Vector3, PBRMaterial, StandardMaterial } from "babylonjs";
import {
  GRID_SIZE,
  HULL_DIMENSIONS,
  WALL_DIMENSIONS,
  LIGHTING_LIMITS,
} from "../constants";
import type { BuilderLamp } from "../types";
import { createSurfaceRegistry } from "../placement/surfaces/surfaceRegistry";
import type { SurfaceRegistry } from "../placement/surfaces/surfaceRegistry";
import { FloorSurface } from "../placement/surfaces/floorSurface";
import { WallSurface } from "../placement/surfaces/wallSurface";
import { createRectAreaLamp } from "../lighting/rectAreaLamp";
import {
  applyHangarTextures,
  disposeHangarMaterial,
  disposeHangarTextureCache,
  getHangarTextureSet,
  type HangarTextureSet,
} from "./hangarTextures";

export interface SceneContext {
  engine: Engine;
  scene: Scene;
  glowLayer: GlowLayer;
  floor: Mesh;
  staticMeshes: Mesh[];
  structuralLamps: BuilderLamp[];
  surfaceRegistry: SurfaceRegistry;
  dispose(): void;
}

export function createSceneContext(canvas: HTMLCanvasElement): SceneContext {
  const engine = new Engine(canvas, true, {
    preserveDrawingBuffer: true,
    stencil: true,
    doNotHandleContextLost: true,
  });
  engine.disableUniformBuffers = true;

  const scene = new Scene(engine);
  scene.clearColor = new Color4(5 / 255, 6 / 255, 10 / 255, 1);
  scene.ambientColor = Color3.Black();
  scene.gravity = new Vector3(0, -9.81, 0);
  scene.collisionsEnabled = true;
  scene.imageProcessingConfiguration.toneMappingEnabled = true;
  scene.imageProcessingConfiguration.exposure = 1.08;
  scene.imageProcessingConfiguration.contrast = 1.04;

  const glowLayer = new GlowLayer("hangar-glow", scene);
  glowLayer.intensity = 0.18;

  const floorTextures = getHangarTextureSet(scene, "metal");
  const wallTextures = getHangarTextureSet(scene, "armor");

  const { floor, ceiling, walls } = buildHangar(scene, {
    floor: floorTextures,
    wall: wallTextures,
  });
  const surfaceRegistry = createSurfaceRegistry();
  surfaceRegistry.register(
    new FloorSurface({
      id: "hangar-floor",
      mesh: floor,
      up: Vector3.Up(),
      forward: new Vector3(0, 0, 1),
    }),
  );
  walls.forEach((wall) => {
    const inward = new Vector3(-wall.position.x, 0, -wall.position.z);
    if (inward.lengthSquared() < 1e-4) {
      const normal = Vector3.TransformNormal(Vector3.Forward(), wall.getWorldMatrix());
      inward.copyFrom(normal.scale(-1));
      inward.y = 0;
    }
    if (inward.lengthSquared() < 1e-4) {
      inward.copyFrom(Vector3.Forward());
    }
    surfaceRegistry.register(
      new WallSurface({
        id: wall.name ?? `wall-${wall.uniqueId}`,
        mesh: wall,
        inward,
        up: Vector3.Up(),
      }),
    );
  });
  const staticMeshes = [...walls, ceiling];
  floor.receiveShadows = true;
  floor.checkCollisions = true;
  staticMeshes.forEach((mesh) => {
    mesh.receiveShadows = true;
    mesh.checkCollisions = true;
  });

  const structuralLamps = createStructuralLamps(scene);
  structuralLamps.forEach((lamp) => {
    lamp.mesh.checkCollisions = false;
    lamp.mesh.isPickable = false;
  });

  engine.runRenderLoop(() => {
    scene.render();
  });

  const resize = () => {
    engine.resize();
  };
  window.addEventListener("resize", resize);

  const sceneContext: SceneContext = {
    engine,
    scene,
    glowLayer,
    floor,
    staticMeshes,
    structuralLamps,
    surfaceRegistry,
    dispose: () => {
      window.removeEventListener("resize", resize);
      glowLayer.dispose();
      structuralLamps.forEach((lamp) => {
        if (lamp.mesh.isDisposed()) {
          return;
        }
        lamp.shadow.dispose();
        lamp.light.dispose();
        lamp.areaLight?.dispose();
        lamp.fillLight?.dispose();
        lamp.auxiliaryLights?.forEach((aux) => aux.dispose());
        if (lamp.gi) {
          lamp.gi.solution.dispose();
          lamp.gi.rsm.dispose();
        }
        lamp.mesh.dispose(false, true);
      });
      surfaceRegistry.dispose();
      disposeHangarMaterials([floor, ceiling, ...walls]);
      disposeHangarTextureCache(scene);
      scene.dispose();
      engine.dispose();
    },
  };
  return sceneContext;
}

interface HangarAssets {
  floor: Mesh;
  ceiling: Mesh;
  walls: Mesh[];
}

function buildHangar(
  scene: Scene,
  textures: {
    floor: HangarTextureSet;
    wall: HangarTextureSet;
  },
): HangarAssets {
  const floor = createHangarFloor(scene, textures.floor);
  const ceiling = createHangarCeiling(scene, textures.floor);
  const walls = createHangarWalls(scene, textures.wall);
  return { floor, ceiling, walls };
}

function createHangarFloor(scene: Scene, textures: HangarTextureSet): Mesh {
  const subdivisionsX = Math.max(1, Math.round(HULL_DIMENSIONS.width / GRID_SIZE));
  const subdivisionsZ = Math.max(1, Math.round(HULL_DIMENSIONS.length / GRID_SIZE));

  const floor = MeshBuilder.CreateGround(
    "hangar-floor",
    {
      width: HULL_DIMENSIONS.width,
      height: HULL_DIMENSIONS.length,
      subdivisionsX,
      subdivisionsY: subdivisionsZ,
    },
    scene,
  );
  floor.position.y = 0;
  floor.metadata = { type: "ship-foundation", textureTiling: { u: 4.2, v: 6.0 } };

  const floorMaterial = new PBRMaterial("floor-pbr", scene);
  applyHangarTextures(floorMaterial, textures, (floor.metadata as { textureTiling: { u: number; v: number } }).textureTiling);
  floorMaterial.ambientTextureStrength = 0.92;
  floorMaterial.useAmbientInGrayScale = true;
  floorMaterial.metallic = 0.42;
  floorMaterial.roughness = 0.84;
  floorMaterial.microSurface = 0.86;
  floorMaterial.environmentIntensity = 0.72;
  floorMaterial.specularIntensity = 1.1;
  floorMaterial.backFaceCulling = true;
  floorMaterial.maxSimultaneousLights = LIGHTING_LIMITS.maxSimultaneousLights;
  floor.material = floorMaterial;

  return floor;
}

function createHangarCeiling(scene: Scene, textures: HangarTextureSet): Mesh {
  const subdivisionsX = Math.max(1, Math.round(HULL_DIMENSIONS.width / GRID_SIZE));
  const subdivisionsZ = Math.max(1, Math.round(HULL_DIMENSIONS.length / GRID_SIZE));

  const ceiling = MeshBuilder.CreateGround(
    "hangar-ceiling",
    {
      width: HULL_DIMENSIONS.width,
      height: HULL_DIMENSIONS.length,
      subdivisionsX,
      subdivisionsY: subdivisionsZ,
    },
    scene,
  );
  ceiling.position.y = HULL_DIMENSIONS.height;
  ceiling.rotation.x = Math.PI;
  ceiling.metadata = { type: "ship-foundation", textureTiling: { u: 3.4, v: 5.0 } };

  const ceilingMaterial = new PBRMaterial("ceiling-pbr", scene);
  applyHangarTextures(
    ceilingMaterial,
    textures,
    (ceiling.metadata as { textureTiling: { u: number; v: number } }).textureTiling,
  );
  ceilingMaterial.ambientTextureStrength = 0.85;
  ceilingMaterial.useAmbientInGrayScale = true;
  ceilingMaterial.metallic = 0.28;
  ceilingMaterial.roughness = 0.9;
  ceilingMaterial.microSurface = 0.78;
  ceilingMaterial.environmentIntensity = 0.66;
  ceilingMaterial.specularIntensity = 0.9;
  ceilingMaterial.maxSimultaneousLights = LIGHTING_LIMITS.maxSimultaneousLights;
  ceiling.material = ceilingMaterial;

  return ceiling;
}

function createHangarWalls(scene: Scene, textures: HangarTextureSet): Mesh[] {
  const halfHeight = HULL_DIMENSIONS.height / 2;
  const thickness = WALL_DIMENSIONS.thickness;
  const footingDepth = WALL_DIMENSIONS.footingDepth ?? 0;
  const wallHeight = HULL_DIMENSIONS.height + footingDepth;
  const centerY = halfHeight - footingDepth / 2;

  return [
    createHangarWall(scene, textures, {
      name: "wall-north",
      size: { width: HULL_DIMENSIONS.width, height: wallHeight, depth: thickness },
      position: new Vector3(0, centerY, -HULL_DIMENSIONS.length / 2),
      inward: new Vector3(0, 0, 1),
    }),
    createHangarWall(scene, textures, {
      name: "wall-south",
      size: { width: HULL_DIMENSIONS.width, height: wallHeight, depth: thickness },
      position: new Vector3(0, centerY, HULL_DIMENSIONS.length / 2),
      inward: new Vector3(0, 0, -1),
    }),
    createHangarWall(scene, textures, {
      name: "wall-east",
      size: { width: HULL_DIMENSIONS.length, height: wallHeight, depth: thickness },
      position: new Vector3(HULL_DIMENSIONS.width / 2, centerY, 0),
      rotationY: Math.PI / 2,
      inward: new Vector3(-1, 0, 0),
    }),
    createHangarWall(scene, textures, {
      name: "wall-west",
      size: { width: HULL_DIMENSIONS.length, height: wallHeight, depth: thickness },
      position: new Vector3(-HULL_DIMENSIONS.width / 2, centerY, 0),
      rotationY: Math.PI / 2,
      inward: new Vector3(1, 0, 0),
    }),
  ];
}

function createHangarWall(
  scene: Scene,
  textures: HangarTextureSet,
  config: {
    name: string;
    size: { width: number; height: number; depth: number };
    position: Vector3;
    inward: Vector3;
    rotationY?: number;
  },
): Mesh {
  const wall = MeshBuilder.CreateBox(
    config.name,
    {
      width: config.size.width,
      height: config.size.height,
      depth: config.size.depth,
    },
    scene,
  );

  wall.position = config.position.clone();
  if (typeof config.rotationY === "number") {
    wall.rotation.y = config.rotationY;
  }
  wall.checkCollisions = true;
  wall.isPickable = true;

  const wallMaterial = new PBRMaterial(`${config.name}-pbr`, scene);
  const footingDepth = WALL_DIMENSIONS.footingDepth ?? 0;
  const visibleHeight = config.size.height - footingDepth;
  const tileU = Math.max(config.size.width, visibleHeight) * 0.9;
  const tileV = visibleHeight * 0.95;
  applyHangarTextures(wallMaterial, textures, { u: tileU, v: tileV });
  wallMaterial.ambientTextureStrength = 0.94;
  wallMaterial.useAmbientInGrayScale = true;
  wallMaterial.metallic = 0.36;
  wallMaterial.roughness = 0.88;
  wallMaterial.microSurface = 0.8;
  wallMaterial.environmentIntensity = 0.7;
  wallMaterial.specularIntensity = 1.0;
  wallMaterial.backFaceCulling = true;
  wallMaterial.twoSidedLighting = false;
  wallMaterial.maxSimultaneousLights = LIGHTING_LIMITS.maxSimultaneousLights;
  wall.material = wallMaterial;

  const inward = config.inward.clone().normalize();
  const up = Vector3.Up();
  const existingMetadata = (wall.metadata as Record<string, unknown>) ?? {};
  wall.metadata = {
    ...existingMetadata,
    type: "ship-wall",
    lampOrientation: {
      forward: inward.asArray(),
      up: up.asArray(),
    },
    textureTiling: { u: tileU, v: tileV },
  };

  return wall;
}

function disposeHangarMaterials(meshes: Mesh[]) {
  meshes.forEach((mesh) => {
    const material = mesh.material;
    if (material instanceof PBRMaterial) {
      disposeHangarMaterial(material);
      material.dispose(false, true);
    }
  });
}

function createStructuralLamps(scene: Scene): BuilderLamp[] {
  const color = new Color3(0.6, 0.78, 1);
  const height = HULL_DIMENSIONS.height - 0.22;
  const bandDepth = 0.22;
  const bandThickness = 0.12;
  const inset = bandDepth / 2 + 0.015;
  const spanX = HULL_DIMENSIONS.width * 0.62;
  const spanZ = HULL_DIMENSIONS.length * 0.62;
  const range = Math.max(HULL_DIMENSIONS.length, HULL_DIMENSIONS.width) * 1.25;

  return [
    createWallBandLamp(scene, {
      name: "structural-light-north",
      span: spanX,
      thickness: bandThickness,
      depth: bandDepth,
      position: new Vector3(0, height, -HULL_DIMENSIONS.length / 2 + inset),
      direction: new Vector3(0, -0.45, 1),
      color,
      range,
    }),
    createWallBandLamp(scene, {
      name: "structural-light-south",
      span: spanX,
      thickness: bandThickness,
      depth: bandDepth,
      position: new Vector3(0, height, HULL_DIMENSIONS.length / 2 - inset),
      direction: new Vector3(0, -0.45, -1),
      color,
      range,
    }),
    createWallBandLamp(scene, {
      name: "structural-light-east",
      span: spanZ,
      thickness: bandThickness,
      depth: bandDepth,
      position: new Vector3(HULL_DIMENSIONS.width / 2 - inset, height, 0),
      rotationY: Math.PI / 2,
      direction: new Vector3(-1, -0.45, 0),
      color,
      range,
    }),
    createWallBandLamp(scene, {
      name: "structural-light-west",
      span: spanZ,
      thickness: bandThickness,
      depth: bandDepth,
      position: new Vector3(-HULL_DIMENSIONS.width / 2 + inset, height, 0),
      rotationY: Math.PI / 2,
      direction: new Vector3(1, -0.45, 0),
      color,
      range,
    }),
  ];
}

function createWallBandLamp(
  scene: Scene,
  config: {
    name: string;
    span: number;
    thickness: number;
    depth: number;
    position: Vector3;
    direction: Vector3;
    color: Color3;
    range: number;
    rotationY?: number;
    angle?: number;
    shadowMapSize?: number;
  },
): BuilderLamp {
  const fixture = MeshBuilder.CreateBox(
    `${config.name}-fixture`,
    {
      width: config.span,
      height: config.thickness,
      depth: config.depth,
    },
    scene,
  );

  fixture.position = config.position.clone();
  if (config.rotationY !== undefined) {
    fixture.rotation.y = config.rotationY;
  }
  fixture.isPickable = true;
  fixture.checkCollisions = false;
  fixture.metadata = {
    type: "builder-lamp",
    key: config.name,
    toolId: "lamp",
    structural: true,
  };

  const fixtureMaterial = new StandardMaterial(`${config.name}-mat`, scene);
  fixtureMaterial.diffuseColor = config.color.scale(0.18);
  fixtureMaterial.specularColor = config.color.scale(0.26);
  fixtureMaterial.emissiveColor = config.color.scale(1.12);
  fixtureMaterial.backFaceCulling = false;
  fixtureMaterial.maxSimultaneousLights = LIGHTING_LIMITS.maxSimultaneousLights;
  fixture.material = fixtureMaterial;

  const forward = Vector3.Normalize(config.direction);
  let right = Vector3.Cross(Vector3.Up(), forward);
  if (right.lengthSquared() < 1e-4) {
    right = new Vector3(1, 0, 0);
  }
  right.normalize();

  const lamp = createRectAreaLamp({
    name: config.name,
    scene,
    fixture,
    position: fixture.position.clone(),
    right,
    up: Vector3.Up(),
    forward,
    areaSize: { width: config.span, height: config.thickness },
    color: config.color,
    range: config.range,
    tilt: 0.4,
    twoSided: false,
    areaIntensity: 24,
    shadowIntensity: 1.6,
    ambientIntensity: 0.42,
    ambientRangeMultiplier: 0.76,
    ambientAttenuation: 0.58,
    shadowAngle: config.angle ?? Math.PI / 2.3,
    shadowMapSize: config.shadowMapSize ?? 1024,
    shadowBias: 0.00022,
    shadowNormalBias: 0.0035,
    forceBackFacesOnly: false,
    shadowMinZ: 0.008,
    areaOffset: config.depth * 0.45,
    enableRsm: true,
    rsmTextureSize: 256,
    rsmNumSamples: 220,
    rsmRadius: 0.24,
    rsmIntensity: 0.26,
    rsmEdgeCorrection: 0.09,
    rsmRotateSample: true,
    rsmNoiseFactor: 90,
  });
  lamp.key = config.name;
  lamp.anchorSurfaceId = config.name;
  lamp.mesh.metadata = {
    ...(lamp.mesh.metadata as Record<string, unknown> | undefined),
    type: "builder-lamp",
    key: config.name,
    toolId: "lamp",
    structural: true,
    surfaceId: config.name,
    local: { ...lamp.local },
  };
  return lamp;
}
</file>

</files>
