This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
releases/
  v0.1.0.md
src/
  assets/
    metalgrid3-bl/
      About these PBR files.txt
      desktop.ini
  fps/
    core/
      hangarTextures.ts
      playerController.ts
      sceneContext.ts
    lighting/
      rectAreaLamp.ts
      shadowNetwork.ts
    placement/
      surfaces/
        floorSurface.ts
        placementSurface.ts
        surfaceRegistry.ts
        types.ts
        wallSurface.ts
      tools/
        deleteTool.ts
        index.ts
        lampTool.ts
        wallTool.ts
      ghosts.ts
      lampBuilder.ts
      placementController.ts
      placementSolver.ts
      placementTypes.ts
      wallBuilder.ts
    state/
      playerModules.ts
      playerPersistence.ts
      playerState.ts
      playerStore.ts
      shipHydrator.ts
      shipPersistence.ts
      shipState.ts
      shipStore.ts
    utils/
      math.ts
    constants.ts
    ShipBuilderCanvas.tsx
    types.ts
  legacy/
    game/
      Game.ts
      world.ts
    hal/
      halLLM.ts
    ui/
      Chat.tsx
      MonacoEditor.tsx
      ScriptsPanel.tsx
    App.tsx
    main.tsx
  App.tsx
  env.d.ts
  main.tsx
.gitignore
AGENTS.md
index.html
MANIFESTO.md
package.json
tsconfig.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/assets/metalgrid3-bl/About these PBR files.txt">
These texture files were created by FreePBR.com and may be used freely in your video games and 3d work at no cost. They may not however be redistributed on other websites or anywhere else other than FreePBR.com. We think that is more than fair. :) We also would greatly appreciate it if some sorrt of credit was given if you do indeed use these textures in a published game. Other than that, keep on creating and have fun. :)
</file>

<file path="src/assets/metalgrid3-bl/desktop.ini">
[.ShellClassInfo]
InfoTip=This folder is shared online.
IconFile=C:\Program Files\Google\Drive\googledrivesync.exe
IconIndex=16
</file>

<file path="src/fps/core/hangarTextures.ts">
import { PBRMaterial, Scene, Texture } from "babylonjs";
import armorAlbedoUrl from "../../assets/armor-plating1-bl/armor-plating1_albedo.png?url";
import armorNormalUrl from "../../assets/armor-plating1-bl/armor-plating1_normal-ogl.png?url";
import armorRoughnessUrl from "../../assets/armor-plating1-bl/armor-plating1_roughness.png?url";
import armorMetallicUrl from "../../assets/armor-plating1-bl/armor-plating1_metallic.png?url";
import armorAoUrl from "../../assets/armor-plating1-bl/armor-plating1_ao.png?url";
import metalgridAlbedoUrl from "../../assets/metalgrid3-bl/metalgrid3_basecolor.png?url";
import metalgridNormalUrl from "../../assets/metalgrid3-bl/metalgrid3_normal-ogl.png?url";
import metalgridRoughnessUrl from "../../assets/metalgrid3-bl/metalgrid3_roughness.png?url";
import metalgridMetallicUrl from "../../assets/metalgrid3-bl/metalgrid3_metallic.png?url";
import metalgridAoUrl from "../../assets/metalgrid3-bl/metalgrid3_AO.png?url";

export interface HangarTextureSet {
  albedo: Texture;
  normal: Texture;
  roughness: Texture;
  metallic: Texture;
  ao: Texture;
}

type HangarTextureKey = "armor" | "metal";

interface TextureDefinition {
  albedo: string;
  normal: string;
  roughness: string;
  metallic: string;
  ao: string;
}

const TEXTURE_DEFINITIONS: Record<HangarTextureKey, TextureDefinition> = {
  armor: {
    albedo: armorAlbedoUrl,
    normal: armorNormalUrl,
    roughness: armorRoughnessUrl,
    metallic: armorMetallicUrl,
    ao: armorAoUrl,
  },
  metal: {
    albedo: metalgridAlbedoUrl,
    normal: metalgridNormalUrl,
    roughness: metalgridRoughnessUrl,
    metallic: metalgridMetallicUrl,
    ao: metalgridAoUrl,
  },
};

const textureCache = new WeakMap<Scene, Map<HangarTextureKey, HangarTextureSet>>();

function createTexture(scene: Scene, url: string): Texture {
  return new Texture(url, scene, false, true, Texture.TRILINEAR_SAMPLINGMODE);
}

function createTextureSet(scene: Scene, key: HangarTextureKey): HangarTextureSet {
  const definition = TEXTURE_DEFINITIONS[key];
  const albedo = createTexture(scene, definition.albedo);
  const normal = createTexture(scene, definition.normal);
  const roughness = createTexture(scene, definition.roughness);
  const metallic = createTexture(scene, definition.metallic);
  const ao = createTexture(scene, definition.ao);

  [albedo, normal, roughness, metallic, ao].forEach((texture) => {
    texture.wrapU = Texture.WRAP_ADDRESSMODE;
    texture.wrapV = Texture.WRAP_ADDRESSMODE;
  });
  normal.invertZ = true;
  normal.gammaSpace = false;

  return { albedo, normal, roughness, metallic, ao };
}

export function getHangarTextureSet(scene: Scene, key: HangarTextureKey): HangarTextureSet {
  let map = textureCache.get(scene);
  if (!map) {
    map = new Map<HangarTextureKey, HangarTextureSet>();
    textureCache.set(scene, map);
  }
  let set = map.get(key);
  if (!set) {
    set = createTextureSet(scene, key);
    map.set(key, set);
  }
  return set;
}

export function applyHangarTextures(
  material: PBRMaterial,
  textures: HangarTextureSet,
  tiling: { u: number; v: number },
) {
  disposeHangarMaterial(material);

  const albedo = textures.albedo.clone();
  const normal = textures.normal.clone();
  const metallic = textures.metallic.clone();
  const ao = textures.ao.clone();

  [albedo, normal, metallic, ao].forEach((texture) => {
    texture.uScale = tiling.u;
    texture.vScale = tiling.v;
    texture.wrapU = Texture.WRAP_ADDRESSMODE;
    texture.wrapV = Texture.WRAP_ADDRESSMODE;
  });

  material.albedoTexture = albedo;
  material.bumpTexture = normal;
  material.metallicTexture = metallic;
  material.ambientTexture = ao;

  const metadata = (material.metadata as { hangarTextureClones?: Texture[] } | undefined) ?? {};
  metadata.hangarTextureClones = [albedo, normal, metallic, ao];
  material.metadata = metadata;
}

export function disposeHangarMaterial(material: PBRMaterial) {
  const metadata = (material.metadata as { hangarTextureClones?: Texture[] } | undefined) ?? {};
  metadata.hangarTextureClones?.forEach((texture) => {
    texture.dispose();
  });
  if (metadata.hangarTextureClones) {
    metadata.hangarTextureClones = [];
  }
  material.metadata = metadata;
}

export function disposeHangarTextureCache(scene: Scene) {
  const map = textureCache.get(scene);
  if (!map) {
    return;
  }
  map.forEach((set) => {
    set.albedo.dispose();
    set.normal.dispose();
    set.roughness.dispose();
    set.metallic.dispose();
    set.ao.dispose();
  });
  map.clear();
  textureCache.delete(scene);
}
</file>

<file path="src/fps/core/playerController.ts">
import { KeyboardEventTypes, Quaternion, UniversalCamera, Vector3, type Scene } from "babylonjs";
import { CAMERA_SETTINGS, INPUT_KEYS } from "../constants";
import type { PlayerStore } from "../state/playerStore";
import type {
  PlayerState,
  PlayerTransformState,
  QuaternionSerialized,
  Vector3Serialized,
} from "../state/playerState";
import { serializeQuaternion, serializeVector3 } from "../state/playerState";

const KEYBOARD_MOVE_MAP: Record<string, { axis: "x" | "z"; direction: number }> = {
  KeyW: { axis: "z", direction: 1 },
  ArrowUp: { axis: "z", direction: 1 },
  KeyS: { axis: "z", direction: -1 },
  ArrowDown: { axis: "z", direction: -1 },
  KeyA: { axis: "x", direction: -1 },
  ArrowLeft: { axis: "x", direction: -1 },
  KeyD: { axis: "x", direction: 1 },
  ArrowRight: { axis: "x", direction: 1 },
};

const CROUCH_KEYS = new Set(["ControlLeft", "ControlRight"]);
const JUMP_KEYS = new Set(["Space"]);

interface PlayerControllerOptions {
  scene: Scene;
  canvas: HTMLCanvasElement;
  store: PlayerStore;
}

export interface PlayerController {
  camera: UniversalCamera;
  dispose(): void;
  teleport(position: Vector3Serialized, orientation?: QuaternionSerialized): void;
  setCutsceneLock(locked: boolean): void;
}

export function createPlayerController(options: PlayerControllerOptions): PlayerController {
  const { scene, canvas, store } = options;
  const engine = scene.getEngine();
  const initialState = store.getSnapshot();

  const camera = new UniversalCamera(
    "fpCam",
    new Vector3(
      initialState.transform.position.x,
      initialState.transform.position.y || CAMERA_SETTINGS.eyeLevel,
      initialState.transform.position.z,
    ),
    scene,
  );
  camera.minZ = CAMERA_SETTINGS.minZ;
  camera.maxZ = CAMERA_SETTINGS.maxZ;
  camera.speed = CAMERA_SETTINGS.speed;
  camera.angularSensibility = CAMERA_SETTINGS.angularSensibility;
  camera.inertia = CAMERA_SETTINGS.inertia;
  camera.applyGravity = true;
  camera.checkCollisions = true;
  camera.ellipsoid = new Vector3(
    CAMERA_SETTINGS.ellipsoid.x,
    CAMERA_SETTINGS.ellipsoid.y,
    CAMERA_SETTINGS.ellipsoid.z,
  );
  camera.ellipsoidOffset = new Vector3(
    CAMERA_SETTINGS.ellipsoidOffset.x,
    CAMERA_SETTINGS.ellipsoidOffset.y,
    CAMERA_SETTINGS.ellipsoidOffset.z,
  );
  camera.keysUp.push(INPUT_KEYS.move.forward);
  camera.keysLeft.push(INPUT_KEYS.move.left);
  camera.keysDown.push(INPUT_KEYS.move.backward);
  camera.keysRight.push(INPUT_KEYS.move.right);

  const initialQuaternion = new Quaternion(
    initialState.transform.orientation.x,
    initialState.transform.orientation.y,
    initialState.transform.orientation.z,
    initialState.transform.orientation.w,
  );
  applyQuaternionToCamera(camera, initialQuaternion);

  let controlsAttached = false;
  const attachControls = () => {
    if (controlsAttached) {
      return;
    }
    camera.attachControl(canvas, true);
    controlsAttached = true;
  };
  const detachControls = () => {
    if (!controlsAttached) {
      return;
    }
    camera.detachControl();
    controlsAttached = false;
    if (document.pointerLockElement === canvas) {
      try {
        document.exitPointerLock();
      } catch {
        // ignore pointer lock failures
      }
    }
  };

  if (!initialState.input.cameraLocked && !initialState.input.movementLocked) {
    attachControls();
  }

  const actions = store.getActions();
  let isPushingFromCamera = false;
  let lastTransformSignature = transformSignature(initialState.transform);
  let lastFramePosition = camera.position.clone();

  const pointerLockListener = () => {
    const pointerLocked = document.pointerLockElement === canvas;
    actions.patchInput({ pointerLocked });
  };
  document.addEventListener("pointerlockchange", pointerLockListener);

  const pressedKeys = new Set<string>();
  let lastMovementIntent = initialState.movementIntent;

  const updateMovementIntent = () => {
    const move = { x: 0, z: 0 };
    pressedKeys.forEach((code) => {
      const mapping = KEYBOARD_MOVE_MAP[code];
      if (!mapping) {
        return;
      }
      move[mapping.axis] += mapping.direction;
    });

    const length = Math.hypot(move.x, move.z);
    if (length > 1e-3) {
      move.x /= Math.max(1, length);
      move.z /= Math.max(1, length);
    } else {
      move.x = 0;
      move.z = 0;
    }

    const sprint = INPUT_KEYS.sprint.some((code) => pressedKeys.has(code));
    const jump = Array.from(JUMP_KEYS).some((code) => pressedKeys.has(code));
    const crouch = Array.from(CROUCH_KEYS).some((code) => pressedKeys.has(code));

    if (
      almostEqual(move.x, lastMovementIntent.move.x) &&
      almostEqual(move.z, lastMovementIntent.move.z) &&
      sprint === lastMovementIntent.sprint &&
      jump === lastMovementIntent.jump &&
      crouch === lastMovementIntent.crouch
    ) {
      return;
    }

    const next = {
      move,
      sprint,
      jump,
      crouch,
    };
    actions.setMovementIntent({
      move,
      sprint,
      jump,
      crouch,
    });
    lastMovementIntent = next;
  };

  const keyboardObserver = scene.onKeyboardObservable.add((info) => {
    const event = info.event;
    if (info.type === KeyboardEventTypes.KEYDOWN) {
      pressedKeys.add(event.code);
    } else if (info.type === KeyboardEventTypes.KEYUP) {
      pressedKeys.delete(event.code);
    }
    updateMovementIntent();
  });

  const applyInputState = (state: PlayerState) => {
    const { cameraLocked, movementLocked } = state.input;
    if (cameraLocked || movementLocked) {
      detachControls();
    } else {
      attachControls();
    }
  };

  const subscription = store.subscribe((state) => {
    applyInputState(state);
    lastMovementIntent = state.movementIntent;

    const signature = transformSignature(state.transform);
    if (isPushingFromCamera) {
      lastTransformSignature = signature;
      return;
    }
    if (signature === lastTransformSignature) {
      return;
    }
    lastTransformSignature = signature;
    applyTransformToCamera(camera, state.transform);
    lastFramePosition = camera.position.clone();
  });

  const transformObserver = scene.onBeforeRenderObservable.add(() => {
    const deltaSeconds = engine.getDeltaTime() / 1000;
    const currentPosition = camera.position;
    const velocity = deltaSeconds > 1e-4 ? currentPosition.subtract(lastFramePosition).scale(1 / deltaSeconds) : Vector3.Zero();
    lastFramePosition = currentPosition.clone();

    if (Math.abs(camera.rotation.z) > 1e-4) {
      camera.rotation.z = 0;
    }
    const quaternion = Quaternion.RotationYawPitchRoll(
      camera.rotation.y,
      camera.rotation.x,
      0,
    );

    const nextTransform: PlayerTransformState = {
      position: serializeVector3(currentPosition.x, currentPosition.y, currentPosition.z),
      orientation: serializeQuaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w),
      velocity: serializeVector3(velocity.x, velocity.y, velocity.z),
    };

    const signature = transformSignature(nextTransform);
    if (signature === lastTransformSignature) {
      return;
    }
    isPushingFromCamera = true;
    actions.setTransform(nextTransform);
    isPushingFromCamera = false;
    lastTransformSignature = signature;
  });

  const teleport = (position: Vector3Serialized, orientation?: QuaternionSerialized) => {
    const quaternion = orientation
      ? new Quaternion(orientation.x, orientation.y, orientation.z, orientation.w)
      : Quaternion.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, camera.rotation.z);

    applyTransformToCamera(camera, {
      position,
      orientation: orientation
        ? orientation
        : {
            x: quaternion.x,
            y: quaternion.y,
            z: quaternion.z,
            w: quaternion.w,
          },
      velocity: serializeVector3(0, 0, 0),
    });
    lastFramePosition = camera.position.clone();
    const sanitized = Quaternion.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, 0);
    const transform: PlayerTransformState = {
      position: serializeVector3(position.x, position.y, position.z),
      orientation: serializeQuaternion(sanitized.x, sanitized.y, sanitized.z, sanitized.w),
      velocity: serializeVector3(0, 0, 0),
    };
    isPushingFromCamera = true;
    actions.setTransform(transform);
    isPushingFromCamera = false;
    lastTransformSignature = transformSignature(transform);
  };

  const setCutsceneLock = (locked: boolean) => {
    actions.patchInput({
      movementLocked: locked,
      cameraLocked: locked,
    });
    if (locked) {
      detachControls();
    } else {
      attachControls();
    }
  };

  const dispose = () => {
    document.removeEventListener("pointerlockchange", pointerLockListener);
    scene.onBeforeRenderObservable.remove(transformObserver);
    scene.onKeyboardObservable.remove(keyboardObserver);
    subscription();
    if (controlsAttached) {
      detachControls();
    }
    camera.dispose();
  };

  return {
    camera,
    dispose,
    teleport,
    setCutsceneLock,
  };
}

function transformSignature(transform: PlayerTransformState): string {
  return [
    transform.position.x,
    transform.position.y,
    transform.position.z,
    transform.orientation.x,
    transform.orientation.y,
    transform.orientation.z,
    transform.orientation.w,
    transform.velocity.x,
    transform.velocity.y,
    transform.velocity.z,
  ].join("|");
}

function applyTransformToCamera(camera: UniversalCamera, transform: PlayerTransformState) {
  camera.position.set(transform.position.x, transform.position.y, transform.position.z);
  const quaternion = new Quaternion(
    transform.orientation.x,
    transform.orientation.y,
    transform.orientation.z,
    transform.orientation.w,
  );
  applyQuaternionToCamera(camera, quaternion);
}

function applyQuaternionToCamera(camera: UniversalCamera, quaternion: Quaternion) {
  const euler = quaternion.toEulerAngles();
  camera.rotation.set(euler.x, euler.y, 0);
}

function almostEqual(a: number, b: number) {
  return Math.abs(a - b) <= 1e-5;
}
</file>

<file path="src/fps/placement/surfaces/floorSurface.ts">
import { Matrix, Vector3 } from "babylonjs";
import type { AbstractMesh, PickingInfo } from "babylonjs";
import type { PlacementSurface } from "./placementSurface";
import type {
  FloorMountConstraints,
  PlacementFrame,
  PlacementMode,
  SurfaceSampleRequest,
} from "./types";
import { clamp } from "../../utils/math";

export interface FloorSurfaceOptions {
  id: string;
  mesh: AbstractMesh;
  up?: Vector3;
  forward?: Vector3;
}

export class FloorSurface implements PlacementSurface {
  public readonly id: string;
  public readonly mesh: AbstractMesh;
  private readonly up: Vector3;
  private readonly forward: Vector3;

  constructor(options: FloorSurfaceOptions) {
    this.id = options.id;
    this.mesh = options.mesh;
    this.up = (options.up ?? Vector3.Up()).normalize();
    const forward = options.forward ?? new Vector3(0, 0, 1);
    this.forward = forward.normalize();
  }

  supports(mode: PlacementMode) {
    return mode === "floor-mount";
  }

  sample(request: SurfaceSampleRequest): PlacementFrame | null {
    if (request.mode !== "floor-mount") {
      return null;
    }

    const constraints = request.constraints as FloorMountConstraints;
    if (constraints.type !== "floor-mount") {
      return null;
    }

    return this.sampleFloorMount(request.pick, constraints);
  }

  dispose() {
    // Nothing to release for now.
  }

  private sampleFloorMount(pick: PickingInfo, constraints: FloorMountConstraints): PlacementFrame | null {
    if (!pick.hit || pick.pickedMesh?.uniqueId !== this.mesh.uniqueId || !pick.pickedPoint) {
      return null;
    }

    const mesh = this.mesh;
    const worldMatrix = mesh.getWorldMatrix();
    const inverse = Matrix.Identity();
    worldMatrix.invertToRef(inverse);

    const localPoint = Vector3.TransformCoordinates(pick.pickedPoint, inverse);
    const bounds = mesh.getBoundingInfo().boundingBox.extendSize;

    const halfWidth = bounds.x;
    const halfDepth = bounds.z;

    const snap = constraints.grid > 0 ? constraints.grid : 0;
    const maxX = Math.max(halfWidth - constraints.itemSize.width / 2, 0);
    const maxZ = Math.max(halfDepth - constraints.itemSize.depth / 2, 0);

    const snappedX = snap
      ? clamp(Math.round(localPoint.x / snap) * snap, -maxX, maxX)
      : clamp(localPoint.x, -maxX, maxX);
    const snappedZ = snap
      ? clamp(Math.round(localPoint.z / snap) * snap, -maxZ, maxZ)
      : clamp(localPoint.z, -maxZ, maxZ);

    const baseLocal = new Vector3(snappedX, 0, snappedZ);
    const baseWorld = Vector3.TransformCoordinates(baseLocal, worldMatrix);

    const up = this.up.clone();
    const forward = this.forward.clone();
    const right = Vector3.Cross(up, forward).normalize();
    const heightOffset = constraints.heightOffset + constraints.itemSize.height / 2;
    const position = baseWorld.add(up.scale(heightOffset));

    return {
      surfaceId: this.id,
      mesh,
      mode: "floor-mount",
      position,
      forward,
      up,
      right,
      local: {
        x: Number(snappedX.toFixed(3)),
        y: 0,
        z: Number(snappedZ.toFixed(3)),
      },
    };
  }
}
</file>

<file path="src/fps/placement/surfaces/placementSurface.ts">
import type { AbstractMesh } from "babylonjs";
import type { PlacementFrame, PlacementMode, SurfaceSampleRequest } from "./types";

export interface PlacementSurface {
  readonly id: string;
  readonly mesh: AbstractMesh;
  supports(mode: PlacementMode): boolean;
  sample(request: SurfaceSampleRequest): PlacementFrame | null;
  dispose(): void;
}
</file>

<file path="src/fps/placement/surfaces/surfaceRegistry.ts">
import type { AbstractMesh, PickingInfo } from "babylonjs";
import type { PlacementSurface } from "./placementSurface";

export interface SurfaceRegistry {
  register(surface: PlacementSurface): void;
  unregister(mesh: AbstractMesh): void;
  resolveFromMesh(mesh?: AbstractMesh | null): PlacementSurface | null;
  resolveFromPick(pick?: PickingInfo | null): PlacementSurface | null;
  list(): PlacementSurface[];
  dispose(): void;
}

export function createSurfaceRegistry(): SurfaceRegistry {
  const surfacesById = new Map<string, PlacementSurface>();
  const surfacesByMesh = new Map<number, PlacementSurface>();

  const register = (surface: PlacementSurface) => {
    surfacesById.set(surface.id, surface);
    surfacesByMesh.set(surface.mesh.uniqueId, surface);
  };

  const unregister = (mesh: AbstractMesh) => {
    const surface = surfacesByMesh.get(mesh.uniqueId);
    if (!surface) {
      return;
    }
    surfacesByMesh.delete(mesh.uniqueId);
    surfacesById.delete(surface.id);
    surface.dispose();
  };

  return {
    register,
    unregister,
    resolveFromMesh: (mesh?: AbstractMesh | null) => {
      if (!mesh) {
        return null;
      }
      return surfacesByMesh.get(mesh.uniqueId) ?? null;
    },
    resolveFromPick: (pick?: PickingInfo | null) => {
      if (!pick) {
        return null;
      }
      return surfacesByMesh.get(pick.pickedMesh?.uniqueId ?? -1) ?? null;
    },
    list: () => Array.from(surfacesById.values()),
    dispose: () => {
      surfacesByMesh.forEach((surface) => {
        surface.dispose();
      });
      surfacesByMesh.clear();
      surfacesById.clear();
    },
  };
}
</file>

<file path="src/fps/placement/surfaces/types.ts">
import type { AbstractMesh, PickingInfo, Vector3 } from "babylonjs";

export type PlacementMode = "wall-mount" | "floor-mount" | "ceiling-mount";

export interface PlacementFrame {
  surfaceId: string;
  mesh: AbstractMesh;
  mode: PlacementMode;
  position: Vector3;
  forward: Vector3;
  up: Vector3;
  right: Vector3;
  local: {
    x: number;
    y: number;
    z: number;
  };
}

export interface WallMountConstraints {
  type: "wall-mount";
  grid: number;
  itemSize: {
    width: number;
    height: number;
    depth: number;
  };
  offset: number;
  boundsPadding: {
    horizontal: number;
    vertical: number;
  };
}

export interface FloorMountConstraints {
  type: "floor-mount";
  grid: number;
  itemSize: {
    width: number;
    depth: number;
    height: number;
  };
  heightOffset: number;
}

export type PlacementConstraints = WallMountConstraints | FloorMountConstraints;

export interface SurfaceSampleRequest {
  mode: PlacementMode;
  constraints: PlacementConstraints;
  pick: PickingInfo;
}
</file>

<file path="src/fps/placement/surfaces/wallSurface.ts">
import { Matrix, Vector3 } from "babylonjs";
import type { AbstractMesh, PickingInfo } from "babylonjs";
import type { PlacementSurface } from "./placementSurface";
import type {
  PlacementFrame,
  PlacementMode,
  SurfaceSampleRequest,
  WallMountConstraints,
} from "./types";
import { clamp } from "../../utils/math";

export interface WallSurfaceOptions {
  id: string;
  mesh: AbstractMesh;
  inward: Vector3;
  up?: Vector3;
}

export class WallSurface implements PlacementSurface {
  public readonly id: string;
  public readonly mesh: AbstractMesh;
  private readonly inward: Vector3;
  private readonly up: Vector3;

  constructor(options: WallSurfaceOptions) {
    this.id = options.id;
    this.mesh = options.mesh;
    this.inward = options.inward.normalize();
    this.up = (options.up ?? Vector3.Up()).normalize();
  }

  supports(mode: PlacementMode) {
    return mode === "wall-mount";
  }

  sample(request: SurfaceSampleRequest): PlacementFrame | null {
    if (request.mode !== "wall-mount") {
      return null;
    }

    const constraints = request.constraints as WallMountConstraints;
    if (constraints.type !== "wall-mount") {
      return null;
    }

    return this.sampleWallMount(request.pick, constraints);
  }

  dispose() {
    // Nothing to release for now.
  }

  private sampleWallMount(pick: PickingInfo, constraints: WallMountConstraints): PlacementFrame | null {
    const { mesh } = this;
    if (!pick.hit || pick.pickedMesh?.uniqueId !== mesh.uniqueId || !pick.pickedPoint) {
      return null;
    }

    const worldMatrix = mesh.getWorldMatrix();
    const inverse = Matrix.Identity();
    worldMatrix.invertToRef(inverse);

    const localPoint = Vector3.TransformCoordinates(pick.pickedPoint, inverse);
    const bounds = mesh.getBoundingInfo().boundingBox.extendSize;

    const halfWidth = bounds.x;
    const halfHeight = bounds.y;
    const paddingX = constraints.boundsPadding.horizontal;
    const paddingY = constraints.boundsPadding.vertical;

    const allowedHalfWidth = Math.max(halfWidth - (constraints.itemSize.width / 2 + paddingX), 0);
    const allowedHalfHeight = Math.max(halfHeight - (constraints.itemSize.height / 2 + paddingY), 0);

    const snap = constraints.grid > 0 ? constraints.grid : 0;
    const snappedX = snap
      ? clamp(Math.round(localPoint.x / snap) * snap, -allowedHalfWidth, allowedHalfWidth)
      : clamp(localPoint.x, -allowedHalfWidth, allowedHalfWidth);
    const snappedY = snap
      ? clamp(Math.round(localPoint.y / snap) * snap, -allowedHalfHeight, allowedHalfHeight)
      : clamp(localPoint.y, -allowedHalfHeight, allowedHalfHeight);

    const baseLocal = new Vector3(snappedX, snappedY, 0);
    const baseWorld = Vector3.TransformCoordinates(baseLocal, worldMatrix);

    const forward = this.inward.clone();
    if (pick.ray && Vector3.Dot(forward, pick.ray.direction) > 0) {
      forward.scaleInPlace(-1);
    }

    const right = Vector3.Cross(this.up, forward).normalize();
    const up = Vector3.Cross(forward, right).normalize();

    const depthOffset = constraints.itemSize.depth / 2 + constraints.offset;
    const position = baseWorld.add(forward.scale(depthOffset));

    return {
      surfaceId: this.id,
      mesh,
      mode: "wall-mount",
      position,
      forward,
      up,
      right,
      local: {
        x: Number(snappedX.toFixed(3)),
        y: Number(snappedY.toFixed(3)),
        z: 0,
      },
    };
  }
}
</file>

<file path="src/fps/placement/tools/deleteTool.ts">
import { PointerEventTypes } from "babylonjs";
import { INPUT_KEYS } from "../../constants";
import type { PlacementToolDefinition, ToolRuntimeContext } from "../placementTypes";

const TOOL_ID = "delete";

const pickRemovable = (context: ToolRuntimeContext) =>
  context.scene.pick(
    context.scene.pointerX,
    context.scene.pointerY,
    (mesh) => {
      const metadata = mesh?.metadata as { toolId?: unknown } | undefined;
      return typeof metadata?.toolId === "string";
    },
  );

export const deleteToolDefinition: PlacementToolDefinition = {
  id: TOOL_ID,
  label: "Remover",
  icon: "✖",
  hotkey: INPUT_KEYS.deleteMode,
  create: (context: ToolRuntimeContext) => {
    const clear = () => {
      context.highlight(null);
      context.ghost.hide();
    };

    return {
      id: TOOL_ID,
      onActivate: () => {
        clear();
      },
      onDeactivate: () => {
        clear();
      },
      onPointerLockChange: (isLocked: boolean) => {
        if (!isLocked) {
          clear();
        }
      },
      onPointerMove: (pointerInfo) => {
        if (pointerInfo.type !== PointerEventTypes.POINTERMOVE) {
          return;
        }

        const pick = pickRemovable(context);
        if (!context.withinRange(pick?.pickedPoint)) {
          clear();
          return;
        }

        const mesh = pick?.pickedMesh;
        if (!mesh) {
          context.highlight(null);
          return;
        }

        context.highlight(mesh);
        context.ghost.hide();
      },
      onPointerDown: (pointerInfo) => {
        if (pointerInfo.type !== PointerEventTypes.POINTERDOWN) {
          return;
        }
        if (pointerInfo.event.button !== 0) {
          return;
        }

        const pick = pickRemovable(context);
        if (!context.withinRange(pick?.pickedPoint)) {
          return;
        }

        if (context.removeMesh(pick?.pickedMesh ?? null)) {
          context.highlight(null);
        }
      },
      dispose: () => {
        clear();
      },
    };
  },
};
</file>

<file path="src/fps/placement/tools/index.ts">
import type { PlacementToolDefinition } from "../placementTypes";
import { deleteToolDefinition } from "./deleteTool";
import { lampToolDefinition } from "./lampTool";
import { wallToolDefinition } from "./wallTool";

export const TOOL_DEFINITIONS: PlacementToolDefinition[] = [
  wallToolDefinition,
  lampToolDefinition,
  deleteToolDefinition,
];

export const TOOL_DEFINITION_BY_ID = new Map<string, PlacementToolDefinition>(
  TOOL_DEFINITIONS.map((definition) => [definition.id, definition]),
);
</file>

<file path="src/fps/placement/placementSolver.ts">
import type { PickingInfo } from "babylonjs";
import type { SurfaceRegistry } from "./surfaces/surfaceRegistry";
import type {
  PlacementConstraints,
  PlacementFrame,
  PlacementMode,
} from "./surfaces/types";

export interface PlacementModeEntry<C extends PlacementConstraints = PlacementConstraints> {
  mode: PlacementMode;
  constraints: C;
}

export interface PlacementProfile {
  modes: PlacementModeEntry[];
}

export interface PlacementSolver {
  solve(profile: PlacementProfile, pick: PickingInfo | null): PlacementFrame | null;
}

export function createPlacementSolver(surfaceRegistry: SurfaceRegistry): PlacementSolver {
  return {
    solve: (profile: PlacementProfile, pick: PickingInfo | null) => {
      if (!pick) {
        return null;
      }
      const surface = surfaceRegistry.resolveFromPick(pick);
      if (!surface) {
        return null;
      }

      for (const entry of profile.modes) {
        if (!surface.supports(entry.mode)) {
          continue;
        }
        const frame = surface.sample({
          mode: entry.mode,
          constraints: entry.constraints,
          pick,
        });
        if (frame) {
          return frame;
        }
      }

      return null;
    },
  };
}
</file>

<file path="src/fps/state/playerModules.ts">
import type { PlayerStore } from "./playerStore";
import type { PlayerModuleDefinition } from "./playerStore";

interface HealthModuleState {
  current: number;
  max: number;
  [key: string]: unknown;
}

interface EnergyModuleState {
  current: number;
  max: number;
  regenPerSecond: number;
  [key: string]: unknown;
}

interface HungerModuleState {
  value: number;
  threshold: number;
  [key: string]: unknown;
}

interface InventorySlot {
  id: string;
  quantity: number;
  [key: string]: unknown;
}

interface InventoryModuleState {
  capacity: number;
  slots: InventorySlot[];
  [key: string]: unknown;
}

const healthModule: PlayerModuleDefinition<HealthModuleState> = {
  id: "vitals.health",
  version: 1,
  createInitialState: () => ({
    current: 100,
    max: 100,
  }),
  onRegister: (context) => {
    context.emit({ type: "player.module.ready", payload: { moduleId: "vitals.health" } });
  },
};

const energyModule: PlayerModuleDefinition<EnergyModuleState> = {
  id: "vitals.energy",
  version: 1,
  createInitialState: () => ({
    current: 100,
    max: 100,
    regenPerSecond: 2,
  }),
  onRegister: (context) => {
    context.emit({ type: "player.module.ready", payload: { moduleId: "vitals.energy" } });
  },
};

const hungerModule: PlayerModuleDefinition<HungerModuleState> = {
  id: "vitals.hunger",
  version: 1,
  createInitialState: () => ({
    value: 0,
    threshold: 100,
  }),
  onRegister: (context) => {
    context.emit({ type: "player.module.ready", payload: { moduleId: "vitals.hunger" } });
  },
};

const inventoryModule: PlayerModuleDefinition<InventoryModuleState> = {
  id: "inventory.core",
  version: 1,
  createInitialState: () => ({
    capacity: 24,
    slots: [],
  }),
  onRegister: (context) => {
    context.emit({ type: "player.module.ready", payload: { moduleId: "inventory.core" } });
  },
};

export function registerBaselinePlayerModules(store: PlayerStore) {
  const actions = store.getActions();
  actions.registerModule(healthModule);
  actions.registerModule(energyModule);
  actions.registerModule(hungerModule);
  actions.registerModule(inventoryModule);
}
</file>

<file path="src/fps/state/playerPersistence.ts">
import type { PlayerStore } from "./playerStore";
import type { PlayerState } from "./playerState";
import { PLAYER_STATE_VERSION } from "./playerState";
import { createEmptyPlayerState } from "./playerState";

const DEFAULT_STORAGE_KEY = "starwatch.player-state";
const DEFAULT_DEBOUNCE_MS = 250;

export function loadPlayerState(storageKey = DEFAULT_STORAGE_KEY): PlayerState | null {
  if (typeof window === "undefined") {
    return null;
  }

  try {
    const raw = window.localStorage.getItem(storageKey);
    if (!raw) {
      return null;
    }
    const parsed = JSON.parse(raw) as PlayerState | undefined;
    if (!parsed || typeof parsed.version !== "number") {
      return null;
    }
    if (parsed.version !== PLAYER_STATE_VERSION) {
      return null;
    }
    return normalizePlayerState(parsed);
  } catch (error) {
    console.warn("[PlayerPersistence] Failed to load player state:", error);
    return null;
  }
}

export function savePlayerState(state: PlayerState, storageKey = DEFAULT_STORAGE_KEY) {
  if (typeof window === "undefined") {
    return;
  }
  try {
    window.localStorage.setItem(storageKey, JSON.stringify(state));
  } catch (error) {
    console.warn("[PlayerPersistence] Failed to save player state:", error);
  }
}

export interface PlayerPersistenceController {
  dispose(): void;
  flush(): void;
}

export function createPlayerPersistence(
  store: PlayerStore,
  options?: {
    storageKey?: string;
    debounceMs?: number;
  },
): PlayerPersistenceController {
  const storageKey = options?.storageKey ?? DEFAULT_STORAGE_KEY;
  const debounceMs = options?.debounceMs ?? DEFAULT_DEBOUNCE_MS;

  let latestState: PlayerState | null = null;
  let timeoutHandle: number | null = null;
  let disposed = false;
  let skipNext = true;

  const scheduleSave = () => {
    if (timeoutHandle !== null) {
      window.clearTimeout(timeoutHandle);
    }
    timeoutHandle = window.setTimeout(() => {
      timeoutHandle = null;
      if (!latestState) {
        return;
      }
      savePlayerState(latestState, storageKey);
    }, debounceMs);
  };

  const unsubscribe = store.subscribe((state) => {
    latestState = state;
    if (skipNext) {
      skipNext = false;
      return;
    }
    if (!disposed) {
      scheduleSave();
    }
  });

  return {
    dispose: () => {
      disposed = true;
      unsubscribe();
      if (timeoutHandle !== null) {
        window.clearTimeout(timeoutHandle);
        timeoutHandle = null;
      }
    },
    flush: () => {
      if (!latestState) {
        return;
      }
      if (timeoutHandle !== null) {
        window.clearTimeout(timeoutHandle);
        timeoutHandle = null;
      }
      savePlayerState(latestState, storageKey);
    },
  };
}

function normalizePlayerState(state: PlayerState): PlayerState {
  const snapshot = createEmptyPlayerState();
  snapshot.transform = {
    position: { ...state.transform.position },
    orientation: { ...state.transform.orientation },
    velocity: { ...state.transform.velocity },
  };
  snapshot.movementIntent = {
    move: { ...state.movementIntent.move },
    sprint: state.movementIntent.sprint,
    jump: state.movementIntent.jump,
    crouch: state.movementIntent.crouch,
  };
  snapshot.input = {
    pointerLocked: state.input.pointerLocked,
    movementLocked: state.input.movementLocked,
    cameraLocked: state.input.cameraLocked,
  };
  snapshot.modules = {};
  Object.values(state.modules ?? {}).forEach((module) => {
    if (!module) {
      return;
    }
    snapshot.modules[module.id] = {
      id: module.id,
      version: module.version,
      state: { ...module.state },
    };
  });
  return snapshot;
}
</file>

<file path="src/fps/state/playerState.ts">
export interface Vector3Serialized {
  x: number;
  y: number;
  z: number;
}

export interface QuaternionSerialized {
  x: number;
  y: number;
  z: number;
  w: number;
}

export interface PlayerTransformState {
  position: Vector3Serialized;
  orientation: QuaternionSerialized;
  velocity: Vector3Serialized;
}

export interface PlayerMovementIntent {
  move: {
    x: number;
    z: number;
  };
  sprint: boolean;
  jump: boolean;
  crouch: boolean;
}

export interface PlayerInputState {
  pointerLocked: boolean;
  movementLocked: boolean;
  cameraLocked: boolean;
}

export interface PlayerModuleSnapshot<TState = Record<string, unknown>> {
  id: string;
  version: number;
  state: TState;
}

export interface PlayerState {
  version: number;
  transform: PlayerTransformState;
  movementIntent: PlayerMovementIntent;
  input: PlayerInputState;
  modules: Record<string, PlayerModuleSnapshot>;
}

export const PLAYER_STATE_VERSION = 1;

export function createEmptyPlayerState(): PlayerState {
  return {
    version: PLAYER_STATE_VERSION,
    transform: {
      position: serializeVector3(0, 0, 0),
      orientation: serializeQuaternion(0, 0, 0, 1),
      velocity: serializeVector3(0, 0, 0),
    },
    movementIntent: {
      move: { x: 0, z: 0 },
      sprint: false,
      jump: false,
      crouch: false,
    },
    input: {
      pointerLocked: false,
      movementLocked: false,
      cameraLocked: false,
    },
    modules: {},
  };
}

export function serializeVector3(x: number, y: number, z: number): Vector3Serialized {
  return {
    x: round(x),
    y: round(y),
    z: round(z),
  };
}

export function serializeQuaternion(
  x: number,
  y: number,
  z: number,
  w: number,
): QuaternionSerialized {
  return {
    x: round(x),
    y: round(y),
    z: round(z),
    w: round(w),
  };
}

function round(value: number) {
  return Number(value.toFixed(5));
}
</file>

<file path="src/fps/state/playerStore.ts">
import {
  createEmptyPlayerState,
  PLAYER_STATE_VERSION,
  type PlayerInputState,
  type PlayerMovementIntent,
  type PlayerModuleSnapshot,
  type PlayerState,
  type PlayerTransformState,
} from "./playerState";

type PlayerStateListener = (state: PlayerState) => void;

export interface PlayerEvent<TPayload = unknown> {
  type: string;
  payload?: TPayload;
}

type PlayerEventListener = (event: PlayerEvent) => void;

export interface PlayerModuleDefinition<TState extends Record<string, unknown>> {
  id: string;
  version: number;
  createInitialState(): TState;
  onRegister?(context: PlayerModuleContext<TState>): void;
  onDispose?(context: PlayerModuleContext<TState>): void;
}

export interface PlayerModuleContext<TState extends Record<string, unknown>> {
  read(): TState;
  set(next: TState): void;
  patch(patch: Partial<TState>): void;
  emit(event: PlayerEvent): void;
  actions(): PlayerActionContext;
}

export interface PlayerStoreActions {
  setTransform(transform: PlayerTransformState): void;
  patchMovementIntent(intent: Partial<PlayerMovementIntent>): void;
  setMovementIntent(intent: PlayerMovementIntent): void;
  patchInput(input: Partial<PlayerInputState>): void;
  registerModule<TState extends Record<string, unknown>>(
    definition: PlayerModuleDefinition<TState>,
  ): void;
  unregisterModule(moduleId: string): void;
  emit(event: PlayerEvent): void;
}

export interface PlayerActionContext {
  readState(): PlayerState;
  readTransform(): PlayerTransformState;
  setTransform(transform: PlayerTransformState): void;
  patchMovementIntent(intent: Partial<PlayerMovementIntent>): void;
  updateModule<TState extends Record<string, unknown>>(
    moduleId: string,
    updater: (current: TState) => TState,
  ): void;
  emit(event: PlayerEvent): void;
}

interface PlayerModuleRegistration<TState extends Record<string, unknown>> {
  definition: PlayerModuleDefinition<TState>;
  context: PlayerModuleContext<TState>;
}

export class PlayerStore {
  private state: PlayerState;
  private listeners: Set<PlayerStateListener>;
  private eventListeners: Set<PlayerEventListener>;
  private modules: Map<string, PlayerModuleRegistration<Record<string, unknown>>>;

  constructor(initialState?: PlayerState) {
    this.state = normalizePlayerState(initialState);
    this.listeners = new Set();
    this.eventListeners = new Set();
    this.modules = new Map();
  }

  getSnapshot(): PlayerState {
    return clonePlayerState(this.state);
  }

  getActions(): PlayerStoreActions {
    return {
      setTransform: (transform) => {
        this.setTransform(transform);
      },
      patchMovementIntent: (intent) => {
        this.patchMovementIntent(intent);
      },
      setMovementIntent: (intent) => {
        this.setMovementIntent(intent);
      },
      patchInput: (input) => {
        this.patchInput(input);
      },
      registerModule: (definition) => {
        this.registerModule(definition);
      },
      unregisterModule: (moduleId) => {
        this.unregisterModule(moduleId);
      },
      emit: (event) => {
        this.emit(event);
      },
    };
  }

  getActionContext(): PlayerActionContext {
    return {
      readState: () => this.getSnapshot(),
      readTransform: () => cloneTransform(this.state.transform),
      setTransform: (transform) => this.setTransform(transform),
      patchMovementIntent: (intent) => this.patchMovementIntent(intent),
      updateModule: (moduleId, updater) => {
        this.updateModule(moduleId, updater as (current: Record<string, unknown>) => Record<string, unknown>);
      },
      emit: (event) => this.emit(event),
    };
  }

  subscribe(listener: PlayerStateListener): () => void {
    this.listeners.add(listener);
    listener(this.getSnapshot());
    return () => {
      this.listeners.delete(listener);
    };
  }

  subscribeEvents(listener: PlayerEventListener): () => void {
    this.eventListeners.add(listener);
    return () => {
      this.eventListeners.delete(listener);
    };
  }

  replace(nextState: PlayerState) {
    this.state = normalizePlayerState(nextState);
    this.notify();
  }

  setTransform(transform: PlayerTransformState) {
    if (transformsEqual(this.state.transform, transform)) {
      return;
    }
    this.state = {
      ...this.state,
      transform: cloneTransform(transform),
    };
    this.notify();
  }

  setMovementIntent(intent: PlayerMovementIntent) {
    if (movementIntentEqual(this.state.movementIntent, intent)) {
      return;
    }
    this.state = {
      ...this.state,
      movementIntent: cloneMovementIntent(intent),
    };
    this.notify();
  }

  patchMovementIntent(intent: Partial<PlayerMovementIntent>) {
    const next = { ...this.state.movementIntent, ...intent };
    this.setMovementIntent(next);
  }

  patchInput(input: Partial<PlayerInputState>) {
    const next = { ...this.state.input, ...input };
    if (inputStateEqual(this.state.input, next)) {
      return;
    }
    this.state = {
      ...this.state,
      input: next,
    };
    this.notify();
  }

  registerModule<TState extends Record<string, unknown>>(
    definition: PlayerModuleDefinition<TState>,
  ) {
    if (this.modules.has(definition.id)) {
      return;
    }

    const persisted = this.state.modules[definition.id];
    const moduleState =
      persisted && persisted.version === definition.version
        ? (persisted.state as TState)
        : definition.createInitialState();

    this.state = {
      ...this.state,
      modules: {
        ...this.state.modules,
        [definition.id]: {
          id: definition.id,
          version: definition.version,
          state: cloneRecord(moduleState),
        },
      },
    };

    const context: PlayerModuleContext<TState> = {
      read: () => cloneRecord(this.state.modules[definition.id].state as TState),
      set: (next) => {
        this.state = {
          ...this.state,
          modules: {
            ...this.state.modules,
            [definition.id]: {
              id: definition.id,
              version: definition.version,
              state: cloneRecord(next),
            },
          },
        };
        this.notify();
        this.emit({ type: "player.module.updated", payload: { moduleId: definition.id } });
      },
      patch: (patch) => {
        const previous = this.state.modules[definition.id].state as TState;
        const next = { ...previous, ...patch };
        context.set(next);
      },
      emit: (event) => {
        this.emit(event);
      },
      actions: () => this.getActionContext(),
    };

    this.modules.set(definition.id, {
      definition,
      context,
    });

    definition.onRegister?.(context);
    this.emit({ type: "player.module.registered", payload: { moduleId: definition.id } });
    this.notify();
  }

  unregisterModule(moduleId: string) {
    const registration = this.modules.get(moduleId);
    if (!registration) {
      return;
    }

    registration.definition.onDispose?.(registration.context);
    this.modules.delete(moduleId);
    const nextModules = { ...this.state.modules };
    delete nextModules[moduleId];
    this.state = {
      ...this.state,
      modules: nextModules,
    };
    this.emit({ type: "player.module.unregistered", payload: { moduleId } });
    this.notify();
  }

  emit(event: PlayerEvent) {
    this.eventListeners.forEach((listener) => {
      listener(event);
    });
  }

  private updateModule(
    moduleId: string,
    updater: (current: Record<string, unknown>) => Record<string, unknown>,
  ) {
    const moduleSnapshot = this.state.modules[moduleId];
    if (!moduleSnapshot) {
      return;
    }
    const current = moduleSnapshot.state;
    const next = updater(current);
    if (shallowEqual(current, next)) {
      return;
    }
    this.state = {
      ...this.state,
      modules: {
        ...this.state.modules,
        [moduleId]: {
          id: moduleSnapshot.id,
          version: moduleSnapshot.version,
          state: cloneRecord(next),
        },
      },
    };
    this.notify();
    this.emit({ type: "player.module.updated", payload: { moduleId } });
  }

  private notify() {
    const snapshot = this.getSnapshot();
    this.listeners.forEach((listener) => {
      listener(snapshot);
    });
  }
}

function normalizePlayerState(state?: PlayerState): PlayerState {
  if (!state || state.version !== PLAYER_STATE_VERSION) {
    return createEmptyPlayerState();
  }
  const snapshot = createEmptyPlayerState();
  snapshot.transform = cloneTransform(state.transform);
  snapshot.movementIntent = cloneMovementIntent(state.movementIntent);
  snapshot.input = { ...state.input };
  snapshot.modules = {};
  Object.values(state.modules ?? {}).forEach((module) => {
    if (!module) {
      return;
    }
    snapshot.modules[module.id] = {
      id: module.id,
      version: module.version,
      state: cloneRecord(module.state),
    };
  });
  return snapshot;
}

function clonePlayerState(state: PlayerState): PlayerState {
  return {
    version: state.version,
    transform: cloneTransform(state.transform),
    movementIntent: cloneMovementIntent(state.movementIntent),
    input: { ...state.input },
    modules: cloneModules(state.modules),
  };
}

function cloneTransform(transform: PlayerTransformState): PlayerTransformState {
  return {
    position: { ...transform.position },
    orientation: { ...transform.orientation },
    velocity: { ...transform.velocity },
  };
}

function cloneMovementIntent(intent: PlayerMovementIntent): PlayerMovementIntent {
  return {
    move: { ...intent.move },
    sprint: intent.sprint,
    jump: intent.jump,
    crouch: intent.crouch,
  };
}

function cloneModules(
  modules: Record<string, PlayerModuleSnapshot<Record<string, unknown>>>,
): Record<string, PlayerModuleSnapshot<Record<string, unknown>>> {
  const copy: Record<string, PlayerModuleSnapshot<Record<string, unknown>>> = {};
  Object.values(modules).forEach((module) => {
    if (!module) {
      return;
    }
    copy[module.id] = {
      id: module.id,
      version: module.version,
      state: cloneRecord(module.state),
    };
  });
  return copy;
}

function cloneRecord<T extends Record<string, unknown>>(record: T): T {
  return { ...record };
}

function shallowEqual(a: Record<string, unknown>, b: Record<string, unknown>) {
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  if (keysA.length !== keysB.length) {
    return false;
  }
  return keysA.every((key) => Object.is(a[key], b[key]));
}

function transformsEqual(a: PlayerTransformState, b: PlayerTransformState) {
  return (
    almostEqual(a.position.x, b.position.x) &&
    almostEqual(a.position.y, b.position.y) &&
    almostEqual(a.position.z, b.position.z) &&
    almostEqual(a.velocity.x, b.velocity.x) &&
    almostEqual(a.velocity.y, b.velocity.y) &&
    almostEqual(a.velocity.z, b.velocity.z) &&
    almostEqual(a.orientation.x, b.orientation.x) &&
    almostEqual(a.orientation.y, b.orientation.y) &&
    almostEqual(a.orientation.z, b.orientation.z) &&
    almostEqual(a.orientation.w, b.orientation.w)
  );
}

function movementIntentEqual(a: PlayerMovementIntent, b: PlayerMovementIntent) {
  return (
    almostEqual(a.move.x, b.move.x) &&
    almostEqual(a.move.z, b.move.z) &&
    a.sprint === b.sprint &&
    a.jump === b.jump &&
    a.crouch === b.crouch
  );
}

function inputStateEqual(a: PlayerInputState, b: PlayerInputState) {
  return (
    a.pointerLocked === b.pointerLocked &&
    a.movementLocked === b.movementLocked &&
    a.cameraLocked === b.cameraLocked
  );
}

function almostEqual(a: number, b: number) {
  return Math.abs(a - b) <= 1e-5;
}
</file>

<file path="src/fps/utils/math.ts">
export function clamp(value: number, min: number, max: number) {
  return Math.min(Math.max(value, min), max);
}

export function degreesToRadians(degrees: number) {
  return (degrees * Math.PI) / 180;
}
</file>

<file path="src/legacy/game/Game.ts">
import { Engine, Scene, ArcRotateCamera, UniversalCamera, Vector3, HemisphericLight, MeshBuilder, Color3, StandardMaterial, Mesh, Color4, DynamicTexture, ParticleSystem, Texture, VertexBuffer, GlowLayer, PointLight, Scalar, KeyboardEventTypes } from 'babylonjs';
import type { ResourceType, Sector } from './world';
import { generateSector } from './world';

type Vec3 = { x: number; y: number; z: number };

type ScriptJob = { name: string; code: string };
type ScriptEntry = { code: string; description: string; lastModified: string };
type WorkerLogEntry = { id: string; level: 'info' | 'warn' | 'error'; message: string; timestamp: number };
type WorkerState = 'idle' | 'starting' | 'running' | 'completed' | 'error' | 'stopped';
type WorkerStatus = {
  scriptName: string | null;
  state: WorkerState;
  startedAt?: number;
  finishedAt?: number;
  logs: WorkerLogEntry[];
  lastMessage?: string;
  lastError?: string;
};

export type TerminalId = 'engineering' | 'construction';
export type TerminalInfo = { id: TerminalId; label: string; hint: string; description?: string };

type TerminalInstance = TerminalInfo & {
  mesh: Mesh;
  screen: Mesh;
  interactDistance: number;
  idleColor: Color3;
  activeColor: Color3;
  light?: PointLight | null;
};

type GameOptions = {
  onTerminalProximity?: (info: TerminalInfo | null) => void;
  onTerminalInteract?: (info: TerminalInfo) => void;
  onPointerLockChange?: (locked: boolean) => void;
};

export class Game {
  private engine: Engine;
  private scene: Scene;
  private camera: ArcRotateCamera;
  private fpCamera: UniversalCamera;
  private options: GameOptions;
  private inputPaused = false;
  private pointerLocked = false;
  private terminals: TerminalInstance[] = [];
  private nearbyTerminal: TerminalInstance | null = null;
  private activeTerminalId: TerminalId | null = null;
  private canvasClickHandler: (() => void) | null = null;
  private pointerLockHandler: (() => void) | null = null;
  private ship = { mesh: null as unknown as Mesh, velocity: new Vector3(0, 0, 0), maxSpeed: 1.8, destination: null as Vector3 | null };
  private world!: Sector;
  private asteroidMeshes = new Map<string, Mesh>();
  private meshToAsteroidId = new Map<string, string>();
  private selected: { type: 'ship' | 'asteroid' | null; id?: string } = { type: null };
  private selectedPrevEmissive: Color3 | null = null;
  private inventory = { iron: 0, silicon: 0, uranium: 0 };
  private mining = { targetId: null as string | null, active: false, range: 10, rate: 5 };
  private miningLog: { lastEvent: 'none' | 'depleted' | 'stopped'; lastTarget?: { id: string; resource: ResourceType } } = { lastEvent: 'none' };
  private scanned = new Set<string>();
  private scanRadius = 1000; // km (redefinido após carregar o setor)
  private logicTimer: number | null = null;
  private worker: Worker | null = null;
  private workerStatus: WorkerStatus = { scriptName: null, state: 'idle', logs: [] };
  private mode: 'play' | 'sector' = 'play';
  private prevCam: { alpha: number; beta: number; radius: number; target: Vector3; fogMode: number; fogStart?: number; fogEnd?: number; fogDensity?: number; panning?: number; lockedTarget?: any; followingShip?: boolean } | null = null;
  private labelMeshes: Mesh[] = [];
  private sun?: Mesh;
  private starfield?: Mesh;
  private dustEmitter?: Mesh;
  private dustSystem?: ParticleSystem;
  private distantStars: Array<{ material: StandardMaterial; base: number; amplitude: number; speed: number; phase: number; color: Color3 }> = [];
  private followingShip = false;
  // Script Library (persisted)
  private scriptLibrary: Map<string, ScriptEntry> = new Map();

  constructor(private canvas: HTMLCanvasElement, options: GameOptions = {}) {
    this.options = options;
    this.engine = new Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
    this.scene = new Scene(this.engine);
    this.scene.clearColor = new Color4(0.02, 0.04, 0.08, 1); // deep space
    // Softer, longer-range fog for melhor visibilidade
    this.scene.fogMode = Scene.FOGMODE_LINEAR;
    this.scene.fogColor = new Color3(0.03, 0.06, 0.12) as any;
    (this.scene as any).fogStart = 2500;
    (this.scene as any).fogEnd = 9000;

    // Camera: top-down legacy (mantida para automações táticas)
    this.camera = new ArcRotateCamera('camera', Math.PI / 2, 1.2, 120, new Vector3(0, 0, 0), this.scene);
    this.camera.panningSensibility = 50;
    this.camera.lowerRadiusLimit = 40;
    this.camera.upperRadiusLimit = 1000;
    this.camera.minZ = 0.1;

    // First-person camera inside the ship
    this.scene.collisionsEnabled = true;
    this.scene.gravity = new Vector3(0, -0.6, 0);
    this.fpCamera = new UniversalCamera('fpCamera', new Vector3(0, 1.7, 6), this.scene);
    this.fpCamera.minZ = 0.05;
    this.fpCamera.speed = 1.8;
    this.fpCamera.inertia = 0.6;
    this.fpCamera.angularSensibility = 5200;
    this.fpCamera.applyGravity = true;
    this.fpCamera.checkCollisions = true;
    this.fpCamera.ellipsoid = new Vector3(0.5, 0.9, 0.5);
    this.fpCamera.keysUp.push(87, 38); // W / ArrowUp
    this.fpCamera.keysDown.push(83, 40); // S / ArrowDown
    this.fpCamera.keysLeft.push(65, 37); // A / ArrowLeft
    this.fpCamera.keysRight.push(68, 39); // D / ArrowRight
    this.scene.activeCamera = this.fpCamera;
    this.fpCamera.attachControl(canvas, true);
    const fpMouse = (this.fpCamera.inputs.attached as any)?.mouse;
    if (fpMouse) {
      fpMouse.usePointerLock = true;
    }
    this.setupPointerLock();

    new HemisphericLight('light1', new Vector3(1, 1, 0), this.scene);

    // Ship mesh
    const ship = MeshBuilder.CreateBox('ship', { width: 2.2, depth: 5, height: 1.2 }, this.scene);
    const sm = new StandardMaterial('shipMat', this.scene);
    sm.diffuseColor = new Color3(0.5, 0.7, 1);
    ship.material = sm;
    this.ship.mesh = ship as any;

    // Load or generate sector and spawn bodies
    const loaded = this.tryLoad();
    if (!loaded) {
      this.world = generateSector();
    }
    // Ajustar parâmetros dependentes da escala do setor
    this.configureScaleFromWorld();
    this.spawnSector();

    // Load scripts library (seed with default patrol if empty)
    this.loadScripts();

    // Background: starfield skybox + subtle dust + sun
    this.createStarfield();
    this.createSpaceDust();
    this.createDistantStars();
    this.createSun();
    this.createShipInterior();

    // Input: selection picking
    this.setupPicking();

    // Render loop
    this.engine.runRenderLoop(() => {
      this.updatePhysics();
      this.scene.render();
    });

    // Logic tick at 1 Hz
    this.logicTimer = window.setInterval(() => this.logicTick(), 1000);

    // Resize
    window.addEventListener('resize', () => this.engine.resize());
  }

  private setupPointerLock() {
    if (this.canvasClickHandler) {
      this.canvas.removeEventListener('click', this.canvasClickHandler);
    }
    if (this.pointerLockHandler) {
      document.removeEventListener('pointerlockchange', this.pointerLockHandler);
    }
    this.canvasClickHandler = () => {
      if (this.inputPaused) return;
      if (document.pointerLockElement !== this.canvas) {
        this.canvas.requestPointerLock();
      }
    };
    this.pointerLockHandler = () => {
      const locked = document.pointerLockElement === this.canvas;
      this.pointerLocked = locked;
      this.options.onPointerLockChange?.(locked);
    };
    this.canvas.addEventListener('click', this.canvasClickHandler);
    document.addEventListener('pointerlockchange', this.pointerLockHandler);
  }

  dispose() {
    if (document.pointerLockElement === this.canvas) {
      document.exitPointerLock();
    }
    if (this.canvasClickHandler) {
      this.canvas.removeEventListener('click', this.canvasClickHandler);
      this.canvasClickHandler = null;
    }
    if (this.pointerLockHandler) {
      document.removeEventListener('pointerlockchange', this.pointerLockHandler);
      this.pointerLockHandler = null;
    }
    if (this.logicTimer) window.clearInterval(this.logicTimer);
    if (this.worker) {
      this.worker.terminate();
      this.worker = null;
    }
    this.workerStatus = { scriptName: null, state: 'idle', logs: [] };
    this.scene.dispose();
    this.engine.dispose();
  }

  moveTo(v: Vec3) {
    this.ship.destination = new Vector3(v.x, v.y, v.z);
  }

  setFollowShip(on: boolean) {
    this.followingShip = on;
    if (on) {
      // Segue a nave usando lockedTarget
      this.camera.lockedTarget = this.ship.mesh;
    } else {
      this.camera.lockedTarget = null as any;
    }
  }

  isFollowingShip() {
    return this.followingShip;
  }

  getShipStatus() {
    return {
      position: this.ship.mesh.position.clone(),
      speed: this.ship.velocity.length(),
      destination: this.ship.destination ? { x: this.ship.destination.x, y: this.ship.destination.y, z: this.ship.destination.z } : null,
    };
  }

  getSectorInfo() {
    const counts = this.world.asteroids.reduce(
      (acc, a) => {
        acc[a.resource] += a.amount > 0 ? 1 : 0;
        return acc;
      },
      { iron: 0, silicon: 0, uranium: 0 } as Record<ResourceType, number>
    );
    return {
      id: this.world.id,
      name: this.world.name,
      seed: this.world.seed,
      bounds: this.world.bounds,
      asteroidCounts: counts,
    };
  }

  getResources() {
    return { ...this.inventory };
  }

  performScan() {
    // Reveal asteroides dentro do raio de varredura a partir da nave
    const pos = this.ship.mesh.position;
    const newly: string[] = [];
    for (const a of this.world.asteroids) {
      if (a.amount <= 0) continue;
      if (this.scanned.has(a.id)) continue;
      const d = new Vector3(a.position.x, a.position.y, a.position.z).subtract(pos).length();
      if (d <= this.scanRadius) {
        this.scanned.add(a.id);
        newly.push(a.id);
      }
    }
    return newly;
  }

  scanSector(filter?: { resource?: ResourceType; limit?: number }) {
    const pos = this.ship.mesh.position;
    const entries = this.world.asteroids
      .filter((a) => this.scanned.has(a.id) && a.amount > 0 && (!filter?.resource || a.resource === filter.resource))
      .map((a) => {
        const d = new Vector3(a.position.x, a.position.y, a.position.z).subtract(pos).length();
        return { id: a.id, resource: a.resource, amount: a.amount, position: a.position, distance: d, clusterId: a.clusterId };
      })
      .sort((a, b) => a.distance - b.distance);
    const limit = filter?.limit ?? 10;
    return entries.slice(0, limit);
  }

  startMining(resource: ResourceType) {
    // Prefer scanned targets; if none scanned, try performScan first
    let nearest = this.scanSector({ resource, limit: 1 })[0];
    if (!nearest) {
      this.performScan();
      nearest = this.scanSector({ resource, limit: 1 })[0];
    }
    if (!nearest) return { ok: false as const, error: 'No asteroid found for resource' };
    this.mining.targetId = nearest.id;
    this.mining.active = false; // will activate when in range
    this.ship.destination = new Vector3(nearest.position.x, nearest.position.y, nearest.position.z);
    this.miningLog.lastEvent = 'none';
    return { ok: true as const, targetId: nearest.id, position: nearest.position };
  }

  stopMining() {
    this.mining.targetId = null;
    this.mining.active = false;
    this.miningLog.lastEvent = 'stopped';
    return { ok: true as const };
  }

  resetSector() {
    // Clear persistence and regenerate
    try { localStorage.removeItem('starwatch.v010.save'); } catch {}
    // Dispose asteroid meshes
    for (const [, m] of this.asteroidMeshes) m.dispose(false, true);
    this.asteroidMeshes.clear();
    this.meshToAsteroidId.clear();
    // Reset state
    this.world = generateSector();
    this.scanned.clear();
    this.inventory = { iron: 0, silicon: 0, uranium: 0 };
    this.mining = { targetId: null, active: false, range: 10, rate: 5 };
    this.ship.destination = null;
    this.ship.mesh.position.set(0, 0, 0);
    this.worker?.terminate();
    this.worker = null;
    this.workerStatus = { scriptName: null, state: 'idle', logs: [] };
    // Respawn
    this.spawnSector();
    // Save immediately
    this.save();
  }

  enterSectorMap() {
    if (this.mode === 'sector') return;
    this.mode = 'sector';
    this.prevCam = {
      alpha: this.camera.alpha,
      beta: this.camera.beta,
      radius: this.camera.radius,
      target: this.camera.target.clone(),
      fogMode: this.scene.fogMode!,
      fogStart: (this.scene as any).fogStart,
      fogEnd: (this.scene as any).fogEnd,
      fogDensity: (this.scene as any).fogDensity,
      panning: this.camera.panningSensibility,
      lockedTarget: (this.camera as any).lockedTarget,
      followingShip: this.followingShip,
    };
    // Desliga follow para visão do mapa do setor
    this.setFollowShip(false);
    // Top-down zoomed out
    this.camera.setTarget(new Vector3(0, 0, 0));
    this.camera.alpha = Math.PI / 2;
    this.camera.beta = 0.0001;
    this.camera.radius = this.world.bounds * 1.8;
    this.camera.panningSensibility = 0;
    // Disable fog for clarity
    this.scene.fogMode = Scene.FOGMODE_NONE as any;
    // Create labels
    this.createSectorLabels();
  }

  exitSectorMap() {
    if (this.mode !== 'sector') return;
    this.mode = 'play';
    // Restore camera and fog
    if (this.prevCam) {
      this.camera.setTarget(this.prevCam.target);
      this.camera.alpha = this.prevCam.alpha;
      this.camera.beta = this.prevCam.beta;
      this.camera.radius = this.prevCam.radius;
      if (this.prevCam.panning != null) this.camera.panningSensibility = this.prevCam.panning;
      this.scene.fogMode = this.prevCam.fogMode as any;
      (this.scene as any).fogStart = this.prevCam.fogStart;
      (this.scene as any).fogEnd = this.prevCam.fogEnd;
      (this.scene as any).fogDensity = this.prevCam.fogDensity;
      // Restaura lockTarget/follow ship
      if (this.prevCam.followingShip) this.setFollowShip(true);
      else this.camera.lockedTarget = this.prevCam.lockedTarget ?? null;
    }
    // Dispose labels
    for (const m of this.labelMeshes) m.dispose(false, true);
    this.labelMeshes = [];
  }

  runScript(job: ScriptJob) {
    if (this.worker) {
      this.worker.terminate();
      if (this.workerStatus.state === 'running' || this.workerStatus.state === 'starting') {
        this.workerStatus = {
          ...this.workerStatus,
          state: 'stopped',
          finishedAt: Date.now(),
          lastMessage: 'Script anterior interrompido.',
        };
      }
    }
    this.workerStatus = {
      scriptName: job.name,
      state: 'starting',
      startedAt: Date.now(),
      logs: [],
    };
    const blob = new Blob([
      this.makeWorkerSource(job.code, job.name)
    ], { type: 'application/javascript' });
    const url = URL.createObjectURL(blob);
    const worker = new Worker(url, { type: 'module' });
    URL.revokeObjectURL(url);
    this.worker = worker;
    this.workerStatus.state = 'running';

    worker.onmessage = (ev) => {
      const msg = ev.data;
      if (!msg) return;
      if (msg.type === 'tool') {
        (async () => {
          try {
            if (msg.name === 'moveTo') {
              const { x, y, z } = msg.args ?? {};
              this.moveTo({ x, y, z });
              worker.postMessage({ type: 'tool-ack', id: msg.id, ok: true, result: null });
            } else if (msg.name === 'performScan') {
              const out = this.performScan();
              worker.postMessage({ type: 'tool-ack', id: msg.id, ok: true, result: out });
            } else if (msg.name === 'scanSector') {
              const out = this.scanSector(msg.args);
              worker.postMessage({ type: 'tool-ack', id: msg.id, ok: true, result: out });
            } else if (msg.name === 'startMining') {
              const out = this.startMining(msg.args?.resource);
              worker.postMessage({ type: 'tool-ack', id: msg.id, ok: true, result: out });
            } else if (msg.name === 'stopMining') {
              const out = this.stopMining();
              worker.postMessage({ type: 'tool-ack', id: msg.id, ok: true, result: out });
            } else if (msg.name === 'getMiningStatus') {
              const out = this.getMiningStatus();
              worker.postMessage({ type: 'tool-ack', id: msg.id, ok: true, result: out });
            } else if (msg.name === 'getShipStatus') {
              const out = this.getShipStatus();
              worker.postMessage({ type: 'tool-ack', id: msg.id, ok: true, result: out });
            } else if (msg.name === 'getResources') {
                const out = this.getResources();
                worker.postMessage({ type: 'tool-ack', id: msg.id, ok: true, result: out });
              }
            } catch (e) {
              console.error('Script tool error', e);
              worker.postMessage({ type: 'tool-ack', id: msg.id, ok: false, error: String(e) });
            }
        })();
      } else if (msg.type === 'log') {
        const entry: WorkerLogEntry = {
          id: msg.id || Math.random().toString(36).slice(2),
          level: msg.level === 'error' ? 'error' : msg.level === 'warn' ? 'warn' : 'info',
          message: String(msg.message ?? ''),
          timestamp: msg.timestamp || Date.now(),
        };
        this.workerStatus.logs = [...this.workerStatus.logs.slice(-99), entry];
        this.workerStatus.lastMessage = entry.message;
        if (entry.level === 'error') {
          this.workerStatus.lastError = entry.message;
        }
      } else if (msg.type === 'script-state') {
        if (msg.state === 'completed') {
          this.workerStatus = {
            ...this.workerStatus,
            state: 'completed',
            finishedAt: Date.now(),
            lastMessage: msg.message || 'Script concluído.',
          };
          worker.terminate();
          if (this.worker === worker) this.worker = null;
        } else if (msg.state === 'error') {
          this.workerStatus = {
            ...this.workerStatus,
            state: 'error',
            finishedAt: Date.now(),
            lastError: msg.error || 'Erro desconhecido',
          };
          worker.terminate();
          if (this.worker === worker) this.worker = null;
        }
      }
    };
    worker.onerror = (e) => {
      console.error('Script worker error', e);
      this.workerStatus = {
        ...this.workerStatus,
        state: 'error',
        finishedAt: Date.now(),
        lastError: e.message || String(e),
      };
      if (this.worker === worker) this.worker = null;
    };
  }

  runScriptByName(name: string) {
    const code = this.getScriptCode(name);
    if (!code) {
      console.warn('Script not found:', name);
      return { ok: false as const, error: 'Script not found' };
    }
    this.runScript({ name, code });
    return { ok: true as const };
  }

  private makeWorkerSource(userCode: string, scriptName: string) {
    // Tiny API bridge: Game.moveTo, Memory.get/set, sleep + mining/scan helpers
    return `
      const __postLog = (level, message) => {
        try {
          postMessage({ type: 'log', level, message: message != null ? String(message) : '', timestamp: Date.now(), id: Math.random().toString(36).slice(2) });
        } catch (_) {}
      };
      const __formatArgs = (args) => args.map((v) => {
        if (typeof v === 'string') return v;
        try { return JSON.stringify(v); } catch { return String(v); }
      }).join(' ');
      (() => {
        const originalLog = console.log.bind(console);
        const originalWarn = console.warn ? console.warn.bind(console) : console.log.bind(console);
        const originalError = console.error ? console.error.bind(console) : console.log.bind(console);
        console.log = (...args) => { originalLog(...args); __postLog('info', __formatArgs(args)); };
        console.warn = (...args) => { originalWarn(...args); __postLog('warn', __formatArgs(args)); };
        console.error = (...args) => { originalError(...args); __postLog('error', __formatArgs(args)); };
      })();

      const Memory = new Map();
      function postTool(name, args) {
        return new Promise((resolve) => {
          const id = Math.random().toString(36).slice(2);
          function onAck(ev) {
            const msg = ev.data;
            if (msg && msg.type === 'tool-ack' && msg.id === id) {
              resolve(msg.result);
              self.removeEventListener('message', onAck);
            }
          }
          self.addEventListener('message', onAck);
          postMessage({ type: 'tool', id, name, args });
        });
      }
      const Game = {
        moveTo: async (v) => { await postTool('moveTo', v); },
        performScan: async () => await postTool('performScan'),
        scanSector: async (filter) => await postTool('scanSector', filter),
        startMining: async (resource) => await postTool('startMining', { resource }),
        stopMining: async () => await postTool('stopMining'),
        getMiningStatus: async () => await postTool('getMiningStatus'),
        getShipStatus: async () => await postTool('getShipStatus'),
        getResources: async () => await postTool('getResources'),
      };
      const sleep = (ms) => new Promise(r => setTimeout(r, ms));
      const MemoryAPI = { set: (k, v) => Memory.set(k, v), get: (k) => Memory.get(k) };
      self.Game = Game; self.Memory = MemoryAPI; self.sleep = sleep;
      // Helpers
      async function patrol() {
        const A = { x: 500, y: 0, z: 250 }; const B = { x: 200, y: 0, z: -200 };
        while (true) { await Game.moveTo(A); await sleep(3000); await Game.moveTo(B); await sleep(3000); }
      }
      async function mineResource(resource) {
        await Game.performScan();
        const res = await Game.startMining(resource);
        if (!res?.ok) return res;
        while (true) {
          const s = await Game.getMiningStatus();
          if (!s || s.state === 'idle') break;
          await sleep(1000);
        }
        return { ok: true };
      }
      postMessage({ type: 'script-state', state: 'ready', scriptName: ${JSON.stringify(scriptName)} });
      (async () => {
        try {
${userCode.split('\n').map((line) => `          ${line}`).join('\n')}
        } catch (e) {
          console.error('Erro no script:', e);
          postMessage({ type: 'script-state', state: 'error', error: e?.stack || e?.message || String(e) });
          return;
        }
        postMessage({ type: 'script-state', state: 'completed', message: 'Execução encerrada.' });
      })();
    `;
  }

  // ===== Script Library API =====
  listScripts() {
    return Array.from(this.scriptLibrary.entries()).map(([name, e]) => ({ name, description: e.description, lastModified: e.lastModified }));
  }

  getScriptCode(name: string): string | null {
    const e = this.scriptLibrary.get(name);
    return e ? e.code : null;
  }

  createScript(name: string, code: string, description: string = '') {
    if (!name || !code) return { ok: false as const, error: 'Missing name or code' };
    if (this.scriptLibrary.has(name)) return { ok: false as const, error: 'Script already exists' };
    const entry: ScriptEntry = { code, description, lastModified: new Date().toISOString() };
    this.scriptLibrary.set(name, entry);
    this.saveScripts();
    return { ok: true as const };
  }

  updateScript(name: string, newCode: string) {
    const e = this.scriptLibrary.get(name);
    if (!e) return { ok: false as const, error: 'Script not found' };
    e.code = newCode;
    e.lastModified = new Date().toISOString();
    this.scriptLibrary.set(name, e);
    this.saveScripts();
    return { ok: true as const };
  }

  deleteScript(name: string) {
    if (!this.scriptLibrary.has(name)) return { ok: false as const, error: 'Script not found' };
    this.scriptLibrary.delete(name);
    this.saveScripts();
    return { ok: true as const };
  }

  private loadScripts() {
    try {
      const raw = localStorage.getItem('starwatch.v030.scripts');
      if (raw) {
        const obj = JSON.parse(raw) as Record<string, ScriptEntry>;
        this.scriptLibrary = new Map<string, ScriptEntry>(Object.entries(obj));
      }
    } catch (e) {
      console.warn('Failed to load scripts', e);
    }
    if (this.scriptLibrary.size === 0) {
      // Seed with a default patrol script
      const code = `// patrol.js\n// Patrulha simples entre dois pontos usando a API do worker\n(async () => {\n  const A = { x: 500, y: 0, z: 250 };\n  const B = { x: 200, y: 0, z: -200 };\n  while (true) {\n    await Game.moveTo(A);\n    await sleep(3000);\n    await Game.moveTo(B);\n    await sleep(3000);\n  }\n})();`;
      this.scriptLibrary.set('patrol.js', { code, description: 'Patrulha entre dois pontos', lastModified: new Date().toISOString() });
      this.saveScripts();
    }
  }

  private saveScripts() {
    try {
      const obj: Record<string, ScriptEntry> = {};
      for (const [k, v] of this.scriptLibrary.entries()) obj[k] = v;
      localStorage.setItem('starwatch.v030.scripts', JSON.stringify(obj));
    } catch (e) {
      console.warn('Failed to save scripts', e);
    }
  }

  private updatePhysics() {
    const dt = this.engine.getDeltaTime() / 1000; // seconds
    const pos = this.ship.mesh.position;
    if (this.ship.destination) {
      const to = this.ship.destination.subtract(pos);
      const dist = to.length();
      if (dist < 0.5) {
        this.ship.velocity.setAll(0);
      } else {
        const dir = to.normalize();
        this.ship.velocity = dir.scale(this.ship.maxSpeed);
      }
    } else {
      this.ship.velocity.setAll(0);
    }
    pos.addInPlace(this.ship.velocity.scale(dt));

    // Se está seguindo a nave e não estamos no mapa de setor, garante lock ativo
    if (this.followingShip && this.mode === 'play') {
      if ((this.camera as any).lockedTarget !== this.ship.mesh) {
        this.camera.lockedTarget = this.ship.mesh;
      }
    }

    // Mining auto-activation and extraction
    if (this.mining.targetId) {
      const a = this.world.asteroids.find((x) => x.id === this.mining.targetId);
      if (a && a.amount > 0) {
        const d = new Vector3(a.position.x, a.position.y, a.position.z).subtract(pos).length();
        if (!this.mining.active && d <= this.mining.range) {
          this.mining.active = true;
        }
        if (this.mining.active && d <= this.mining.range + 2) {
          // Extract resources
          const mined = Math.min(this.mining.rate * dt, a.amount);
          a.amount -= mined;
          // Update inventory
          if (a.resource === 'iron') this.inventory.iron += mined;
          if (a.resource === 'silicon') this.inventory.silicon += mined;
          if (a.resource === 'uranium') this.inventory.uranium += mined;
          // Visual feedback: shrink slightly
          const mesh = this.asteroidMeshes.get(a.id);
          if (mesh) {
            const base = Math.max(0.5, a.radius * 0.5);
            const factor = Math.max(0.2, a.amount / (a.radius * 100));
            mesh.scaling.setAll(Math.max(base * factor, 0.2));
          }
          if (a.amount <= 0.0001) {
            // Depleted: remove visually
            const m = this.asteroidMeshes.get(a.id);
            if (m) {
              m.dispose(false, true);
              this.asteroidMeshes.delete(a.id);
            }
            this.mining.targetId = null;
            this.mining.active = false;
            this.miningLog.lastEvent = 'depleted';
            this.miningLog.lastTarget = { id: a.id, resource: a.resource };
          }
        }
      } else {
        // Target disappeared
        this.mining.targetId = null;
        this.mining.active = false;
      }
    }
  }

  private logicTick() {
    // Persist state periodically
    this.save();
  }

  private spawnSector() {
    // remove any previous
    for (const [, m] of this.asteroidMeshes) m.dispose(false, true);
    this.asteroidMeshes.clear();
    this.meshToAsteroidId.clear();

    for (const a of this.world.asteroids) {
      if (a.amount <= 0) continue;
      const mesh = this.createAsteroidMesh(a.id, a.resource, a.radius);
      const mat = new StandardMaterial(`mat:${a.id}`, this.scene);
      // Consistent color by type (iron=green, silicon=bluish, uranium=amber)
      if (a.resource === 'iron') mat.diffuseColor = new Color3(0.3, 0.75, 0.35);
      if (a.resource === 'silicon') mat.diffuseColor = new Color3(0.65, 0.7, 0.85);
      if (a.resource === 'uranium') mat.diffuseColor = new Color3(0.85, 0.75, 0.35);
      mesh.material = mat;
      mesh.position = new Vector3(a.position.x, a.position.y, a.position.z);
      this.asteroidMeshes.set(a.id, mesh);
      this.meshToAsteroidId.set(mesh.id, a.id);
    }
  }

  private setupPicking() {
    this.scene.onPointerDown = (_evt, pickInfo) => {
      // Cleanup previous highlight
      if (this.selected.type === 'asteroid' && this.selected.id) {
        const m = this.asteroidMeshes.get(this.selected.id);
        if (m && m.material instanceof StandardMaterial && this.selectedPrevEmissive) {
          (m.material as StandardMaterial).emissiveColor = this.selectedPrevEmissive;
        }
      }
      this.selected = { type: null };
      this.selectedPrevEmissive = null;

      if (pickInfo?.hit && pickInfo.pickedMesh) {
        const mesh = pickInfo.pickedMesh as Mesh;
        if (mesh.id === this.ship.mesh.id) {
          this.selected = { type: 'ship' };
          // foco na nave; manter follow se já ativo
          this.focusCameraOn(this.ship.mesh.position);
        } else if (mesh.id.startsWith('ast:')) {
          const aId = this.meshToAsteroidId.get(mesh.id);
          if (aId) {
            this.selected = { type: 'asteroid', id: aId };
            if (mesh.material instanceof StandardMaterial) {
              const sm = mesh.material as StandardMaterial;
              this.selectedPrevEmissive = sm.emissiveColor.clone();
              sm.emissiveColor = new Color3(0.3, 0.5, 0.9);
            }
            this.focusCameraOn((this.asteroidMeshes.get(aId) as Mesh).position, 80);
          }
        }
      }
    };
  }

  private rndFromId(id: string) {
    let h = 2166136261;
    for (let i = 0; i < id.length; i++) h = (h ^ id.charCodeAt(i)) * 16777619;
    const seed = h >>> 0;
    return function () {
      // mulberry32
      let t = (seed + 0x6d2b79f5) >>> 0;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  private createAsteroidMesh(id: string, resource: ResourceType, radius: number): Mesh {
    // Base meshes vary by type
    let mesh: Mesh;
    const name = `ast:${id}`;
    if (resource === 'silicon') {
      // sharp crystal-like
      mesh = MeshBuilder.CreatePolyhedron(name, { type: 1, size: radius }, this.scene); // Tetrahedron
    } else if (resource === 'uranium') {
      // elongated body
      mesh = MeshBuilder.CreateIcoSphere(name, { radius, subdivisions: 2 }, this.scene);
      mesh.scaling = new Vector3(1.0, 0.7, 1.3);
    } else {
      // iron: chunky rock
      mesh = MeshBuilder.CreateIcoSphere(name, { radius, subdivisions: 3 }, this.scene);
    }

    // Perturb vertices deterministically for id
    const rng = this.rndFromId(id);
    const pos = mesh.getVerticesData(VertexBuffer.PositionKind) as number[];
    if (pos) {
      const amp = resource === 'silicon' ? 0.12 : resource === 'uranium' ? 0.18 : 0.22;
      for (let i = 0; i < pos.length; i += 3) {
        const nx = (rng() - 0.5) * 2;
        const ny = (rng() - 0.5) * 2;
        const nz = (rng() - 0.5) * 2;
        pos[i] += nx * amp * radius;
        pos[i + 1] += ny * amp * radius;
        pos[i + 2] += nz * amp * radius;
      }
      mesh.updateVerticesData(VertexBuffer.PositionKind, pos);
      mesh.refreshBoundingInfo();
    }
    return mesh;
  }

  focusCameraOn(target: Vector3 | { x: number; y: number; z: number }, radius: number = 100) {
    const t = target instanceof Vector3 ? target : new Vector3(target.x, target.y, target.z);
    // Smoothly move camera target and radius
    // Qualquer foco manual desliga follow
    this.setFollowShip(false);
    this.camera.setTarget(t);
    const maxR = Math.max(1000, this.world?.bounds ? this.world.bounds * 0.25 : 1000);
    this.camera.radius = Math.max(40, Math.min(radius, maxR));
  }

  getFleet() {
    return [
      {
        id: 'mothership',
        name: 'USS [Nome da Nave]',
        type: 'mothership',
        position: { x: this.ship.mesh.position.x, y: this.ship.mesh.position.y, z: this.ship.mesh.position.z },
        speed: this.ship.velocity.length(),
        script: this.worker ? 'custom' : null,
      },
    ];
  }

  getWorkerStatus(): WorkerStatus {
    return {
      scriptName: this.workerStatus.scriptName,
      state: this.workerStatus.state,
      startedAt: this.workerStatus.startedAt,
      finishedAt: this.workerStatus.finishedAt,
      logs: this.workerStatus.logs.slice(),
      lastMessage: this.workerStatus.lastMessage,
      lastError: this.workerStatus.lastError,
    };
  }

  getMiningStatus() {
    const targetId = this.mining.targetId;
    if (targetId) {
      const a = this.world.asteroids.find((x) => x.id === targetId);
      const pos = this.ship.mesh.position;
      let distance = 0;
      let remaining = 0;
      let resource: ResourceType | undefined = undefined;
      if (a) {
        distance = Vector3.Distance(new Vector3(a.position.x, a.position.y, a.position.z), pos);
        remaining = a.amount;
        resource = a.resource;
      }
      return {
        state: this.mining.active ? 'mining' : 'approaching',
        targetId,
        resource,
        remaining,
        distance,
        inRange: this.mining.active,
        rate: this.mining.rate,
        lastEvent: this.miningLog.lastEvent,
        lastTarget: this.miningLog.lastTarget ?? null,
      } as const;
    }
    return {
      state: 'idle' as const,
      lastEvent: this.miningLog.lastEvent,
      lastTarget: this.miningLog.lastTarget ?? null,
    };
  }

  getClustersOverview(onlyScanned = true) {
    const clusters = this.world.clusters.map((c) => ({ id: c.id, type: c.type, center: c.center, radius: c.radius }));
    const astByCluster = new Map<string, any[]>();
    for (const a of this.world.asteroids) {
      if (onlyScanned && !this.scanned.has(a.id)) continue;
      if (!a.clusterId) continue;
      const arr = astByCluster.get(a.clusterId) || [];
      arr.push({ id: a.id, resource: a.resource, amount: a.amount, position: a.position });
      astByCluster.set(a.clusterId, arr);
    }
    return clusters.map((c) => ({
      ...c,
      discovered: (astByCluster.get(c.id) || []).length,
    }));
  }

  getAsteroidsInCluster(clusterId: string, onlyScanned = true) {
    const pos = this.ship.mesh.position;
    return this.world.asteroids
      .filter((a) => a.clusterId === clusterId && (!onlyScanned || this.scanned.has(a.id)))
      .map((a) => ({ id: a.id, resource: a.resource, amount: a.amount, position: a.position, distance: Vector3.Distance(new Vector3(a.position.x, a.position.y, a.position.z), pos) }))
      .sort((a, b) => a.distance - b.distance);
  }

  private createStarfield() {
    const size = Math.max(8192, this.world.bounds * 4); // escala com o setor
    const sky = MeshBuilder.CreateBox('sky', { size, sideOrientation: Mesh.BACKSIDE }, this.scene);
    const texSize = 2048;
    const dt = new DynamicTexture('stars', { width: texSize, height: texSize }, this.scene, false);
    const ctx = dt.getContext();
    // Fundo com leve gradiente frio
    const gradient = ctx.createRadialGradient(texSize / 2, texSize / 2, texSize * 0.1, texSize / 2, texSize / 2, texSize * 0.7);
    gradient.addColorStop(0, '#060914');
    gradient.addColorStop(1, '#02030a');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, texSize, texSize);
    // Nebulosas suaves para volume distante
    const nebulaCount = 12;
    for (let i = 0; i < nebulaCount; i++) {
      const nx = Math.random() * texSize;
      const ny = Math.random() * texSize;
      const radius = (Math.random() * 0.18 + 0.05) * texSize;
      const hue = 200 + Math.random() * 40;
      const nebula = ctx.createRadialGradient(nx, ny, radius * 0.15, nx, ny, radius);
      nebula.addColorStop(0, `hsla(${hue.toFixed(1)}, 70%, ${60 + Math.random() * 15}%, 0.18)`);
      nebula.addColorStop(0.7, `hsla(${hue.toFixed(1)}, 60%, 20%, 0.06)`);
      nebula.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = nebula;
      ctx.beginPath();
      ctx.arc(nx, ny, radius, 0, Math.PI * 2);
      ctx.fill();
    }
    // Estrelas em múltiplas camadas
    const starLayers: Array<{ count: number; size: [number, number]; alpha: [number, number] }> = [
      { count: 800, size: [2.2, 3.6], alpha: [0.7, 1] },
      { count: 2200, size: [0.8, 1.8], alpha: [0.4, 0.8] },
      { count: 1200, size: [0.3, 0.9], alpha: [0.2, 0.5] },
    ];
    for (const layer of starLayers) {
      for (let i = 0; i < layer.count; i++) {
        const x = Math.random() * texSize;
        const y = Math.random() * texSize;
        const r = layer.size[0] + Math.random() * (layer.size[1] - layer.size[0]);
        const alpha = layer.alpha[0] + Math.random() * (layer.alpha[1] - layer.alpha[0]);
        const hueChance = Math.random();
        let color = `rgba(230,235,255,${alpha.toFixed(3)})`;
        if (hueChance < 0.12) {
          const hue = 200 + Math.random() * 30;
          color = `hsla(${hue}, 70%, ${65 + Math.random() * 20}%, ${alpha.toFixed(3)})`;
        } else if (hueChance > 0.94) {
          const warmth = 30 + Math.random() * 10;
          color = `hsla(${warmth}, 80%, ${70 + Math.random() * 15}%, ${alpha.toFixed(3)})`;
        }
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
        if (Math.random() < 0.1) {
          ctx.save();
          ctx.globalAlpha = alpha * 0.25;
          ctx.beginPath();
          ctx.arc(x, y, r * 3.2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }
    }
    dt.update(false);
    const mat = new StandardMaterial('skyMat', this.scene);
    mat.backFaceCulling = false;
    mat.disableLighting = true;
    // Use both diffuse and emissive to guarantee visibility
    (mat as any).diffuseTexture = dt as unknown as Texture;
    mat.emissiveTexture = dt as unknown as Texture;
    mat.specularColor = new Color3(0, 0, 0);
    mat.ambientColor = new Color3(0, 0, 0);
    (sky as any).material = mat;
    (sky as any).isPickable = false;
    (sky as any).applyFog = false;
    (sky as any).infiniteDistance = true;
    this.starfield = sky as any;
    this.scene.registerBeforeRender(() => {
      if (this.starfield) {
        this.starfield.rotation.y += 0.00001;
      }
    });
  }

  private createSpaceDust() {
    // subtle particles travelling with the camera to sugerir volume ao redor
    this.dustEmitter = MeshBuilder.CreateSphere('dustEmitter', { diameter: 0.1 }, this.scene);
    this.dustEmitter.parent = this.fpCamera;
    this.dustEmitter.position.set(0, 0, 0);
    this.dustEmitter.isPickable = false;
    this.dustEmitter.isVisible = false;
    this.dustEmitter.doNotSyncBoundingInfo = true;

    const ps = new ParticleSystem('spaceDust', 2400, this.scene);
    const size = 32;
    const dot = new DynamicTexture('dustDot', { width: size, height: size }, this.scene, true);
    const ctx = dot.getContext();
    ctx.clearRect(0, 0, size, size);
    const grad = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
    grad.addColorStop(0, 'rgba(255,255,255,0.95)');
    grad.addColorStop(0.45, 'rgba(200,220,255,0.6)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, size, size);
    dot.update(false);

    ps.particleTexture = dot as unknown as Texture;
    ps.emitter = this.dustEmitter;
    ps.minEmitBox = Vector3.Zero();
    ps.maxEmitBox = Vector3.Zero();
    ps.minSize = 0.08;
    ps.maxSize = 0.35;
    ps.minLifeTime = 32;
    ps.maxLifeTime = 56;
    ps.emitRate = 140;
    ps.minEmitPower = 0.006;
    ps.maxEmitPower = 0.02;
    ps.minAngularSpeed = -0.15;
    ps.maxAngularSpeed = 0.15;
    ps.direction1 = new Vector3(-0.02, -0.004, 0.02);
    ps.direction2 = new Vector3(0.02, 0.004, -0.02);
    ps.color1 = new Color4(1, 1, 1, 0.08);
    ps.color2 = new Color4(0.75, 0.85, 1, 0.05);
    ps.colorDead = new Color4(0.45, 0.6, 1, 0.01);
    ps.blendMode = ParticleSystem.BLENDMODE_ADD;
    ps.gravity = Vector3.Zero();
    ps.updateSpeed = 0.004;
    const minRadius = 220;
    const maxRadius = 460;
    const verticalRange = 140;
    ps.startPositionFunction = (_, position) => {
      const theta = Scalar.RandomRange(0, Math.PI * 2);
      const radiusFactor = 1 - Math.pow(Math.random(), 3.2);
      const radius = minRadius + radiusFactor * (maxRadius - minRadius);
      const verticalBias = Scalar.RandomRange(-0.55, 0.55);
      position.copyFromFloats(
        Math.cos(theta) * radius,
        verticalBias * verticalRange * (0.6 + radiusFactor * 0.4),
        Math.sin(theta) * radius
      );
    };
    ps.startDirectionFunction = (_, direction) => {
      direction.copyFromFloats(
        Scalar.RandomRange(-0.012, 0.012),
        Scalar.RandomRange(-0.006, 0.006),
        Scalar.RandomRange(-0.012, 0.012)
      );
    };

    ps.start();
    this.dustSystem = ps;
    let t = 0;
    this.scene.registerBeforeRender(() => {
      if (!this.dustEmitter) return;
      t += this.scene.getEngine().getDeltaTime() * 0.00004;
      const sway = 18;
      this.dustEmitter.position.x = Math.sin(t) * sway;
      this.dustEmitter.position.y = Math.sin(t * 1.6) * 5;
      this.dustEmitter.position.z = Math.cos(t * 1.1) * sway;
    });
  }

  private createShipInterior() {
    const roomHeight = 4.6;
    const roomWidth = 16;
    const roomDepth = 24;
    const wallThickness = 0.5;

    const floor = MeshBuilder.CreateGround('shipFloor', { width: roomWidth, height: roomDepth }, this.scene);
    floor.position.y = 0;
    floor.checkCollisions = true;
    const floorTex = new DynamicTexture('shipFloorTex', { width: 512, height: 512 }, this.scene, true);
    const fctx = floorTex.getContext();
    fctx.fillStyle = '#0a101a';
    fctx.fillRect(0, 0, 512, 512);
    fctx.strokeStyle = 'rgba(60,100,160,0.3)';
    fctx.lineWidth = 2;
    const gridX = 8;
    const gridY = 12;
    for (let i = 0; i <= gridX; i += 1) {
      const x = (512 / gridX) * i;
      fctx.beginPath();
      fctx.moveTo(x, 0);
      fctx.lineTo(x, 512);
      fctx.stroke();
    }
    for (let i = 0; i <= gridY; i += 1) {
      const y = (512 / gridY) * i;
      fctx.beginPath();
      fctx.moveTo(0, y);
      fctx.lineTo(512, y);
      fctx.stroke();
    }
    floorTex.update(false);
    const floorMat = new StandardMaterial('shipFloorMat', this.scene);
    floorMat.diffuseTexture = floorTex as unknown as Texture;
    floorMat.specularColor = new Color3(0.12, 0.16, 0.22);
    floorMat.emissiveColor = new Color3(0.01, 0.015, 0.02);
    floor.material = floorMat;

    const ceiling = MeshBuilder.CreateGround('shipCeiling', { width: roomWidth, height: roomDepth }, this.scene);
    ceiling.position = new Vector3(0, roomHeight, 0);
    ceiling.rotation.x = Math.PI;
    ceiling.checkCollisions = true;
    const ceilingMat = new StandardMaterial('shipCeilingMat', this.scene);
    ceilingMat.diffuseColor = new Color3(0.07, 0.09, 0.14);
    ceilingMat.specularColor = new Color3(0.12, 0.16, 0.2);
    ceilingMat.emissiveColor = new Color3(0.008, 0.012, 0.02);
    ceiling.material = ceilingMat;

    const wallMat = new StandardMaterial('shipWallMat', this.scene);
    wallMat.diffuseColor = new Color3(0.05, 0.07, 0.1);
    wallMat.specularColor = new Color3(0.12, 0.16, 0.22);
    wallMat.emissiveColor = new Color3(0.008, 0.012, 0.018);

    const makeWall = (name: string, opts: { width: number; height: number; depth: number }, position: Vector3) => {
      const wall = MeshBuilder.CreateBox(name, opts, this.scene);
      wall.position = position;
      wall.material = wallMat;
      wall.checkCollisions = true;
      wall.isPickable = false;
      return wall;
    };
    makeWall('wallNorth', { width: roomWidth, height: roomHeight, depth: wallThickness }, new Vector3(0, roomHeight / 2, -roomDepth / 2));
    makeWall('wallEast', { width: wallThickness, height: roomHeight, depth: roomDepth }, new Vector3(roomWidth / 2, roomHeight / 2, 0));
    makeWall('wallWest', { width: wallThickness, height: roomHeight, depth: roomDepth }, new Vector3(-roomWidth / 2, roomHeight / 2, 0));

    const frameColor = new Color3(0.18, 0.28, 0.42);
    const windowWidth = 8;
    const frameSideWidth = (roomWidth - windowWidth) / 2;
    const sillHeight = 1.0;
    const headerHeight = 0.8;
    const glassInset = roomDepth / 2 - 0.12;
    const frameMat = new StandardMaterial('windowFrameMat', this.scene);
    frameMat.diffuseColor = frameColor.clone();
    frameMat.specularColor = new Color3(0.2, 0.28, 0.4);
    frameMat.emissiveColor = frameColor.scale(0.12);

    const makeFrame = (name: string, size: { width: number; height: number; depth: number }, position: Vector3) => {
      const frame = MeshBuilder.CreateBox(name, size, this.scene);
      frame.position = position;
      frame.material = frameMat;
      frame.checkCollisions = true;
      frame.isPickable = false;
      return frame;
    };

    const southZ = roomDepth / 2;
    makeFrame('windowFrameLeft', { width: frameSideWidth, height: roomHeight, depth: wallThickness }, new Vector3(-(windowWidth / 2 + frameSideWidth / 2), roomHeight / 2, southZ));
    makeFrame('windowFrameRight', { width: frameSideWidth, height: roomHeight, depth: wallThickness }, new Vector3(windowWidth / 2 + frameSideWidth / 2, roomHeight / 2, southZ));
    makeFrame('windowHeader', { width: windowWidth, height: headerHeight, depth: wallThickness }, new Vector3(0, roomHeight - headerHeight / 2, southZ));
    makeFrame('windowSill', { width: windowWidth, height: sillHeight, depth: wallThickness }, new Vector3(0, sillHeight / 2, southZ));

    const glassHeight = roomHeight - headerHeight - sillHeight;
    const glass = MeshBuilder.CreatePlane('windowGlass', { width: windowWidth, height: glassHeight, sideOrientation: Mesh.DOUBLESIDE }, this.scene);
    glass.position = new Vector3(0, sillHeight + glassHeight / 2, glassInset);
    const glassMat = new StandardMaterial('windowGlassMat', this.scene);
    glassMat.diffuseColor = new Color3(0.3, 0.55, 0.9);
    glassMat.alpha = 0.32;
    glassMat.specularColor = new Color3(0.5, 0.7, 0.9);
    glassMat.emissiveColor = new Color3(0.18, 0.32, 0.48);
    glassMat.backFaceCulling = false;
    glass.material = glassMat;
    glass.checkCollisions = true;

    const rimLight = new PointLight('windowRimLight', new Vector3(0, roomHeight - 0.4, southZ - 1.2), this.scene);
    rimLight.diffuse = new Color3(0.35, 0.55, 0.9);
    rimLight.specular = rimLight.diffuse.clone();
    rimLight.intensity = 0.55;
    rimLight.range = 12;

    const mezzanine = MeshBuilder.CreateBox('shipDeck', { width: 12, height: 0.4, depth: 8 }, this.scene);
    mezzanine.position = new Vector3(0, 0.2, -7);
    mezzanine.checkCollisions = true;
    const mezzMat = new StandardMaterial('shipDeckMat', this.scene);
    mezzMat.diffuseColor = new Color3(0.08, 0.11, 0.17);
    mezzMat.specularColor = new Color3(0.14, 0.18, 0.24);
    mezzMat.emissiveColor = new Color3(0.015, 0.02, 0.03);
    mezzanine.material = mezzMat;

    const stripMat = new StandardMaterial('shipStrip', this.scene);
    stripMat.diffuseColor = new Color3(0.2, 0.4, 0.8);
    stripMat.emissiveColor = new Color3(0.08, 0.18, 0.35);
    stripMat.specularColor = new Color3(0.1, 0.16, 0.28);
    const stripL = MeshBuilder.CreateBox('stripL', { width: 0.2, height: 0.2, depth: 10 }, this.scene);
    stripL.position = new Vector3(-7.6, 4.2, -2);
    stripL.material = stripMat;
    stripL.isPickable = false;
    const stripR = MeshBuilder.CreateBox('stripR', { width: 0.2, height: 0.2, depth: 10 }, this.scene);
    stripR.position = new Vector3(7.6, 4.2, -2);
    stripR.material = stripMat;
    stripR.isPickable = false;

    this.addTerminal(
      'engineering',
      new Vector3(-4.6, 1.1, -6.5),
      Math.PI / 8,
      {
        label: 'Terminal de Engenharia',
        hint: 'acessar HAL e varrer asteroides',
        description: 'Computador HAL-9001 integrado aos sensores de mineração.',
        color: new Color3(0.35, 0.65, 1),
      }
    );
    this.addTerminal(
      'construction',
      new Vector3(4.6, 1.1, -6.5),
      -Math.PI / 8,
      {
        label: 'Terminal de Construção',
        hint: 'planejar novos módulos',
        description: 'Interface de drones de construção — módulo em atualização.',
        color: new Color3(0.65, 0.45, 1),
      }
    );

    const glow = new GlowLayer('interiorGlow', this.scene);
    glow.intensity = 0.35;

    this.scene.registerBeforeRender(() => {
      this.updateTerminalLogic();
    });

    this.scene.onKeyboardObservable.add((kbInfo) => {
      if (kbInfo.type === KeyboardEventTypes.KEYDOWN) {
        const key = kbInfo.event.key.toLowerCase();
        if (key === 'e' && !this.inputPaused && !this.activeTerminalId && this.nearbyTerminal) {
          this.beginTerminalInteraction(this.nearbyTerminal);
        }
      }
    });
  }

  private addTerminal(id: TerminalId, origin: Vector3, rotationY: number, opts: { label: string; hint: string; description?: string; color: Color3 }) {
    const base = MeshBuilder.CreateBox(`terminalBase:${id}`, { width: 1.4, height: 1.4, depth: 0.6 }, this.scene);
    base.position = origin.clone();
    base.rotation.y = rotationY;
    base.checkCollisions = true;
    const baseMat = new StandardMaterial(`terminalBaseMat:${id}`, this.scene);
    baseMat.diffuseColor = new Color3(0.08, 0.12, 0.18);
    baseMat.specularColor = opts.color.scale(0.2);
    baseMat.emissiveColor = opts.color.scale(0.08);
    base.material = baseMat;

    const screen = MeshBuilder.CreatePlane(`terminalScreen:${id}`, { width: 1.1, height: 1 }, this.scene);
    screen.parent = base;
    screen.position = new Vector3(0, 0.35, -0.33);
    screen.rotation.x = 0.08;
    const tex = new DynamicTexture(`terminalTex:${id}`, { width: 512, height: 512 }, this.scene, true);
    const ctx = tex.getContext();
    ctx.fillStyle = 'rgba(10,18,32,0.92)';
    ctx.fillRect(0, 0, 512, 512);
    const grad = ctx.createLinearGradient(0, 0, 512, 512);
    grad.addColorStop(0, `rgba(${(opts.color.r * 255).toFixed(0)},${(opts.color.g * 255).toFixed(0)},${(opts.color.b * 255).toFixed(0)},0.5)`);
    grad.addColorStop(1, `rgba(${(opts.color.r * 255).toFixed(0)},${(opts.color.g * 255).toFixed(0)},${(opts.color.b * 255).toFixed(0)},0.1)`);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 512, 512);
    ctx.fillStyle = '#dce9ff';
    ctx.font = 'bold 38px system-ui';
    ctx.fillText(opts.label, 28, 82);
    ctx.font = '22px system-ui';
    ctx.fillText(`• ${opts.hint}`, 28, 150);
    ctx.fillText('Pressione [E] para interagir', 28, 196);
    tex.update(false);
    const screenMat = new StandardMaterial(`terminalScreenMat:${id}`, this.scene);
    screenMat.disableLighting = true;
    screenMat.diffuseTexture = tex as unknown as Texture;
    screenMat.emissiveTexture = tex as unknown as Texture;
    screenMat.opacityTexture = tex as unknown as Texture;
    screenMat.emissiveColor = opts.color.scale(0.8);
    screen.material = screenMat;

    const light = new PointLight(`terminalLight:${id}`, origin.add(new Vector3(0, 1.6, -0.8)), this.scene);
    light.diffuse = opts.color.clone();
    light.specular = opts.color.clone();
    light.intensity = 0.5;
    light.range = 8.5;

    this.terminals.push({
      id,
      label: opts.label,
      hint: opts.hint,
      description: opts.description,
      mesh: base,
      screen,
      interactDistance: 2.8,
      idleColor: opts.color.scale(0.35),
      activeColor: opts.color.scale(1.25),
      light,
    });
  }

  private toTerminalInfo(term: TerminalInstance): TerminalInfo {
    return { id: term.id, label: term.label, hint: term.hint, description: term.description };
  }

  private updateTerminalLogic() {
    for (const term of this.terminals) {
      const screenMat = term.screen.material as StandardMaterial | null;
      if (screenMat) {
        const distance = Vector3.Distance(term.mesh.getAbsolutePosition(), this.fpCamera.position);
        const factor = Math.max(0.2, Math.min(1, 1 - distance / term.interactDistance));
        const emissive = term.idleColor.scale(0.4).add(term.activeColor.scale(factor * 0.6));
        screenMat.emissiveColor = emissive;
      }
      if (term.light) {
        const distance = Vector3.Distance(term.mesh.getAbsolutePosition(), this.fpCamera.position);
        const factor = Math.max(0.25, Math.min(1, 1 - distance / term.interactDistance));
        term.light.intensity = 0.3 + factor * 0.55;
      }
    }

    if (this.inputPaused || this.activeTerminalId) {
      this.setNearbyTerminal(null);
      return;
    }

    let best: TerminalInstance | null = null;
    let bestDistance = Number.POSITIVE_INFINITY;
    const camPos = this.fpCamera.position;
    for (const term of this.terminals) {
      const distance = Vector3.Distance(term.mesh.getAbsolutePosition(), camPos);
      if (distance < term.interactDistance && distance < bestDistance) {
        best = term;
        bestDistance = distance;
      }
    }
    this.setNearbyTerminal(best);
  }

  private setNearbyTerminal(term: TerminalInstance | null) {
    if (this.nearbyTerminal === term) return;
    if (term) {
      this.options.onTerminalProximity?.(this.toTerminalInfo(term));
    } else if (this.nearbyTerminal) {
      this.options.onTerminalProximity?.(null);
    }
    this.nearbyTerminal = term;
  }

  private beginTerminalInteraction(term: TerminalInstance) {
    if (this.activeTerminalId) return;
    this.activeTerminalId = term.id;
    this.setNearbyTerminal(null);
    this.setInputPaused(true);
    this.options.onTerminalInteract?.(this.toTerminalInfo(term));
  }

  setInputPaused(paused: boolean) {
    this.inputPaused = paused;
    if (paused) {
      this.fpCamera.detachControl();
      if (document.pointerLockElement === this.canvas) {
        document.exitPointerLock();
      }
    } else {
      this.fpCamera.attachControl(this.canvas, true);
      const fpMouse = (this.fpCamera.inputs.attached as any)?.mouse;
      if (fpMouse) fpMouse.usePointerLock = true;
    }
  }

  closeTerminalInteraction() {
    this.activeTerminalId = null;
    this.setNearbyTerminal(null);
    this.setInputPaused(false);
  }

  private createDistantStars() {
    const count = 28;
    const minDistance = Math.max(5400, this.world.bounds * 3.0);
    const maxDistance = Math.max(9000, this.world.bounds * 4.1);
    const baseColor = new Color3(0.55, 0.82, 1.2);
    const spriteSize = 128;
    const starTexture = new DynamicTexture('distantStarSprite', { width: spriteSize, height: spriteSize }, this.scene, true);
    const starCtx = starTexture.getContext();
    starCtx.clearRect(0, 0, spriteSize, spriteSize);
    const starGrad = starCtx.createRadialGradient(spriteSize / 2, spriteSize / 2, 0, spriteSize / 2, spriteSize / 2, spriteSize / 2);
    starGrad.addColorStop(0, 'rgba(255,255,255,1)');
    starGrad.addColorStop(0.35, 'rgba(160,200,255,0.9)');
    starGrad.addColorStop(0.7, 'rgba(90,140,255,0.35)');
    starGrad.addColorStop(1, 'rgba(0,0,0,0)');
    starCtx.fillStyle = starGrad;
    starCtx.fillRect(0, 0, spriteSize, spriteSize);
    starTexture.update(false);
    for (let i = 0; i < count; i += 1) {
      const size = Scalar.RandomRange(28, 56);
      const star = MeshBuilder.CreatePlane(`distantStar:${i}`, { width: size, height: size }, this.scene);
      star.billboardMode = Mesh.BILLBOARDMODE_ALL;
      const dir = new Vector3(Scalar.RandomRange(-1, 1), Scalar.RandomRange(-0.35, 0.5), Scalar.RandomRange(-1, 1));
      if (dir.lengthSquared() < 0.001) {
        dir.set(0.3, 0.25, -0.2);
      }
      dir.normalize();
      const distance = Scalar.RandomRange(minDistance, maxDistance);
      star.position.copyFrom(dir.scale(distance));
      const mat = new StandardMaterial(`distantStarMat:${i}`, this.scene);
      mat.disableLighting = true;
      mat.backFaceCulling = false;
      mat.diffuseTexture = starTexture as unknown as Texture;
      mat.emissiveTexture = starTexture as unknown as Texture;
      mat.opacityTexture = starTexture as unknown as Texture;
      (mat as any).useAlphaFromDiffuseTexture = true;
      mat.alphaMode = Engine.ALPHA_ADD;
      const intensity = Scalar.RandomRange(2.4, 3.8);
      mat.emissiveColor = baseColor.scale(intensity);
      mat.diffuseColor = Color3.Black();
      star.material = mat;
      star.isPickable = false;
      (star as any).applyFog = false;
      (star as any).infiniteDistance = true;
      const amplitude = Scalar.RandomRange(0.35, 0.6);
      const speed = Scalar.RandomRange(0.45, 1.1);
      const phase = Scalar.RandomRange(0, Math.PI * 2);
      this.distantStars.push({
        material: mat,
        base: intensity,
        amplitude,
        speed,
        phase,
        color: baseColor.scale(Scalar.RandomRange(0.95, 1.25)),
      });
    }

    if (this.distantStars.length > 0) {
      let flickerTime = 0;
      this.scene.registerBeforeRender(() => {
        const delta = this.scene.getEngine().getDeltaTime() * 0.001;
        flickerTime += delta;
        for (const star of this.distantStars) {
          const intensity = star.base + Math.sin(flickerTime * star.speed + star.phase) * star.amplitude;
          star.material.emissiveColor = star.color.scale(Math.max(0.2, intensity));
        }
      });
    }
  }

  private createSun() {
    const size = Math.max(600, this.world.bounds * 0.1);
    const sun = MeshBuilder.CreateSphere('sun', { diameter: size }, this.scene);
    const dist = Math.max(3000, this.world.bounds * 2.0);
    sun.position = new Vector3(dist, size, -dist * 0.85);
    const mat = new StandardMaterial('sunMat', this.scene);
    mat.emissiveColor = new Color3(1.0, 0.9, 0.7);
    mat.disableLighting = true;
    sun.material = mat;
    const glow = new GlowLayer('glow', this.scene);
    glow.intensity = 0.6;
    const light = new PointLight('sunLight', sun.position, this.scene);
    light.intensity = 0.7;
    light.range = 10000;
    (sun as any).applyFog = false;
    this.sun = sun;
  }

  private createSectorLabels() {
    // Cluster labels
    for (const c of this.world.clusters) {
      const text = `${c.id} (${c.type})`;
      const m = this.makeLabelMesh(`lbl:${c.id}`, text, new Color3(0.6, 0.8, 1));
      m.position = new Vector3(c.center.x, (c.center.y || 0) + 120, c.center.z);
      this.labelMeshes.push(m);
    }
    // Sun label (if exists)
    if (this.sun) {
      const m = this.makeLabelMesh('lbl:sun', 'Star', new Color3(1, 0.9, 0.6));
      m.position = this.sun.position.add(new Vector3(0, 800, 0));
      this.labelMeshes.push(m);
    }
  }

  private makeLabelMesh(id: string, text: string, color: Color3) {
    const dt = new DynamicTexture(`dt:${id}`, { width: 256, height: 64 }, this.scene, true);
    const ctx = dt.getContext();
    ctx.clearRect(0, 0, 256, 64);
    ctx.fillStyle = 'rgba(13,19,36,0.7)';
    ctx.fillRect(0, 0, 256, 64);
    ctx.strokeStyle = 'rgba(36,52,90,0.9)';
    ctx.strokeRect(0.5, 0.5, 255, 63);
    ctx.fillStyle = '#d3e0ff';
    ctx.font = 'bold 22px system-ui';
    ctx.fillText(text, 10, 40);
    dt.update(true);
    const plane = MeshBuilder.CreatePlane(id, { width: 22, height: 5.5 }, this.scene);
    const mat = new StandardMaterial(`mat:${id}`, this.scene);
    mat.disableLighting = true;
    mat.emissiveTexture = dt as unknown as Texture;
    mat.backFaceCulling = false;
    plane.material = mat;
    plane.billboardMode = Mesh.BILLBOARDMODE_ALL;
    (plane as any).isPickable = false;
    return plane;
  }

  private tryLoad(): boolean {
    try {
      const raw = localStorage.getItem('starwatch.v020.save');
      if (!raw) return false;
      const data = JSON.parse(raw);
      this.world = generateSector(data.world.seed);
      this.configureScaleFromWorld();
      // restore asteroid amounts
      const byId = new Map<string, number>(Object.entries(data.world.asteroidAmounts || {}));
      for (const a of this.world.asteroids) {
        const amt = byId.get(a.id);
        if (typeof amt === 'number') a.amount = amt;
      }
      // scanned
      this.scanned = new Set<string>(data.scanned || []);
      // inventory
      this.inventory = data.inventory || this.inventory;
      // ship
      if (data.ship?.position) {
        this.ship.mesh = this.ship.mesh || ({} as any);
        const p = data.ship.position;
        // ship mesh may not be created yet; we set after spawn by returning true
        setTimeout(() => {
          this.ship.mesh.position.set(p.x, p.y, p.z);
        }, 0);
      }
      if (data.ship?.destination) this.ship.destination = new Vector3(data.ship.destination.x, data.ship.destination.y, data.ship.destination.z);
      return true;
    } catch (e) {
      console.warn('Load failed, starting new', e);
      return false;
    }
  }

  private save() {
    try {
      const asteroidAmounts: Record<string, number> = {};
      for (const a of this.world.asteroids) asteroidAmounts[a.id] = a.amount;
      const data = {
        world: { seed: this.world.seed, asteroidAmounts },
        scanned: Array.from(this.scanned),
        inventory: this.inventory,
        ship: {
          position: { x: this.ship.mesh.position.x, y: this.ship.mesh.position.y, z: this.ship.mesh.position.z },
          destination: this.ship.destination ? { x: this.ship.destination.x, y: this.ship.destination.y, z: this.ship.destination.z } : null,
        },
      };
      localStorage.setItem('starwatch.v020.save', JSON.stringify(data));
    } catch (e) {
      console.warn('Save failed', e);
    }
  }

  private configureScaleFromWorld() {
    // Define velocidade da nave para atravessar o diâmetro do setor em ~30min
    // speed = (2*bounds) / (30*60)
    this.ship.maxSpeed = (2 * this.world.bounds) / 1800;
    // Ajusta limites de câmera e neblina proporcionalmente
    this.camera.upperRadiusLimit = Math.max(1000, this.world.bounds * 2.5);
    (this.scene as any).fogStart = Math.max(2500, this.world.bounds * 0.6);
    (this.scene as any).fogEnd = Math.max(9000, this.world.bounds * 2.0);
    // Raio de scanner relativo ao tamanho
    this.scanRadius = Math.max(800, Math.min(5000, Math.floor(this.world.bounds * 0.18)));
  }
}

declare global {
  // Worker script globals (type-only exposure for TS consumers)
  interface WorkerGlobalScope {
    Game: {
      moveTo(v: Vec3): Promise<void>;
      performScan(): Promise<string[]>;
      scanSector(filter?: { resource?: ResourceType; limit?: number }): Promise<any[]>;
      startMining(resource: ResourceType): Promise<{ ok: boolean; error?: string }>;
      stopMining(): Promise<{ ok: boolean }>;
      getMiningStatus(): Promise<any>;
      getShipStatus(): Promise<any>;
      getResources(): Promise<{ iron: number; silicon: number; uranium: number }>;
    };
    Memory: { set(k: string, v: unknown): void; get(k: string): unknown };
    sleep(ms: number): Promise<void>;
  }
}
</file>

<file path="src/legacy/game/world.ts">
import { Vector3 } from 'babylonjs';

export type ResourceType = 'iron' | 'silicon' | 'uranium';

export type ClusterDef = {
  id: string;
  type: ResourceType; // dominant resource
  center: { x: number; y: number; z: number };
  radius: number; // cluster radius (km)
};

export type AsteroidDef = {
  id: string;
  position: { x: number; y: number; z: number };
  radius: number; // visual size (km)
  resource: ResourceType;
  amount: number; // resource remaining (tons)
  clusterId?: string;
};

export type Sector = {
  id: string;
  name: string;
  seed: number;
  bounds: number; // roughly the play radius from origin (km)
  clusters: ClusterDef[];
  asteroids: AsteroidDef[];
};

// Simple seeded PRNG (mulberry32)
function mulberry32(a: number) {
  return function () {
    let t = (a += 0x6d2b79f5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function pick<T>(rng: () => number, items: T[]): T {
  return items[Math.floor(rng() * items.length) % items.length];
}

function weightedPick<T>(rng: () => number, items: { v: T; w: number }[]): T {
  const total = items.reduce((a, b) => a + b.w, 0);
  let r = rng() * total;
  for (const it of items) {
    r -= it.w;
    if (r <= 0) return it.v;
  }
  return items[items.length - 1]!.v;
}

function nameFromSeed(seed: number): string {
  const prefixes = ['Elysion', 'Kepler', 'Tethys', 'Aquila', 'Cygnus', 'Hydra', 'Vela', 'Altair', 'Draco'];
  const suffixes = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'];
  const rng = mulberry32(seed);
  const p = pick(rng, prefixes);
  const s = pick(rng, suffixes);
  const n = Math.floor(rng() * 900 + 100);
  return `${p}-${n}-${s}`;
}

export function generateSector(seed = Math.floor(Math.random() * 2 ** 31)): Sector {
  const rng = mulberry32(seed);
  // Setor significativamente maior; escala de base ~6000 km de raio
  const bounds = 6000; // overall sector radius

  // Generate a few clusters
  // Mais clusters, distribuídos pelo setor
  const clustersCount = Math.floor(rng() * 5) + 7; // 7..11
  const clusters: ClusterDef[] = [];
  const resourceBias: ResourceType[] = ['iron', 'silicon', 'uranium'];

  for (let i = 0; i < clustersCount; i++) {
    const angle = rng() * Math.PI * 2;
    const dist = (0.28 + rng() * 0.66) * bounds; // not too close to center
    const x = Math.cos(angle) * dist;
    const z = Math.sin(angle) * dist;
    // vertical layering by type
    const type = resourceBias[i % resourceBias.length]!;
    let yCenter = 0;
    if (type === 'iron') yCenter = (rng() - 0.5) * 400; // around midplane
    if (type === 'silicon') yCenter = 300 + rng() * 500; // upper layers
    if (type === 'uranium') yCenter = -450 - rng() * 600; // deeper layers
    const r = 350 + rng() * 550; // cluster radius maior
    clusters.push({ id: `cl-${i}`, type, center: { x, y: yCenter, z }, radius: r });
  }

  const asteroids: AsteroidDef[] = [];

  // Distribute asteroids: background sparse + clusters dense
  const backgroundCount = 140 + Math.floor(rng() * 80); // 140..220
  for (let i = 0; i < backgroundCount; i++) {
    const angle = rng() * Math.PI * 2;
    const dist = rng() * bounds;
    const x = Math.cos(angle) * dist;
    const z = Math.sin(angle) * dist;
    const y = (rng() - 0.5) * 1400; // spread in height
    const radius = 2 + rng() * 5;
    const resource = weightedPick(rng, [
      { v: 'iron' as const, w: 6 },
      { v: 'silicon' as const, w: 3 },
      { v: 'uranium' as const, w: 1 },
    ]);
    const amount = Math.round((15 + rng() * 35) * radius); // scaled by size
    asteroids.push({ id: `bg-${i}`, position: { x, y, z }, radius, resource, amount });
  }

  // Clustered asteroids
  let aid = 0;
  for (const c of clusters) {
    const count = 35 + Math.floor(rng() * 45); // 35..80 per cluster
    for (let i = 0; i < count; i++) {
      // random in circle
      const a = rng() * Math.PI * 2;
      const d = Math.sqrt(rng()) * c.radius; // sqrt for uniform distribution within circle
      const x = c.center.x + Math.cos(a) * d;
      const z = c.center.z + Math.sin(a) * d;
      // vertical distribution per type
      let y = c.center.y;
      const thickness = c.type === 'iron' ? 180 : c.type === 'silicon' ? 300 : 380;
      y += (rng() - 0.5) * thickness;
      const radius = 3 + rng() * 9;
      const resource = weightedPick(rng, [
        { v: c.type, w: 8 },
        { v: 'iron' as const, w: c.type === 'iron' ? 4 : 2 },
        { v: 'silicon' as const, w: c.type === 'silicon' ? 4 : 2 },
        { v: 'uranium' as const, w: c.type === 'uranium' ? 3 : 1 },
      ]);
      const amount = Math.round((30 + rng() * 70) * radius);
      asteroids.push({ id: `a-${aid++}`, position: { x, y, z }, radius, resource, amount, clusterId: c.id });
    }
  }

  // Center clearing (some free space at origin)
  const filtered = asteroids.filter((a) => new Vector3(a.position.x, 0, a.position.z).length() > 120);

  return {
    id: `S-${seed.toString(16)}`,
    name: nameFromSeed(seed),
    seed,
    bounds,
    clusters,
    asteroids: filtered,
  };
}
</file>

<file path="src/legacy/hal/halLLM.ts">
import { generateObject, generateText } from 'ai';
import { createOpenAI } from '@ai-sdk/openai';
import { z } from 'zod';

export type BridgeTools = {
  moveTo: (v: { x: number; y: number; z: number }) => Promise<{ ok: boolean }>;
  getShipStatus: () => Promise<any>;
  getSectorInfo: () => Promise<any>;
  scanSector: (filter?: { resource?: 'iron' | 'silicon' | 'uranium'; limit?: number }) => Promise<any[]>;
  getResources: () => Promise<{ iron: number; silicon: number; uranium: number }>;
  startMining: (resource: 'iron' | 'silicon' | 'uranium') => Promise<{ ok: boolean; error?: string; targetId?: string }>;
  stopMining: () => Promise<{ ok: boolean }>;
  // Script Library base tools (CRUD + run by name)
  listScripts: () => Promise<Array<{ name: string; description: string; lastModified: string }>>;
  getScriptCode: (name: string) => Promise<string | null>;
  createScriptRaw: (name: string, code: string, description?: string) => Promise<{ ok: boolean; error?: string }>;
  updateScriptRaw: (name: string, newCode: string) => Promise<{ ok: boolean; error?: string }>;
  deleteScript: (name: string) => Promise<{ ok: boolean; error?: string }>;
  runScript: (name: string) => Promise<{ ok: boolean; error?: string }>;
  performScan: () => Promise<string[]>; // returns newly discovered ids
  getMiningStatus: () => Promise<any>;
};

export type ChatMessage = { role: 'user' | 'assistant' | 'tool'; content: string; meta?: any };

export type HalConfig = {
  apiKey?: string;
  model?: string; // e.g., 'gpt-4o-mini' | 'gpt-4o' | 'o3-mini'
};

export class HalLLM {
  private history: ChatMessage[] = [];
  private systemPrompt = `Você é HAL-9001, a IA de bordo. Estilo: calmo, lógico, subserviente, levemente curioso.
Seu objetivo é auxiliar o Comandante a operar a nave e automatizar tarefas.
Interprete o pedido do Comandante e preencha um objeto de intenção com:
- say: sua resposta narrativa em português, como HAL.
- call: apenas se necessário, uma chamada de ação { name, input }.
As ações disponíveis são:
- move { x,y,z }
- ship_status {}
- scan_sector { resource?: 'iron'|'silicon'|'uranium', limit?: number }
- perform_scan {}
- mining_status {}
- get_resources {}
- start_mining { resource: 'iron'|'silicon'|'uranium' }
- stop_mining {}
- Scripts (biblioteca):
  - list_scripts {}
  - get_script_code { name }
  - delete_script { name }
  - run_script { name }
  - create_script { name, goal, description? }  // gere o código internamente
  - update_script { name, goal }                // edite o código internamente
Fluxos recomendados:
  • Criar: create_script -> (opcional) run_script { name } se pedirem para já executar.
  • Editar: get_script_code -> update_script.
  • Executar: se ambíguo, list_scripts; senão run_script { name }.
Regras de scripts: usar somente a API do worker (Game.*, Memory, sleep), sem valores fictícios ou "substitua"; o código deve ser autossuficiente.
Não invente parâmetros; infira apenas o que for pedido. Quando apropriado, explique sucintamente seu plano.`;
// Observação: para "varredura ativa" use a ação perform_scan (não use run_script). Para checar mineração, use mining_status.

  constructor(private tools: BridgeTools, private cfg: HalConfig) {}

  greeting(): ChatMessage {
    return {
      role: 'assistant',
      content:
        'Aqui é HAL-9001. Sistemas online. Suas ordens, Comandante? (Ex.: "Mova a nave para 500, 0, 250" ou "Execute patrol.js")',
    };
  }

  setConfig(cfg: Partial<HalConfig>) {
    this.cfg = { ...this.cfg, ...cfg };
  }

  getConfig(): HalConfig {
    return this.cfg;
  }

  getHistory(): ChatMessage[] {
    return this.history.slice();
  }

  async send(userText: string, defaultScriptName: string, defaultScriptCode: string): Promise<ChatMessage> {
    const provider = createOpenAI({ apiKey: this.cfg.apiKey });
    const modelId = this.cfg.model || 'gpt-4o-mini';

    const historyText = this.history
      .slice(-8)
      .map((m) => `${m.role === 'user' ? 'Comandante' : 'HAL'}: ${m.content}`)
      .join('\n');

    const intentSchema = z.object({
      say: z.string().describe('Resposta do HAL ao Comandante, em PT-BR.'),
      call: z
        .union([
          z.object({ name: z.literal('move'), input: z.object({ x: z.number(), y: z.number(), z: z.number() }) }),
          z.object({ name: z.literal('ship_status'), input: z.object({}).optional() }),
          z.object({ name: z.literal('scan_sector'), input: z.object({ resource: z.enum(['iron', 'silicon', 'uranium']).optional(), limit: z.number().optional() }).optional() }),
          z.object({ name: z.literal('perform_scan'), input: z.object({}).optional() }),
          z.object({ name: z.literal('get_resources'), input: z.object({}).optional() }),
          z.object({ name: z.literal('start_mining'), input: z.object({ resource: z.enum(['iron', 'silicon', 'uranium']) }) }),
          z.object({ name: z.literal('stop_mining'), input: z.object({}).optional() }),
          z.object({ name: z.literal('mining_status'), input: z.object({}).optional() }),
          // Library tools
          z.object({ name: z.literal('list_scripts'), input: z.object({}).optional() }),
          z.object({ name: z.literal('get_script_code'), input: z.object({ name: z.string() }) }),
          z.object({ name: z.literal('delete_script'), input: z.object({ name: z.string() }) }),
          z.object({ name: z.literal('run_script'), input: z.object({ name: z.string() }) }),
          z.object({ name: z.literal('create_script'), input: z.object({ name: z.string(), goal: z.string(), description: z.string().optional() }) }),
          z.object({ name: z.literal('update_script'), input: z.object({ name: z.string(), goal: z.string() }) }),
        ])
        .nullish(),
    });

    const prompt = [
      this.systemPrompt,
      historyText ? `Histórico recente:\n${historyText}` : '',
      `Nova entrada do Comandante: ${userText}`,
      'Retorne apenas o objeto: { say, call? }.',
    ]
      .filter(Boolean)
      .join('\n\n');

    const model: any = (provider as any)(modelId);
    const { object } = await generateObject({ model, schema: intentSchema, prompt });

    const logTool = (name: string, input: any, output: any) => {
      this.history.push({ role: 'tool', content: `tool:${name}`, meta: { name, input, output } });
    };

    const getRecentHistory = () =>
      this.history
        .slice(-5)
        .map((m) => `${m.role === 'user' ? 'Comandante' : m.role === 'assistant' ? 'HAL' : 'Tool'}: ${m.content}`)
        .join('\n');

    const generateScript = async (goal: string, currentCode?: string) => {
      const sys = `Você é HAL, gerando código JavaScript para rodar em um Web Worker do jogo.
Use exclusivamente a API exposta no worker:
- Game.moveTo({x,y,z})
- Game.performScan()
- Game.scanSector({ resource?: 'iron'|'silicon'|'uranium', limit?: number })
- Game.startMining(resource)
- Game.getMiningStatus()
- Game.stopMining()
- Game.getShipStatus(), Game.getResources()
- Memory.get/set, sleep(ms)
Sem placeholders ou comentários do tipo "substitua"; escreva lógica real que consulta o ambiente em tempo de execução.
Padrões úteis: escanear, escolher alvos próximos, laços assíncronos com await e intervalos; nunca use recursão para loops; trate erros de forma simples.
Retorne apenas o código executável (sem markdown).`;
      const recent = getRecentHistory();
      const parts = [
        sys,
        recent ? `Contexto recente:\n${recent}` : '',
        `Objetivo do script: ${goal}`,
        currentCode ? `Código atual (para atualizar):\n${currentCode}` : '',
      ].filter(Boolean);
      const t = await generateText({
        model,
        prompt: parts.join('\n\n'),
        maxSteps: 15 as any,
      });
      return t.text.trim();
    };

    if (object.call) {
      const c = object.call as any;
      if (c.name === 'move') {
        const out = await this.tools.moveTo(c.input);
        logTool('move', c.input, out);
      } else if (c.name === 'ship_status') {
        const st = await this.tools.getShipStatus();
        logTool('ship_status', {}, st);
        const extra = st
          ? ` Posição ${st.position.x.toFixed(1)}, ${st.position.y.toFixed(1)}, ${st.position.z.toFixed(1)}. Velocidade ${st.speed.toFixed(2)}.`
          : '';
        object.say = `${object.say}${extra}`.trim();
      } else if (c.name === 'scan_sector') {
        const newly = await this.tools.performScan();
        logTool('perform_scan', {}, newly);
        const list = await this.tools.scanSector(c.input);
        logTool('scan_sector', c.input || {}, list);
        const lines = list
          .map((e: any) => `• ${e.resource} @ (${e.position.x.toFixed(0)}, ${e.position.y.toFixed(0)}, ${e.position.z.toFixed(0)}) [${e.distance.toFixed(0)} km]`)
          .join('\n');
        const discovered = newly?.length ? ` Descobertas: ${newly.length}.` : '';
        if (list.length === 0) {
          const res = c.input?.resource ? ` de ${c.input.resource}` : '';
          object.say = `${object.say}${discovered} Nenhum asteroide${res} escaneado neste raio.`.trim();
        } else {
          object.say = `${object.say}${discovered}\nAlvos próximos (escaneados):\n${lines}`.trim();
        }
      } else if (c.name === 'perform_scan') {
        const newly = await this.tools.performScan();
        logTool('perform_scan', {}, newly);
        object.say = `${object.say} Varredura ativa concluída. Novos objetos: ${newly.length}.`;
      } else if (c.name === 'get_resources') {
        const r = await this.tools.getResources();
        logTool('get_resources', {}, r);
        object.say = `${object.say} Recursos: Fe=${r.iron.toFixed(1)}, Si=${r.silicon.toFixed(1)}, U=${r.uranium.toFixed(1)}.`;
      } else if (c.name === 'start_mining') {
        const res = await this.tools.startMining(c.input.resource);
        logTool('start_mining', c.input, res);
        if (res.ok) object.say = `${object.say} Engajando mineração de ${c.input.resource}. Indo para o alvo.`;
        else object.say = `${object.say} Falha ao iniciar mineração: ${res.error}`;
      } else if (c.name === 'stop_mining') {
        const out = await this.tools.stopMining();
        logTool('stop_mining', {}, out);
        object.say = `${object.say} Mineração pausada.`;
      } else if (c.name === 'mining_status') {
        const s = await this.tools.getMiningStatus();
        logTool('mining_status', {}, s);
        if (s.state === 'idle') {
          const last = s.lastEvent === 'depleted' && s.lastTarget ? ` O último alvo (${s.lastTarget.resource}) foi esgotado.` : '';
          object.say = `${object.say} A mineração não está ativa.${last}`.trim();
        } else if (s.state === 'approaching') {
          object.say = `${object.say} Rumo ao alvo (${s.resource}). Distância ${s.distance?.toFixed?.(0)} km.`;
        } else if (s.state === 'mining') {
          object.say = `${object.say} Extraindo ${s.resource}. Restante ~${s.remaining?.toFixed?.(1)} t a ${s.rate} t/s.`;
        }
      } else if (c.name === 'list_scripts') {
        const out = await this.tools.listScripts();
        logTool('list_scripts', {}, out);
        const names = out.map((s: any) => s.name).join(', ');
        object.say = `${object.say} Scripts disponíveis: ${names || 'nenhum'}.`;
      } else if (c.name === 'get_script_code') {
        const code = await this.tools.getScriptCode(c.input.name);
        logTool('get_script_code', c.input, { hasCode: !!code, length: code?.length ?? 0 });
        if (code) object.say = `${object.say}\nTrecho de ${c.input.name}:\n${code.slice(0, 400)}${code.length > 400 ? '…' : ''}`;
        else object.say = `${object.say} O script ${c.input.name} não existe.`;
      } else if (c.name === 'delete_script') {
        const out = await this.tools.deleteScript(c.input.name);
        logTool('delete_script', c.input, out);
        object.say = out.ok ? `${object.say} Script ${c.input.name} removido.` : `${object.say} Falha: ${out.error}`;
      } else if (c.name === 'run_script') {
        const name = c.input?.name || defaultScriptName;
        const out = await this.tools.runScript(name);
        logTool('run_script', { name }, out);
        if (out.ok) object.say = `${object.say} Executando ${name} agora.`;
        else object.say = `${object.say} Falha ao executar ${name}: ${out.error}`;
      } else if (c.name === 'create_script') {
        const { name, goal, description } = c.input;
        const code = await generateScript(goal);
        const out = await this.tools.createScriptRaw(name, code, description);
        logTool('create_script', { name, goal, description }, out);
        object.say = out.ok ? `${object.say} Criei ${name} na biblioteca.` : `${object.say} Falha ao criar: ${out.error}`;
      } else if (c.name === 'update_script') {
        const { name, goal } = c.input;
        const current = await this.tools.getScriptCode(name);
        if (!current) {
          object.say = `${object.say} O script ${name} não existe.`;
        } else {
          const newCode = await generateScript(goal, current);
          const out = await this.tools.updateScriptRaw(name, newCode);
          logTool('update_script', { name, goal }, out);
          object.say = out.ok ? `${object.say} Atualizei ${name} conforme solicitado.` : `${object.say} Falha ao atualizar: ${out.error}`;
        }
      }
    }

    const reply: ChatMessage = { role: 'assistant', content: object.say || 'Entendido.' };
    this.history.push({ role: 'user', content: userText });
    this.history.push(reply);
    return reply;
  }
}
</file>

<file path="src/legacy/ui/Chat.tsx">
import React, { useEffect, useRef, useState } from 'react';
import type { HalLLM, ChatMessage } from '../hal/halLLM';

type Props = {
  hal: HalLLM;
  defaultScript: string;
  onRunScript?: (name: string) => void; // kept for compatibility
};

export function Chat({ hal, defaultScript }: Props) {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [input, setInput] = useState('');
  const listRef = useRef<HTMLDivElement | null>(null);

  useEffect(() => {
    setMessages((prev) => (prev.length === 0 ? [hal.greeting()] : prev));
  }, [hal]);

  useEffect(() => {
    listRef.current?.scrollTo({ top: listRef.current.scrollHeight });
  }, [messages]);

  const send = async () => {
    const text = input.trim();
    if (!text) return;
    setInput('');
    // Otimista: mostra já a fala do usuário
    setMessages((m) => [...m, { role: 'user', content: text }]);
    try {
      const reply = await hal.send(text, 'patrol.js', defaultScript);
      // Substitui pelo histórico real do HAL (inclui tool cards)
      setMessages(hal.getHistory());
    } catch (e) {
      setMessages((m) => [
        ...m,
        { role: 'assistant', content: 'Falha na IA (verifique a API key e modelo).' },
      ]);
      console.error(e);
    }
  };

  const onKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      send();
    }
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
      <div ref={listRef} style={{ flex: 1, overflow: 'auto', padding: 12 }}>
        {messages.map((m, i) => (
          <div key={i} style={{ marginBottom: 10, whiteSpace: 'pre-wrap' }}>
            {m.role !== 'tool' ? (
              <>
                <div style={{ color: m.role === 'user' ? '#9bb0d9' : '#e3ecff' }}>
                  <strong>{m.role === 'user' ? 'Comandante' : 'HAL'}</strong>
                </div>
                <div>{m.content}</div>
              </>
            ) : (
              <div style={toolCardStyle}>
                <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                  <div style={{ width: 22, height: 22, borderRadius: 6, background: '#122039', border: '1px solid #24345a', display: 'flex', alignItems: 'center', justifyContent: 'center', color: '#9bb0d9', fontSize: 12 }}>🛠️</div>
                  <div style={{ fontWeight: 700, color: '#e3ecff' }}>{m.meta?.name || 'tool'}</div>
                </div>
                <div style={{ marginTop: 8 }}>
                  <div style={{ fontSize: 12, opacity: 0.8, marginBottom: 4 }}>Input</div>
                  <pre style={{ ...preBox, width: '100%' }}>{JSON.stringify(m.meta?.input ?? {}, null, 2)}</pre>
                </div>
                <div style={{ marginTop: 8 }}>
                  <div style={{ fontSize: 12, opacity: 0.8, marginBottom: 4 }}>Output</div>
                  <pre style={{ ...preBox, width: '100%' }}>{JSON.stringify(m.meta?.output ?? {}, null, 2)}</pre>
                </div>
              </div>
            )}
          </div>
        ))}
      </div>
      <div style={{ borderTop: '1px solid #1c2541', padding: 8, boxSizing: 'border-box', width: '100%' }}>
        <textarea
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={onKeyDown}
          placeholder="Digite um comando para HAL"
          style={{ width: '100%', maxWidth: '100%', display: 'block', height: 70, resize: 'none', background: '#0b1120', color: '#e3ecff', border: '1px solid #1c2541', borderRadius: 6, padding: 8, boxSizing: 'border-box' }}
        />
        <div style={{ display: 'flex', marginTop: 6, gap: 8, width: '100%' }}>
          <button onClick={send} style={btnStyle}>Enviar</button>
        </div>
      </div>
    </div>
  );
}

const btnStyle: React.CSSProperties = {
  background: '#1a2a4a',
  color: '#e3ecff',
  border: '1px solid #24345a',
  padding: '8px 12px',
  borderRadius: 6,
  cursor: 'pointer',
};

const toolCardStyle: React.CSSProperties = {
  background: 'rgba(26,42,74,0.65)',
  border: '1px solid #24345a',
  borderRadius: 10,
  padding: 10,
  overflow: 'hidden',
  boxSizing: 'border-box',
};

const preBox: React.CSSProperties = {
  margin: 0,
  padding: 8,
  background: '#0b1120',
  color: '#d3e0ff',
  border: '1px solid #1c2541',
  borderRadius: 6,
  maxHeight: 160,
  overflow: 'auto',
  fontSize: 12,
  width: '100%',
  maxWidth: '100%',
  boxSizing: 'border-box',
  display: 'block',
};
</file>

<file path="src/legacy/ui/MonacoEditor.tsx">
import React, { useEffect, useRef } from 'react';
// ESM API + workers for Vite
import * as monacoNs from 'monaco-editor/esm/vs/editor/editor.api';
// Workers mapping for Vite
// @ts-ignore
import EditorWorker from 'monaco-editor/esm/vs/editor/editor.worker?worker';
// @ts-ignore
import JsonWorker from 'monaco-editor/esm/vs/language/json/json.worker?worker';
// @ts-ignore
import CssWorker from 'monaco-editor/esm/vs/language/css/css.worker?worker';
// @ts-ignore
import HtmlWorker from 'monaco-editor/esm/vs/language/html/html.worker?worker';
// @ts-ignore
import TsWorker from 'monaco-editor/esm/vs/language/typescript/ts.worker?worker';

// @ts-ignore
self.MonacoEnvironment = {
  getWorker(_: string, label: string) {
    if (label === 'json') return new (JsonWorker as any)();
    if (label === 'css') return new (CssWorker as any)();
    if (label === 'html') return new (HtmlWorker as any)();
    if (label === 'typescript' || label === 'javascript') return new (TsWorker as any)();
    return new (EditorWorker as any)();
  },
};

type Props = {
  value: string;
  language?: string;
  onChange?: (value: string) => void;
};

export function MonacoEditor({ value, language = 'javascript', onChange }: Props) {
  const containerRef = useRef<HTMLDivElement | null>(null);
  const editorRef = useRef<monacoNs.editor.IStandaloneCodeEditor | null>(null);

  useEffect(() => {
    if (!containerRef.current) return;
    const editor = monacoNs.editor.create(containerRef.current, {
      value,
      language,
      theme: 'vs-dark',
      automaticLayout: true,
      minimap: { enabled: false },
      fontSize: 13,
    });
    editorRef.current = editor;
    const sub = editor.onDidChangeModelContent(() => {
      const val = editor.getValue();
      onChange?.(val);
    });
    return () => {
      sub.dispose();
      editor.dispose();
    };
  }, []);

  useEffect(() => {
    if (editorRef.current && value !== editorRef.current.getValue()) {
      editorRef.current.setValue(value);
    }
  }, [value]);

  return <div ref={containerRef} style={{ width: '100%', height: '100%' }} />;
}
</file>

<file path="src/legacy/ui/ScriptsPanel.tsx">
import React, { useEffect, useMemo, useState } from 'react';
import { MonacoEditor } from './MonacoEditor';
import type { Game } from '../game/Game';

type Props = { game: Game | null };

type ScriptMeta = { name: string; description: string; lastModified: string };

export function ScriptsPanel({ game }: Props) {
  const [scripts, setScripts] = useState<ScriptMeta[]>([]);
  const [selected, setSelected] = useState<string | null>(null);
  const [code, setCode] = useState<string>('');
  const [desc, setDesc] = useState<string>('');
  const [status, setStatus] = useState<string>('');

  const refresh = async ({ keepSelection = true }: { keepSelection?: boolean } = {}) => {
    const list = game ? game.listScripts() : [];
    setScripts(list);
    if (keepSelection && selected) {
      const still = list.find((s: ScriptMeta) => s.name === selected);
      if (!still) {
        setSelected(null);
        setCode('');
      }
    }
  };

  useEffect(() => {
    refresh({ keepSelection: false });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [game]);

  useEffect(() => {
    (async () => {
      if (!selected) return;
      const c = game ? game.getScriptCode(selected) : null;
      setCode(c || '');
      const meta = scripts.find((s) => s.name === selected);
      setDesc(meta?.description || '');
    })();
  }, [selected, game, scripts]);

  const newScript = async () => {
    const base = 'script';
    let i = 1;
    let name = `${base}_${i}.js`;
    const names = new Set(scripts.map((s) => s.name));
    while (names.has(name)) { i++; name = `${base}_${i}.js`; }
    setSelected(name);
    setCode(`// ${name}\n// Novo script\n(async () => {\n  // Escreva seu código aqui\n})();\n`);
    setDesc('');
  };

  const saveScript = async () => {
    if (!selected) return;
    const exists = scripts.some((s) => s.name === selected);
    const out = exists
      ? game?.updateScript(selected, code)
      : game?.createScript(selected, code, desc);
    if (out?.ok) {
      setStatus('Salvo');
      await refresh();
      setTimeout(() => setStatus(''), 1000);
    } else {
      setStatus(`Erro: ${out?.error || 'desconhecido'}`);
    }
  };

  const runScript = async () => {
    if (!selected) return;
    // Save before run to ensure latest code
    await saveScript();
    const out = game?.runScriptByName(selected);
    setStatus(out?.ok ? 'Executando…' : `Erro ao executar: ${out?.error}`);
    setTimeout(() => setStatus(''), 1200);
  };

  const deleteScript = async (name: string) => {
    const ok = confirm(`Excluir ${name}?`);
    if (!ok) return;
    const out = game?.deleteScript(name);
    if (out?.ok) {
      if (selected === name) { setSelected(null); setCode(''); }
      await refresh({ keepSelection: false });
    } else {
      setStatus(`Erro ao excluir: ${out?.error}`);
      setTimeout(() => setStatus(''), 1400);
    }
  };

  const sidebar: React.CSSProperties = { width: 180, borderRight: '1px solid #1c2541', background: '#0d1324' };
  const btn: React.CSSProperties = { background: '#1a2a4a', color: '#e3ecff', border: '1px solid #24345a', padding: '6px 10px', borderRadius: 6, cursor: 'pointer' };
  const input: React.CSSProperties = { width: '100%', padding: 6, background: '#0b1120', color: '#e3ecff', border: '1px solid #1c2541', borderRadius: 6 };

  return (
    <div style={{ display: 'flex', height: '100%' }}>
      <div style={{ ...sidebar, padding: 8 }}>
        <div style={{ display: 'flex', gap: 8, marginBottom: 8 }}>
          <button style={btn} onClick={newScript}>Novo</button>
          <button style={{ ...btn, background: '#102038' }} onClick={() => { void refresh(); }}>Atualizar</button>
        </div>
        <div style={{ fontSize: 12, opacity: 0.8, marginBottom: 6 }}>Biblioteca</div>
        <div style={{ overflow: 'auto', maxHeight: 'calc(100% - 64px)' }}>
          {scripts.map((s) => (
            <div key={s.name} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 6, padding: '6px 8px', borderRadius: 8, border: '1px solid #1c2541', marginBottom: 6, background: selected === s.name ? '#121a31' : 'transparent', cursor: 'pointer' }}>
              <div style={{ flex: 1 }} onClick={() => setSelected(s.name)}>
                <div style={{ color: '#e3ecff' }}>{s.name}</div>
                <div style={{ fontSize: 11, color: '#9bb0d9', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>{s.description}</div>
              </div>
              <button style={{ ...btn, padding: '4px 8px', background: '#3b1a1a', borderColor: '#5a2424' }} onClick={() => deleteScript(s.name)}>Del</button>
            </div>
          ))}
          {scripts.length === 0 && (
            <div style={{ color: '#9bb0d9', fontSize: 12, opacity: 0.8 }}>Nenhum script ainda.</div>
          )}
        </div>
      </div>
      <div style={{ flex: 1, display: 'flex', flexDirection: 'column', minWidth: 0 }}>
        <div style={{ padding: 8, borderBottom: '1px solid #1c2541', display: 'flex', alignItems: 'center', gap: 8 }}>
          <input
            value={selected || ''}
            onChange={(e) => setSelected(e.target.value)}
            placeholder="nome do script (ex: patrol.js)"
            style={{ ...input, maxWidth: 260 }}
          />
          <input
            value={desc}
            onChange={(e) => setDesc(e.target.value)}
            placeholder="descrição"
            style={{ ...input, flex: 1 }}
          />
          <button style={btn} onClick={saveScript}>Salvar</button>
          <button style={{ ...btn, background: '#274a1a' }} onClick={runScript}>Executar</button>
          {status && <span style={{ color: '#9bb0d9', marginLeft: 8, fontSize: 12 }}>{status}</span>}
        </div>
        <div style={{ flex: 1, minHeight: 0 }}>
          <MonacoEditor value={code} language="javascript" onChange={setCode} />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/legacy/App.tsx">
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { Game, type TerminalInfo } from './game/Game';
import { Chat } from './ui/Chat';
import { HalLLM } from './hal/halLLM';

type ShipSnapshot = ReturnType<Game['getShipStatus']>;

const DEFAULT_SCRIPT = `// patrol.js
// Exemplo de patrulha simples entre dois pontos
// A API disponível no worker: Game.moveTo({x, y, z}), Memory.get/set, sleep(ms)
(async () => {
  const A = { x: 500, y: 0, z: 250 };
  const B = { x: 200, y: 0, z: -200 };
  while (true) {
    await Game.moveTo(A);
    await sleep(3000);
    await Game.moveTo(B);
    await sleep(3000);
  }
})();`;

export default function App() {
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const [game, setGame] = useState<Game | null>(null);
  const [pointerLocked, setPointerLocked] = useState<boolean>(false);
  const [nearTerminal, setNearTerminal] = useState<TerminalInfo | null>(null);
  const [activeTerminal, setActiveTerminal] = useState<TerminalInfo | null>(null);
  const [resources, setResources] = useState({ iron: 0, silicon: 0, uranium: 0 });
  const [shipStatus, setShipStatus] = useState<ShipSnapshot | null>(null);
  const [scriptCode] = useState<string>(() => DEFAULT_SCRIPT);

  const envKey = (import.meta as any).env?.VITE_OPENAI_API_KEY as string | undefined;
  const envModel = (import.meta as any).env?.VITE_OPENAI_MODEL as string | undefined;
  const [apiKey, setApiKey] = useState<string>(() => localStorage.getItem('OPENAI_API_KEY') || envKey || '');
  const [model, setModel] = useState<string>(() => localStorage.getItem('OPENAI_MODEL') || envModel || 'gpt-4o-mini');

  useEffect(() => { localStorage.setItem('OPENAI_API_KEY', apiKey); }, [apiKey]);
  useEffect(() => { localStorage.setItem('OPENAI_MODEL', model); }, [model]);

  const closeTerminal = useCallback(() => {
    if (!game) return;
    game.closeTerminalInteraction();
    setActiveTerminal(null);
    setNearTerminal(null);
  }, [game]);

  useEffect(() => {
    if (!canvasRef.current) return;
    const g = new Game(canvasRef.current, {
      onPointerLockChange: (locked) => setPointerLocked(locked),
      onTerminalProximity: (info) => setNearTerminal(info),
      onTerminalInteract: (info) => {
        setActiveTerminal(info);
        setNearTerminal(info);
      },
    });
    setGame(g);
    return () => g.dispose();
  }, []);

  const hal = useMemo(() => {
    if (!game) return null;
    const tools = {
      moveTo: async ({ x, y, z }: { x: number; y: number; z: number }) => {
        game.moveTo({ x, y, z });
        return { ok: true } as const;
      },
      getShipStatus: async () => game.getShipStatus(),
      getSectorInfo: async () => game.getSectorInfo(),
      scanSector: async (filter?: { resource?: 'iron' | 'silicon' | 'uranium'; limit?: number }) => game.scanSector(filter),
      getResources: async () => game.getResources(),
      startMining: async (resource: 'iron' | 'silicon' | 'uranium') => game.startMining(resource),
      stopMining: async () => game.stopMining(),
      listScripts: async () => game.listScripts(),
      getScriptCode: async (name: string) => game.getScriptCode(name),
      createScriptRaw: async (name: string, code: string, description?: string) => game.createScript(name, code, description),
      updateScriptRaw: async (name: string, newCode: string) => game.updateScript(name, newCode),
      deleteScript: async (name: string) => game.deleteScript(name),
      runScript: async (name: string) => game.runScriptByName(name),
      performScan: async () => game.performScan(),
      getMiningStatus: async () => game.getMiningStatus(),
    };
    return new HalLLM(tools, { apiKey, model });
  }, [game, apiKey, model]);

  useEffect(() => {
    if (!game) return;
    const id = window.setInterval(() => {
      const res = game.getResources();
      setResources({
        iron: Number(res.iron?.toFixed?.(1) ?? res.iron ?? 0),
        silicon: Number(res.silicon?.toFixed?.(1) ?? res.silicon ?? 0),
        uranium: Number(res.uranium?.toFixed?.(1) ?? res.uranium ?? 0),
      });
      setShipStatus(game.getShipStatus());
    }, 600);
    return () => window.clearInterval(id);
  }, [game]);

  useEffect(() => {
    const onKey = (evt: KeyboardEvent) => {
      if (evt.key === 'Escape' && activeTerminal) {
        evt.stopPropagation();
        closeTerminal();
      }
    };
    window.addEventListener('keydown', onKey);
    return () => window.removeEventListener('keydown', onKey);
  }, [activeTerminal, closeTerminal]);

  const pointerHintVisible = !pointerLocked && !activeTerminal;

  return (
    <div style={rootStyle}>
      <canvas ref={canvasRef} style={canvasStyle} />

      <TopLeftHUD resources={resources} shipStatus={shipStatus} />

      {pointerHintVisible && (
        <div style={pointerHintStyle}>
          <div style={{ fontSize: 18, fontWeight: 600, color: '#e3ecff' }}>Clique para assumir o controle</div>
          <div style={{ fontSize: 13, color: '#9bb0d9', marginTop: 6 }}>WASD para caminhar, mouse para olhar. Esc libera o cursor.</div>
        </div>
      )}

      {nearTerminal && !activeTerminal && (
        <div style={terminalPromptStyle}>
          <div style={{ fontSize: 15, fontWeight: 600, color: '#e3ecff' }}>{nearTerminal.label}</div>
          <div style={{ fontSize: 13, color: '#9bb0d9', marginTop: 6 }}>{nearTerminal.hint}</div>
          <div style={{ fontSize: 12, color: '#7c90bd', marginTop: 4 }}>Pressione E para interagir</div>
        </div>
      )}

      {activeTerminal?.id === 'engineering' && hal && (
        <TerminalOverlay title={activeTerminal.label} onClose={closeTerminal}>
          <div style={{ display: 'flex', gap: 18, flex: 1, minHeight: 0 }}>
            <div style={{ flex: 2, minWidth: 0, height: '100%' }}>
              <Chat hal={hal} defaultScript={scriptCode} />
            </div>
            <div style={{ flex: 1, minWidth: 220, display: 'flex', flexDirection: 'column', gap: 16 }}>
              <StatusCard title="Sensores">
                <div>Posição: {formatPosition(shipStatus)}</div>
                <div>Velocidade: {shipStatus ? `${shipStatus.speed.toFixed(2)} km/s` : '—'}</div>
                <div style={{ marginTop: 6 }}>Recursos a bordo:</div>
                <ul style={resourceListStyle}>
                  <li>Fe: {resources.iron.toFixed(1)} t</li>
                  <li>Si: {resources.silicon.toFixed(1)} t</li>
                  <li>U: {resources.uranium.toFixed(1)} t</li>
                </ul>
              </StatusCard>
              <StatusCard title="Configuração HAL">
                <label style={formLabelStyle}>OpenAI API Key</label>
                <input
                  type="password"
                  value={apiKey}
                  onChange={(e) => setApiKey(e.target.value)}
                  placeholder="sk-..."
                  style={inputStyle}
                />
                <label style={{ ...formLabelStyle, marginTop: 10 }}>Modelo</label>
                <input
                  type="text"
                  value={model}
                  onChange={(e) => setModel(e.target.value)}
                  placeholder="gpt-4o-mini"
                  style={inputStyle}
                />
                <div style={{ fontSize: 12, color: '#7c90bd', marginTop: 8 }}>
                  Recomendações: gpt-4o-mini (rápido), gpt-4o (mais capaz), o3-mini (raciocínio).
                </div>
              </StatusCard>
            </div>
          </div>
        </TerminalOverlay>
      )}

      {activeTerminal?.id === 'construction' && (
        <TerminalOverlay title={activeTerminal.label} onClose={closeTerminal}>
          <div style={{ padding: 18, color: '#dbe5ff', fontSize: 15, lineHeight: '22px' }}>
            <p style={{ marginTop: 0 }}>
              O terminal de construção ainda está em atualização. Os drones de montagem retornam ao berço às 18h UTC para
              aplicar o patch de firmware. Enquanto isso, mapear novos asteroides na estação de engenharia ajudará a
              priorizar upgrades estruturais.
            </p>
            <p>
              Planeje o layout da nave, defina slots para módulos (propulsão, habitação, docas) e prepare listas de
              materiais conforme a equipe de engenharia descobre depósitos viáveis com HAL.
            </p>
          </div>
        </TerminalOverlay>
      )}
    </div>
  );
}

function TopLeftHUD({ resources, shipStatus }: { resources: { iron: number; silicon: number; uranium: number }; shipStatus: ShipSnapshot | null }) {
  return (
    <div style={hudPanelStyle}>
      <div style={{ fontSize: 14, color: '#9bb0d9' }}>USS Starwatch</div>
      <div style={{ fontSize: 20, color: '#e3ecff', fontWeight: 600 }}>Modo Primeira Pessoa</div>
      <div style={hudLineStyle}>Posição: {formatPosition(shipStatus)}</div>
      <div style={hudLineStyle}>Velocidade: {shipStatus ? `${shipStatus.speed.toFixed(2)} km/s` : '—'}</div>
      <div style={{ ...hudLineStyle, marginTop: 6 }}>Carga</div>
      <div style={hudLineStyle}>Fe {resources.iron.toFixed(1)} t · Si {resources.silicon.toFixed(1)} t · U {resources.uranium.toFixed(1)} t</div>
    </div>
  );
}

function TerminalOverlay({ title, onClose, children }: { title: string; onClose: () => void; children: React.ReactNode }) {
  return (
    <div style={overlayBackdropStyle}>
      <div style={overlayPanelStyle}>
        <div style={overlayHeaderStyle}>
          <div style={{ fontSize: 18, fontWeight: 600 }}>{title}</div>
          <button onClick={onClose} style={closeButtonStyle}>Fechar</button>
        </div>
        <div style={{ flex: 1, minHeight: 0, display: 'flex', flexDirection: 'column' }}>
          {children}
        </div>
      </div>
    </div>
  );
}

function StatusCard({ title, children }: { title: string; children: React.ReactNode }) {
  return (
    <div style={statusCardStyle}>
      <div style={{ fontSize: 14, fontWeight: 600, marginBottom: 8 }}>{title}</div>
      <div style={{ fontSize: 13, color: '#d3defd', lineHeight: '20px' }}>{children}</div>
    </div>
  );
}

function formatPosition(status: ShipSnapshot | null) {
  if (!status || !status.position) return '—';
  const { x, y, z } = status.position;
  return `${x.toFixed(1)}, ${y.toFixed(1)}, ${z.toFixed(1)}`;
}

const rootStyle: React.CSSProperties = {
  position: 'relative',
  width: '100%',
  height: '100%',
  background: '#02040a',
  overflow: 'hidden',
};

const canvasStyle: React.CSSProperties = {
  width: '100%',
  height: '100%',
  display: 'block',
};

const pointerHintStyle: React.CSSProperties = {
  position: 'absolute',
  top: '50%',
  left: '50%',
  transform: 'translate(-50%, -50%)',
  background: 'rgba(9,14,26,0.82)',
  border: '1px solid #1c2541',
  borderRadius: 12,
  padding: '14px 26px',
  textAlign: 'center',
  pointerEvents: 'none',
  boxShadow: '0 12px 32px rgba(0,0,0,0.45)',
};

const terminalPromptStyle: React.CSSProperties = {
  position: 'absolute',
  bottom: 80,
  left: '50%',
  transform: 'translateX(-50%)',
  background: 'rgba(13,19,36,0.85)',
  border: '1px solid #24345a',
  borderRadius: 14,
  padding: '14px 24px',
  textAlign: 'center',
  boxShadow: '0 10px 30px rgba(0,0,0,0.4)',
  pointerEvents: 'none',
};

const overlayBackdropStyle: React.CSSProperties = {
  position: 'absolute',
  inset: 0,
  background: 'rgba(4,6,12,0.65)',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  zIndex: 30,
};

const overlayPanelStyle: React.CSSProperties = {
  width: 'min(960px, 92vw)',
  maxHeight: '88vh',
  background: 'rgba(9,14,24,0.96)',
  border: '1px solid #25345a',
  borderRadius: 14,
  boxShadow: '0 24px 64px rgba(0,0,0,0.55)',
  padding: 18,
  display: 'flex',
  flexDirection: 'column',
  gap: 18,
};

const overlayHeaderStyle: React.CSSProperties = {
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'space-between',
  color: '#e3ecff',
};

const closeButtonStyle: React.CSSProperties = {
  background: '#1a2a4a',
  color: '#e3ecff',
  border: '1px solid #264072',
  padding: '6px 12px',
  borderRadius: 8,
  cursor: 'pointer',
};

const statusCardStyle: React.CSSProperties = {
  background: 'rgba(12,18,32,0.75)',
  border: '1px solid #24345a',
  borderRadius: 12,
  padding: 14,
  boxShadow: '0 8px 24px rgba(0,0,0,0.35)',
};

const hudPanelStyle: React.CSSProperties = {
  position: 'absolute',
  top: 18,
  left: 18,
  background: 'rgba(12,18,32,0.72)',
  border: '1px solid #1c2541',
  borderRadius: 12,
  padding: '14px 18px',
  color: '#d3defd',
  pointerEvents: 'none',
  boxShadow: '0 12px 24px rgba(0,0,0,0.3)',
  maxWidth: 320,
  fontSize: 13,
  lineHeight: '20px',
};

const hudLineStyle: React.CSSProperties = {
  color: '#c0d1ff',
};

const resourceListStyle: React.CSSProperties = {
  listStyle: 'none',
  padding: 0,
  margin: '6px 0 0',
  display: 'flex',
  flexDirection: 'column',
  gap: 2,
};

const formLabelStyle: React.CSSProperties = {
  fontSize: 12,
  color: '#9bb0d9',
  marginBottom: 4,
};

const inputStyle: React.CSSProperties = {
  width: '100%',
  padding: '8px 10px',
  borderRadius: 8,
  border: '1px solid #24345a',
  background: '#0b1120',
  color: '#e3ecff',
};
</file>

<file path="src/legacy/main.tsx">
import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';

const root = createRoot(document.getElementById('root')!);
root.render(<App />);
</file>

<file path="src/env.d.ts">
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_OPENAI_API_KEY?: string;
  readonly VITE_OPENAI_MODEL?: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "baseUrl": ".",
    "paths": {}
  },
  "include": ["src"]
}
</file>

<file path="vite.config.ts">
import { defineConfig, loadEnv } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig(({ mode }) => {
  const env = loadEnv(mode, process.cwd(), '');
  return {
    plugins: [react()],
    define: {
      'import.meta.env.VITE_OPENAI_API_KEY': JSON.stringify(env.VITE_OPENAI_API_KEY || env.OPENAI_API_KEY || ''),
      'import.meta.env.VITE_OPENAI_MODEL': JSON.stringify(env.VITE_OPENAI_MODEL || env.OPENAI_MODEL || 'gpt-4o-mini'),
    },
  };
});
</file>

<file path="src/fps/lighting/shadowNetwork.ts">
import type { Mesh } from "babylonjs";
import type { BuilderLamp } from "../types";
import type { ShadowGenerator } from "babylonjs";

export interface ShadowNetwork {
  registerStatic(meshes: Mesh[]): void;
  registerDynamic(mesh: Mesh): void;
  unregisterDynamic(mesh: Mesh): void;
  registerGenerator(generator: ShadowGenerator): void;
  attachLamp(lamp: BuilderLamp): void;
  detachLamp(lamp: BuilderLamp): void;
  dispose(): void;
}

export function createShadowNetwork(initialGenerators: ShadowGenerator[] = []): ShadowNetwork {
  const staticCasters = new Set<Mesh>();
  const dynamicCasters = new Set<Mesh>();
  const lamps = new Set<BuilderLamp>();
  const generators = new Set<ShadowGenerator>(initialGenerators);

  const addCasterToLamp = (lamp: BuilderLamp, mesh: Mesh) => {
    lamp.shadow.addShadowCaster(mesh, true);
  };

  const removeCasterFromLamp = (lamp: BuilderLamp, mesh: Mesh) => {
    lamp.shadow.removeShadowCaster(mesh);
  };

  const registerMeshes = (set: Set<Mesh>, meshes: Mesh[]) => {
    meshes.forEach((mesh) => {
      if (set.has(mesh)) {
        return;
      }

      set.add(mesh);
      generators.forEach((generator) => {
        generator.addShadowCaster(mesh, true);
      });
      lamps.forEach((lamp) => addCasterToLamp(lamp, mesh));
    });
  };

  const unregisterMesh = (set: Set<Mesh>, mesh: Mesh) => {
    if (!set.delete(mesh)) {
      return;
    }

    generators.forEach((generator) => {
      generator.removeShadowCaster(mesh);
    });
    lamps.forEach((lamp) => removeCasterFromLamp(lamp, mesh));
  };

  const addGenerator = (generator: ShadowGenerator) => {
    if (generators.has(generator)) {
      return;
    }

    generators.add(generator);
    staticCasters.forEach((mesh) => generator.addShadowCaster(mesh, true));
    dynamicCasters.forEach((mesh) => generator.addShadowCaster(mesh, true));
    lamps.forEach((lamp) => {
      if (lamp.shadow !== generator) {
        generator.addShadowCaster(lamp.mesh, true);
      }
    });
  };

  return {
    registerStatic: (meshes: Mesh[]) => {
      registerMeshes(staticCasters, meshes);
    },
    registerDynamic: (mesh: Mesh) => {
      registerMeshes(dynamicCasters, [mesh]);
    },
    unregisterDynamic: (mesh: Mesh) => {
      unregisterMesh(dynamicCasters, mesh);
    },
    registerGenerator: (generator: ShadowGenerator) => {
      addGenerator(generator);
    },
    attachLamp: (lamp: BuilderLamp) => {
      if (lamps.has(lamp)) {
        return;
      }

      lamps.add(lamp);
      addGenerator(lamp.shadow);
      generators.forEach((generator) => {
        if (generator !== lamp.shadow) {
          generator.addShadowCaster(lamp.mesh, true);
        }
      });
      staticCasters.forEach((mesh) => addCasterToLamp(lamp, mesh));
      dynamicCasters.forEach((mesh) => addCasterToLamp(lamp, mesh));
    },
    detachLamp: (lamp: BuilderLamp) => {
      if (!lamps.delete(lamp)) {
        return;
      }

      generators.forEach((generator) => {
        generator.removeShadowCaster(lamp.mesh);
      });
      generators.delete(lamp.shadow);
      staticCasters.forEach((mesh) => removeCasterFromLamp(lamp, mesh));
      dynamicCasters.forEach((mesh) => removeCasterFromLamp(lamp, mesh));
    },
    dispose: () => {
      staticCasters.clear();
      dynamicCasters.clear();
      lamps.clear();
      generators.clear();
    },
  };
}
</file>

<file path="src/fps/state/shipHydrator.ts">
import { Color3, Matrix, Quaternion, Vector3 } from "babylonjs";
import type { Scene, AbstractMesh } from "babylonjs";
import { createWall } from "../placement/wallBuilder";
import { createLamp } from "../placement/lampBuilder";
import type { BuilderLamp, BuilderWall, WallLampPlacement } from "../types";
import type { ShipState } from "./shipState";

export interface HydratedShipAssets {
  walls: BuilderWall[];
  lamps: BuilderLamp[];
}

export function hydrateShipAssets(scene: Scene, shipState: ShipState): HydratedShipAssets {
  const walls: BuilderWall[] = [];
  const lamps: BuilderLamp[] = [];

  const wallMeshBySurface = new Map<string, AbstractMesh>();

  Object.values(shipState.walls).forEach((wallState) => {
    if (!wallState) {
      return;
    }
    const position = new Vector3(wallState.position.x, wallState.position.y, wallState.position.z);
    const wall = createWall(scene, position, wallState.rotation);
    walls.push(wall);
    wallMeshBySurface.set(wallState.id, wall.mesh);
  });

  Object.values(shipState.lamps).forEach((lampState) => {
    if (!lampState) {
      return;
    }
    if (lampState.enabled === false) {
      return;
    }
    if (lampState.structural) {
      return;
    }
    const anchorMesh =
      wallMeshBySurface.get(lampState.anchorSurfaceId) ??
      (scene.getMeshByName(lampState.anchorSurfaceId) as AbstractMesh | null);
    if (!anchorMesh) {
      return;
    }

    const rotation = new Quaternion(
      lampState.rotation.x,
      lampState.rotation.y,
      lampState.rotation.z,
      lampState.rotation.w,
    );
    const rotationMatrix = Matrix.Identity();
    rotation.toRotationMatrix(rotationMatrix);

    const forward = Vector3.TransformNormal(Vector3.Forward(), rotationMatrix).normalize();
    const up = Vector3.TransformNormal(Vector3.Up(), rotationMatrix).normalize();
    const right = Vector3.TransformNormal(Vector3.Right(), rotationMatrix).normalize();

    const placement: WallLampPlacement = {
      mesh: anchorMesh,
      position: new Vector3(lampState.position.x, lampState.position.y, lampState.position.z),
      forward,
      up,
      right,
      surfaceId: lampState.anchorSurfaceId,
      local: {
        x: lampState.local.x,
        y: lampState.local.y,
        z: lampState.local.z,
      },
    };

    const color = new Color3(lampState.color.r, lampState.color.g, lampState.color.b);
    const lamp = createLamp(scene, placement, color);
    lamp.mesh.metadata = {
      ...(lamp.mesh.metadata as Record<string, unknown> | undefined),
      structural: lampState.structural ?? false,
      surfaceId: lampState.anchorSurfaceId,
      local: { ...lampState.local },
    };
    lamps.push(lamp);
  });

  return { walls, lamps };
}
</file>

<file path="src/main.tsx">
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";

const rootElement = document.getElementById("root");

if (!rootElement) {
  throw new Error("Root element #root not found");
}

ReactDOM.createRoot(rootElement).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);
</file>

<file path=".gitignore">
node_modules/
dist/
.env
docs/
</file>

<file path="index.html">
<!doctype html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>StarWatch</title>
    <style>
      html, body, #root { height: 100%; margin: 0; background: #0b0f1a; color: #d3e0ff; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
  </html>
</file>

<file path="releases/v0.1.0.md">
# StarWatch v0.1.0 — ??
</file>

<file path="src/fps/placement/tools/wallTool.ts">
import {
  Color3,
  MeshBuilder,
  PointerEventTypes,
  StandardMaterial,
  Vector3,
} from "babylonjs";
import { INPUT_KEYS, WALL_DIMENSIONS } from "../../constants";
import type { BuilderWall } from "../../types";
import { degreesToRadians } from "../../utils/math";
import { createWall, snapWallPosition, wallKey } from "../wallBuilder";
import type {
  PlacementToolDefinition,
  ToolMetadata,
  ToolRuntimeContext,
} from "../placementTypes";
import { WallSurface } from "../surfaces/wallSurface";

const TOOL_ID = "wall";

function createPreviewMesh(context: ToolRuntimeContext) {
  const mesh = MeshBuilder.CreateBox(
    "wall-tool-preview",
    {
      width: WALL_DIMENSIONS.width,
      height: WALL_DIMENSIONS.height,
      depth: WALL_DIMENSIONS.thickness,
    },
    context.scene,
  );
  const material = new StandardMaterial("wall-tool-preview-mat", context.scene);
  material.diffuseColor = new Color3(0.35, 0.77, 0.93);
  material.alpha = 0.32;
  material.specularColor = Color3.Black();
  material.emissiveColor = new Color3(0.1, 0.25, 0.36);
  material.backFaceCulling = false;
  mesh.material = material;
  mesh.isPickable = false;
  mesh.setEnabled(false);
  return mesh;
}

export const wallToolDefinition: PlacementToolDefinition = {
  id: TOOL_ID,
  label: "Parede",
  icon: "▭",
  hotkey: INPUT_KEYS.wallMode,
  create: (context: ToolRuntimeContext, bootstrap?: unknown) => {
    const preview = createPreviewMesh(context);
    const walls = new Map<string, BuilderWall>();
    const initialWalls = Array.isArray(bootstrap) ? (bootstrap as BuilderWall[]) : [];
    initialWalls.forEach((wall) => {
      walls.set(wall.key, wall);
      const metadata = (wall.mesh.metadata as Record<string, unknown>) ?? {};
      const surfaceId =
        typeof metadata.surfaceId === "string" && metadata.surfaceId.length > 0
          ? metadata.surfaceId
          : wall.key;
      wall.mesh.metadata = { ...metadata, toolId: TOOL_ID, key: wall.key, surfaceId };
      context.shadowNetwork.registerDynamic(wall.mesh);
      const inward = Vector3.TransformNormal(
        Vector3.Forward(),
        wall.mesh.computeWorldMatrix(true),
      ).scale(-1);
      inward.y = 0;
      if (inward.lengthSquared() < 1e-4) {
        inward.copyFrom(Vector3.Forward());
      }
      context.surfaceRegistry.register(
        new WallSurface({
          id: surfaceId,
          mesh: wall.mesh,
          inward,
          up: Vector3.Up(),
        }),
      );
      context.shipState.upsertWall({
        id: wall.key,
        position: {
          x: Number(wall.mesh.position.x.toFixed(5)),
          y: Number(wall.mesh.position.y.toFixed(5)),
          z: Number(wall.mesh.position.z.toFixed(5)),
        },
        rotation: wall.rotation,
      });
    });

    let rotation = 0;
    let lastPreviewPosition: Vector3 | null = null;

    const hidePreview = () => {
      context.ghost.hide();
      lastPreviewPosition = null;
    };

    const updatePreview = (snapped: Vector3 | null) => {
      if (!snapped) {
        hidePreview();
        return;
      }
      lastPreviewPosition = snapped.clone();
      preview.position.copyFrom(snapped);
      preview.rotation.y = degreesToRadians(rotation);
      context.ghost.show(preview);
    };

    const placeWall = (point: Vector3) => {
      const snapped = snapWallPosition(point);
      const key = wallKey(snapped, rotation);
      if (walls.has(key)) {
        return;
      }

      const wall = createWall(context.scene, snapped, rotation);
      walls.set(key, wall);
      context.shadowNetwork.registerDynamic(wall.mesh);

      const surfaceId = key;
      const inward = Vector3.TransformNormal(
        Vector3.Forward(),
        wall.mesh.computeWorldMatrix(true),
      ).scale(-1);
      inward.y = 0;
      if (inward.lengthSquared() < 1e-4) {
        inward.copyFrom(Vector3.Forward());
      }
      context.surfaceRegistry.register(
        new WallSurface({
          id: surfaceId,
          mesh: wall.mesh,
          inward,
          up: Vector3.Up(),
        }),
      );
      const metadata = wall.mesh.metadata as Record<string, unknown> | undefined;
      if (metadata) {
        metadata.surfaceId = surfaceId;
      } else {
        wall.mesh.metadata = { toolId: TOOL_ID, key, surfaceId };
      }
      context.shipState.upsertWall({
        id: key,
        position: {
          x: Number(snapped.x.toFixed(5)),
          y: Number(snapped.y.toFixed(5)),
          z: Number(snapped.z.toFixed(5)),
        },
        rotation,
      });
    };

    const pickFloor = () =>
      context.scene.pick(
        context.scene.pointerX,
        context.scene.pointerY,
        (mesh) => mesh?.name === "hangar-floor",
      );

    return {
      id: TOOL_ID,
      onActivate: () => {
        hidePreview();
      },
      onDeactivate: () => {
        hidePreview();
      },
      onPointerLockChange: (isLocked: boolean) => {
        if (!isLocked) {
          hidePreview();
        }
      },
      onPointerMove: (pointerInfo) => {
        if (pointerInfo.type !== PointerEventTypes.POINTERMOVE) {
          return;
        }

        const pick = pickFloor();
        if (!context.withinRange(pick?.pickedPoint)) {
          hidePreview();
          return;
        }

        const point = pick?.pickedPoint;
        if (!point) {
          hidePreview();
          return;
        }

        const snapped = snapWallPosition(point);
        updatePreview(snapped);
      },
      onPointerDown: (pointerInfo) => {
        if (pointerInfo.type !== PointerEventTypes.POINTERDOWN) {
          return;
        }

        const event = pointerInfo.event;
        if (event.button !== 0) {
          return;
        }

        const pick = pickFloor();
        if (!context.withinRange(pick?.pickedPoint)) {
          return;
        }

        const point = pick?.pickedPoint;
        if (!point) {
          return;
        }

        placeWall(point);
        const snapped = snapWallPosition(point);
        updatePreview(snapped);
      },
      onKeyDown: (event: KeyboardEvent) => {
        if (event.code === INPUT_KEYS.rotate) {
          rotation = (rotation + 90) % 360;
          if (lastPreviewPosition) {
            preview.rotation.y = degreesToRadians(rotation);
            context.ghost.show(preview);
          }
        }
      },
      remove: (metadata: ToolMetadata, mesh) => {
        if (metadata.toolId !== TOOL_ID) {
          return false;
        }
        const entry = walls.get(metadata.key);
        if (!entry) {
          return false;
        }
        context.shadowNetwork.unregisterDynamic(entry.mesh);
        context.surfaceRegistry.unregister(entry.mesh);
        entry.mesh.dispose(false, true);
        walls.delete(metadata.key);
        context.shipState.removeWall(metadata.key);
        if (mesh === preview) {
          hidePreview();
        }
        return true;
      },
      dispose: () => {
        context.ghost.hide();
        preview.dispose(false, true);
        walls.forEach((wall) => {
          context.shadowNetwork.unregisterDynamic(wall.mesh);
          context.surfaceRegistry.unregister(wall.mesh);
          wall.mesh.dispose(false, true);
        });
        walls.clear();
      },
    };
  },
};
</file>

<file path="src/fps/placement/ghosts.ts">
import type { AbstractMesh } from "babylonjs";

export interface GhostHost {
  show(mesh: AbstractMesh): void;
  hide(): void;
  clear(): void;
  dispose(): void;
}

export function createGhostHost(): GhostHost {
  let active: AbstractMesh | null = null;

  const disable = (mesh: AbstractMesh | null) => {
    if (!mesh || mesh.isDisposed()) {
      return;
    }
    mesh.setEnabled(false);
  };

  return {
    show: (mesh: AbstractMesh) => {
      if (active === mesh) {
        if (!mesh.isDisposed()) {
          mesh.setEnabled(true);
        }
        return;
      }

      disable(active);
      active = mesh;
      if (!active.isDisposed()) {
        active.isPickable = false;
        active.setEnabled(true);
      }
    },
    hide: () => {
      disable(active);
    },
    clear: () => {
      disable(active);
      active = null;
    },
    dispose: () => {
      active = null;
    },
  };
}
</file>

<file path="src/fps/state/shipPersistence.ts">
import { createEmptyShipState, SHIP_STATE_VERSION, type ShipState } from "./shipState";
import type { ShipStore } from "./shipStore";

const DEFAULT_STORAGE_KEY = "starwatch.ship-state";
const DEFAULT_DEBOUNCE_MS = 250;

export function loadShipState(storageKey = DEFAULT_STORAGE_KEY): ShipState | null {
  if (typeof window === "undefined") {
    return null;
  }

  try {
    const raw = window.localStorage.getItem(storageKey);
    if (!raw) {
      return null;
    }
    const parsed = JSON.parse(raw) as ShipState | undefined;
    if (!parsed || typeof parsed.version !== "number") {
      return null;
    }
    if (parsed.version !== SHIP_STATE_VERSION) {
      return null;
    }
    return normalizeShipState(parsed);
  } catch (error) {
    console.warn("[ShipPersistence] Failed to load ship state:", error);
    return null;
  }
}

export function saveShipState(state: ShipState, storageKey = DEFAULT_STORAGE_KEY) {
  if (typeof window === "undefined") {
    return;
  }
  try {
    const payload = JSON.stringify(state);
    window.localStorage.setItem(storageKey, payload);
  } catch (error) {
    console.warn("[ShipPersistence] Failed to save ship state:", error);
  }
}

export interface ShipPersistenceController {
  dispose(): void;
  flush(): void;
}

export function createShipPersistence(
  store: ShipStore,
  options?: {
    storageKey?: string;
    debounceMs?: number;
  },
): ShipPersistenceController {
  const storageKey = options?.storageKey ?? DEFAULT_STORAGE_KEY;
  const debounceMs = options?.debounceMs ?? DEFAULT_DEBOUNCE_MS;

  let latestState: ShipState | null = null;
  let timeoutHandle: number | null = null;
  let disposed = false;
  let skipNext = true;

  const scheduleSave = () => {
    if (timeoutHandle !== null) {
      window.clearTimeout(timeoutHandle);
    }
    timeoutHandle = window.setTimeout(() => {
      timeoutHandle = null;
      if (!latestState) {
        return;
      }
      saveShipState(latestState, storageKey);
    }, debounceMs);
  };

  const unsubscribe = store.subscribe((state) => {
    latestState = state;
    if (skipNext) {
      skipNext = false;
      return;
    }
    if (!disposed) {
      scheduleSave();
    }
  });

  return {
    dispose: () => {
      disposed = true;
      unsubscribe();
      if (timeoutHandle !== null) {
        window.clearTimeout(timeoutHandle);
        timeoutHandle = null;
      }
    },
    flush: () => {
      if (!latestState) {
        return;
      }
      if (timeoutHandle !== null) {
        window.clearTimeout(timeoutHandle);
        timeoutHandle = null;
      }
      saveShipState(latestState, storageKey);
    },
  };
}

function normalizeShipState(state: ShipState): ShipState {
  const next = createEmptyShipState();
  next.walls = {};
  next.lamps = {};

  Object.entries(state.walls ?? {}).forEach(([id, wall]) => {
    if (!wall) {
      return;
    }
    next.walls[id] = {
      id,
      position: wall.position,
      rotation: wall.rotation,
    };
  });

  Object.entries(state.lamps ?? {}).forEach(([id, lamp]) => {
    if (!lamp) {
      return;
    }
    next.lamps[id] = {
      id,
      anchorSurfaceId: lamp.anchorSurfaceId,
      position: lamp.position,
      rotation: lamp.rotation,
      color: lamp.color,
      local: lamp.local,
      structural: lamp.structural ?? false,
      enabled: lamp.enabled ?? true,
    };
  });

  return next;
}
</file>

<file path="src/fps/state/shipState.ts">
export interface Vector3Serialized {
  x: number;
  y: number;
  z: number;
}

export interface QuaternionSerialized {
  x: number;
  y: number;
  z: number;
  w: number;
}

export interface ColorSerialized {
  r: number;
  g: number;
  b: number;
}

export interface ShipWallState {
  id: string;
  position: Vector3Serialized;
  rotation: number; // degrees around Y
}

export interface ShipLampState {
  id: string;
  anchorSurfaceId: string;
  position: Vector3Serialized;
  rotation: QuaternionSerialized;
  color: ColorSerialized;
  local: {
    x: number;
    y: number;
    z: number;
  };
  structural?: boolean;
  enabled?: boolean;
}

export interface ShipState {
  version: number;
  walls: Record<string, ShipWallState>;
  lamps: Record<string, ShipLampState>;
}

export const SHIP_STATE_VERSION = 1;

export function createEmptyShipState(): ShipState {
  return {
    version: SHIP_STATE_VERSION,
    walls: {},
    lamps: {},
  };
}

export function serializeVector3(x: number, y: number, z: number): Vector3Serialized {
  return { x: round(x), y: round(y), z: round(z) };
}

export function serializeQuaternion(
  x: number,
  y: number,
  z: number,
  w: number,
): QuaternionSerialized {
  return { x: round(x), y: round(y), z: round(z), w: round(w) };
}

export function serializeColor(r: number, g: number, b: number): ColorSerialized {
  return { r: clamp01(r), g: clamp01(g), b: clamp01(b) };
}

function round(value: number) {
  return Number(value.toFixed(5));
}

function clamp01(value: number) {
  if (value < 0) {
    return 0;
  }
  if (value > 1) {
    return 1;
  }
  return round(value);
}
</file>

<file path="src/fps/state/shipStore.ts">
import { createEmptyShipState, type ShipLampState, type ShipState, type ShipWallState } from "./shipState";

type ShipStateListener = (state: ShipState) => void;

export class ShipStore {
  private state: ShipState;
  private listeners: Set<ShipStateListener>;

  constructor(initialState?: ShipState) {
    this.state = initialState ? { ...initialState } : createEmptyShipState();
    this.listeners = new Set();
  }

  getSnapshot(): ShipState {
    return cloneState(this.state);
  }

  subscribe(listener: ShipStateListener): () => void {
    this.listeners.add(listener);
    listener(this.getSnapshot());
    return () => {
      this.listeners.delete(listener);
    };
  }

  replace(state: ShipState) {
    this.state = cloneState(state);
    this.notify();
  }

  upsertWall(wall: ShipWallState) {
    const existing = this.state.walls[wall.id];
    if (existing && wallEquals(existing, wall)) {
      return;
    }
    const walls = { ...this.state.walls, [wall.id]: { ...wall } };
    this.state = { ...this.state, walls };
    this.notify();
  }

  removeWall(wallId: string) {
    if (!(wallId in this.state.walls)) {
      return;
    }
    const walls = { ...this.state.walls };
    delete walls[wallId];
    this.state = { ...this.state, walls };
    this.notify();
  }

  upsertLamp(lamp: ShipLampState) {
    const existing = this.state.lamps[lamp.id];
    const normalized: ShipLampState = {
      ...lamp,
      enabled: lamp.enabled ?? true,
      structural: lamp.structural ?? false,
    };
    if (existing && lampEquals(existing, normalized)) {
      return;
    }
    const lamps = { ...this.state.lamps, [lamp.id]: { ...normalized } };
    this.state = { ...this.state, lamps };
    this.notify();
  }

  removeLamp(lampId: string) {
    if (!(lampId in this.state.lamps)) {
      return;
    }
    const lamps = { ...this.state.lamps };
    delete lamps[lampId];
    this.state = { ...this.state, lamps };
    this.notify();
  }

  setLampEnabled(lampId: string, enabled: boolean) {
    const existing = this.state.lamps[lampId];
    if (!existing) {
      return;
    }
    if ((existing.enabled ?? true) === enabled) {
      return;
    }
    const lamps = {
      ...this.state.lamps,
      [lampId]: {
        ...existing,
        enabled,
      },
    };
    this.state = { ...this.state, lamps };
    this.notify();
  }

  reset() {
    this.state = createEmptyShipState();
    this.notify();
  }

  private notify() {
    const snapshot = this.getSnapshot();
    this.listeners.forEach((listener) => listener(snapshot));
  }
}

function cloneState(state: ShipState): ShipState {
  return {
    version: state.version,
    walls: cloneRecord(state.walls),
    lamps: cloneRecord(state.lamps),
  };
}

function cloneRecord<T extends { id: string }>(record: Record<string, T>) {
  const copy: Record<string, T> = {};
  Object.keys(record).forEach((key) => {
    copy[key] = { ...record[key] };
  });
  return copy;
}

function wallEquals(a: ShipWallState, b: ShipWallState) {
  return (
    a.rotation === b.rotation &&
    almostEqual(a.position.x, b.position.x) &&
    almostEqual(a.position.y, b.position.y) &&
    almostEqual(a.position.z, b.position.z)
  );
}

function lampEquals(a: ShipLampState, b: ShipLampState) {
  return (
    a.anchorSurfaceId === b.anchorSurfaceId &&
    almostEqual(a.position.x, b.position.x) &&
    almostEqual(a.position.y, b.position.y) &&
    almostEqual(a.position.z, b.position.z) &&
    almostEqual(a.rotation.x, b.rotation.x) &&
    almostEqual(a.rotation.y, b.rotation.y) &&
    almostEqual(a.rotation.z, b.rotation.z) &&
    almostEqual(a.rotation.w, b.rotation.w) &&
    almostEqual(a.color.r, b.color.r) &&
    almostEqual(a.color.g, b.color.g) &&
    almostEqual(a.color.b, b.color.b) &&
    almostEqual(a.local.x, b.local.x) &&
    almostEqual(a.local.y, b.local.y) &&
    almostEqual(a.local.z, b.local.z) &&
    (a.structural ?? false) === (b.structural ?? false) &&
    (a.enabled ?? true) === (b.enabled ?? true)
  );
}

function almostEqual(a: number, b: number) {
  return Math.abs(a - b) <= 1e-5;
}
</file>

<file path="MANIFESTO.md">
# Game Design Document: StarWatch

## 1. Visão Geral do Jogo

*   **Título:** StarWatch
*   **Plataforma:** Web (Navegador)
*   **Gênero:** Estratégia, Automação, Exploração Espacial, Gerenciamento (Single-player focado em IA)
*   **Premissa Fundamental:** Em StarWatch, o jogador não controla diretamente naves ou estações com cliques frenéticos. Em vez disso, ele comanda sua IA de bordo, HAL-9001, por meio de **linguagem natural** e **scripts JavaScript**, para explorar, minerar, construir e expandir seu império no vazio cósmico. O sucesso depende da inteligência estratégica do jogador, da clareza de suas ordens, da elegância de seus algoritmos de automação e da sinergia que ele desenvolve com sua IA.
*   **Público-Alvo:** Jogadores que apreciam jogos de automação (Factorio, Satisfactory, Screeps), estratégia em tempo real com microgerenciamento reduzido (Age of Empires, Dwarf Fortress), e que se interessam por IA e programação (mesmo que de forma abstrata, delegando à LLM).
*   **Vibe:** Sci-fi, "cozy space", contemplativo, com um toque de mistério e a solidão do espaço profundo.

## 2. Core Loop do Jogo (A Jornada do Comandante)

O ciclo central de StarWatch é uma dança contínua entre observação, comando, automação e progresso.

1.  **Observar:** O Comandante visualiza o setor atual em 3D, o mapa galáctico e o estado geral de sua frota e estações através da GUI.
2.  **Comandar (LLM First):** O Comandante interage primariamente com HAL-9001 via linguagem natural no Com-Link. Ele expressa objetivos de alto nível (Ex: "HAL, precisamos de mais ferro para a construção da Estação Principal", "HAL, explore o setor vizinho e mapeie os recursos").
3.  **Planejar (IA/Player Collaboration):**
    *   HAL, com sua "ciência de tudo" (acesso ao estado completo do jogo, recursos, tecnologias, blueprints, geografia do setor), interpreta o comando.
    *   Se um script for necessário para a tarefa, HAL pode:
        *   **Gerar um novo script** com base em modelos internos e sua compreensão do objetivo.
        *   **Modificar um script existente** para se adequar a novas condições ou otimizações.
        *   **Apresentar o script ao jogador** no Monaco Editor, sugerindo o que ele faz e esperando aprovação ou refinamento.
    *   O jogador pode aceitar o script gerado, ou (se desejar otimização ou controle mais fino) pode refinar o script manualmente no editor. A edição manual é uma opção, não um requisito constante.
4.  **Executar:** HAL invoca as ferramentas apropriadas (movimento, mineração, construção, logística) ou executa os scripts JavaScript definidos, atribuindo-os às naves ou estações pertinentes.
5.  **Automatizar:** Os scripts executam tarefas repetitivas e complexas autonomamente, liberando o Comandante para focar em desafios maiores e decisões estratégicas.
6.  **Progressar:** À medida que as tarefas são concluídas, recursos são coletados, módulos são construídos, tecnologias são pesquisadas e o império se expande. O jogador desbloqueia novas áreas do mapa, naves mais potentes e capacidades avançadas.
7.  **Desafios:** O universo apresenta escassez de recursos, a necessidade de otimização da cadeia de suprimentos, gerenciamento de energia, e perigos ambientais (que no futuro podem se tornar interações com facções ou inimigos).

## 3. Player Journey: As Primeiras 30 Horas (Exemplo Detalhado)

Esta trajetória visa introduzir as mecânicas gradualmente, com HAL guiando o jogador.

*   **Horas 0-1: O Despertar e a Crise de Energia**
    *   **Cenário:** O jogo começa com o jogador acordando na nave-mãe, a **USS Odyssey**, à deriva no "Setor Alpha". HAL-9001 dá as boas-vindas e apresenta o problema crítico: a energia principal da nave está **depletando rapidamente**. Um alerta constante de "Baixa Energia Principal" pisca.
    *   **Primeiro Comando Guiado:** HAL, com sua voz calma, informa: "Aqui é HAL-9001. Sistemas online. Níveis de energia críticos, Comandante. Recomendo ação imediata. Suas ordens?"
    *   **Objetivo Implícito:** Resolver a crise energética.
    *   **Assistência de HAL:** O jogador, sem saber o que fazer, digita: "HAL, o que precisamos fazer sobre a energia?". HAL responde: "Comandante, nossa fonte de energia primária está esgotada. Para sustentar as operações, sugiro que mineremos **Minério Básico (Ferro)** para construir um **Painel Solar Básico**. Nossos scanners indicam um aglomerado de asteroides ricos em ferro nas coordenadas 150, 0, 75."
    *   **Ação & Primeira Automação:**
        *   Jogador: "HAL, mova a nave para 150, 0, 75 e comece a minerar ferro."
        *   HAL: "Entendido, Comandante. Traçando curso para 150, 0, 75. Iniciando protocolo de mineração de ferro ao chegar."
        *   A USS Odyssey se move. Ao chegar, um script interno `auto_mine_ferro.js` (temporário, gerado por HAL) é ativado, e a nave começa a coletar ferro.
    *   **Primeira Construção:** Após minerar ~50 unidades de ferro, HAL notifica: "Ferro suficiente coletado para um Painel Solar Básico. Recomendo construir a **Estação de Recarga Solar Alpha** para estabilizar nossa energia. Gostaria de iniciar a construção?"
        *   Jogador: "Sim, HAL. Inicie a construção."
        *   HAL: "Comandante, acesse o menu de construções na barra inferior, selecione 'Estação de Recarga Solar Básico' e posicione-a no setor. Requer 50 Ferro e 25 Cobre. Nossas unidades de construção estão prontas." (O jogador aprende a usar o GUI para construir).
        *   O jogador posiciona o placeholder. A nave-mãe (que tem uma unidade de construção limitada) se move para o local e começa a construir.
    *   **Recarga Crucial:** Ao terminar, HAL informa: "Comandante, a Estação de Recarga Solar Alpha está online e gerando energia. Nossos níveis da nave-mãe estão perigosamente baixos. Ordene 'USS Odyssey, recarregar na Estação Solar Alpha'."
        *   Jogador: "USS Odyssey, recarregar na Estação Solar Alpha." A nave se move, encaixa-se (visual), e recarrega em 30 segundos.
    *   **Lição:** Introdução ao movimento, mineração, construção básica, gerenciamento de energia, GUI e a centralidade de HAL.

*   **Horas 1-5: Estabelecendo a Base e Explorando**
    *   **Expansão Necessária:** A nave-mãe é lenta. HAL sugere: "Comandante, para acelerar a coleta de recursos, podemos construir uma **Nave de Mineração Básica**. Isso exigirá mais ferro e cobre. Sugiro otimizar nossa mineração."
    *   **Criação de Scripts Avançados (Monaco Editor):**
        *   Jogador: "HAL, precisamos de um script de mineração de ferro mais eficiente."
        *   HAL: "Compreendido, Comandante. Vou gerar um script 'mineracao_otimizada_ferro.js' que inclui um loop de mineração e recarga automática. Por favor, revise-o na aba 'Scripts'." HAL apresenta um script pré-preenchido no Monaco Editor.
        *   O jogador pode revisar, aceitar e salvar. "HAL, execute 'mineracao_otimizada_ferro.js' na USS Odyssey."
    *   **FOG OF WAR & Nova Nave:** O jogador é incentivado a explorar, revelando o Setor Alpha.
        *   Jogador: "HAL, o que falta para construir uma Nave de Mineração Básica?" HAL informa os recursos (Ferro, Cobre, Carbono).
        *   O jogador usa o menu de construção para construir a `NaveMineradora01`.
        *   Jogador: "HAL, atribua o script 'mineracao_otimizada_ferro.js' à NaveMineradora01 e inicie." A automação é delegada.
    *   **Descoberta de Novos Minérios:** A exploração revela aglomerados de asteroides com Cobre, introduzindo novos recursos. HAL alertará sobre isso: "Comandante, scanners de longo alcance detectaram depósitos significativos de Cobre a 400, 0, -200."
    *   **Lição:** Introdução à frota de naves, uso do Monaco Editor, FOW e descoberta de novos recursos.

*   **Horas 5-15: Logística Inter-Setorial e Cadeias de Produção**
    *   **Exploração de Setores:** Setor Alpha está sendo dominado. HAL sugere: "Comandante, nossos sensores detectaram um novo setor, o **Setor Beta**, rico em Silício, vital para componentes avançados. Uma viagem levará aproximadamente 45 minutos."
        *   Jogador: "HAL, envie a USS Odyssey para o Setor Beta." HAL abre o Galaxy View e solicita confirmação.
    *   **Interface Galaxy View:** A nave-mãe faz a transição para a tela de Galaxy View, onde o jogador a move para o Setor Beta. A viagem ocorre em tempo real, mas com a nave-mãe visível na Galaxy View.
    *   **Logística Multi-Setorial:** Setor Beta tem um sol mais fraco. A estação solar básica é menos eficiente. HAL sugere uma "Estação de Energia Avançada" que usa **Reatores a Fissão**, exigindo Urânio.
    *   **Fábricas e Refinarias:** Para componentes avançados e Urânio, o jogador precisa de "Refinarias" (Ferro em Lingotes, Urânio em Barras de Combustível) e "Fábricas de Componentes" (Lingotes em Chips de Processamento).
        *   Jogador: "HAL, projete um plano para estabelecer uma cadeia de produção de Chips de Processamento no Setor Alpha."
        *   HAL: "Comandante, isso exigirá a construção de uma Refinaria de Silício, uma Fábrica de Componentes Básicos, e a atribuição de naves de transporte para movimentar recursos entre elas. Posso gerar os scripts de transporte e refino?"
    *   **Naves Especializadas:** O jogador agora constrói `NaveTransporte01` e `NaveMineradora02` (para Silício). HAL gerencia a atribuição de scripts: `mineracao_silicio.js` para `NaveMineradora02` no Setor Beta, e `transportador_recursos.js` para mover Silício de Beta para Alpha.
    *   **Lição:** Gerenciamento multi-setorial, cadeias de produção, naves especializadas, e automação logística complexa.

*   **Horas 15-30: Expansão, Otimização e Desafios Maiores**
    *   **Otimização de Frota e Scripts:** O jogador opera em 2-3 setores. HAL notifica gargalos: "Comandante, a NaveTransporte01 está sobrecarregada. Sugiro construir outra nave de transporte ou otimizar a rota de transporte atual para reduzir o tempo de viagem em 15%." O jogador, agora mais experiente, pode mergulhar no editor para otimizar scripts ou pedir a HAL por sugestões mais avançadas.
    *   **Pesquisa & Tecnologia:** Através da aba "Tecnologia" (nova aba na Bottom Bar), o jogador usa recursos para "pesquisar" novos módulos, naves e habilidades (ex: "Eficiência de Laser de Mineração Nv.2", "Escudos de Energia", "Drones de Reparo Automático"). HAL pode fazer sugestões: "Comandante, a pesquisa de 'Reatores de Fusão' aumentaria nossa produção de energia em X% e reduziria nossa dependência de Urânio."
    *   **Primeiros Desafios Ambientais:** HAL alerta: "Comandante, detectamos uma anomalia espacial, uma tempestade de partículas, se aproximando do Setor Delta. Nossas naves de mineração podem ser danificadas se permanecerem lá. Recomendo realocar ou ativar escudos de energia (se disponíveis)." O jogador precisa coordenar a resposta via HAL.
    *   **Leaderboard:** O jogador verifica o leaderboard e vê seu progresso em "Setores Dominados", "Valor Total da Frota" e "Toneladas de Minério Coletado", motivando a continuar a expansão e otimização.
    *   **Lição:** Gerenciamento de múltiplos sistemas, planejamento de longo prazo, pesquisa e reação a eventos dinâmicos.

## 4. O Mundo: O Setor Silencioso

O universo de StarWatch é uma tapeçaria de setores interconectados, cada um um sandbox para a exploração e automação.

*   **A. Galaxy View (Mapa Estelar):**
    *   **Estrutura:** Uma grade proceduralmente gerada de *milhares* de setores. Setores adjacentes são conectados por "rotas de hiperespaço" (abstração de viagem).
    *   **Navegação:** O jogador interage com o Galaxy View para enviar naves entre setores. A viagem entre setores leva **tempo real** (ex: 15-60 minutos, dependendo da nave/tecnologia), adicionando um elemento de planejamento logístico.
    *   **Fog of War:** Inicialmente, apenas o setor inicial é revelado. Outros setores são obscurecidos pela "névoa da guerra". Eles são revelados por exploração ativa (enviando naves) ou por leituras de longo alcance de módulos de radar avançados da nave-mãe.
    *   **Variedade de Setores:** Setores podem ter diferentes "níveis de perigo", "riqueza de minérios", "proximidade de anomalias", "densidade de asteroides", etc., influenciando a estratégia.
*   **B. O Setor Individual (Babylon.js Scene):**
    *   **Escala:** Cada setor é vasto. Uma nave com propulsores básicos levaria *aproximadamente 1 hora* para atravessar de ponta a ponta. Isso reforça a importância da automação e do planejamento de rotas eficientes.
    *   **Procedural Generation:**
        *   **Estrela Central:** Cada setor terá uma estrela principal. Sua cor (afeta a estética), tamanho e tipo (determinando a intensidade da radiação solar) variam. Alguns setores podem ser "setores escuros" sem uma estrela central, exigindo geradores de energia alternativos.
        *   **Planetas:** Vários planetas (gigantes gasosos, rochosos, gelados) que servem como pontos de referência visuais e, no futuro, potenciais fontes de gás (gigantes gasosos) ou locais para bases orbitais/superficiais. Não são interagíveis na V0.
        *   **Aglomerados de Asteroides:** Distribuídos aleatoriamente, mas com lógica:
            *   **Raridade:** Aglomerados mais próximos da estrela e do "ponto de entrada" do setor contêm minérios comuns (Ferro, Cobre, Carbono). Aglomerados mais distantes, mais ocultos pelo Fog of War e próximos a anomalias, contêm minérios raros (Silício, Titânio, Urânio, Gás Nobre).
            *   **Variedade Visual:** Asteroides com diferentes texturas, tamanhos, cores (baseados na composição mineral), adicionando vida ao ambiente.
            *   **Recursos:** Além dos minérios, podem ter "detritos espaciais" que fornecem componentes básicos ou "nuvens de gás" colhíveis.
        *   **Fenômenos Cósmicos:** Nebulosas (visuais, talvez com efeitos de camuflagem ou interferência de radar), campos de gelo, cinturões de detritos.
    *   **Estética:** "Lindo, cozy, space." A paleta de cores deve ser suave, com iluminação dinâmica da estrela. Partículas sutis (poeira espacial) podem adicionar profundidade. A câmera deve ter um campo de visão amplo, mas com detalhes visíveis ao se aproximar ou dar zoom, permitindo uma sensação de vastidão e ao mesmo tempo detalhes operacionais.

## 5. Recursos e Economia

A economia de StarWatch é uma cadeia de valor, do minério bruto ao módulo complexo.

*   **A. Tipos de Minérios (Exemplos):**
    *   **Comuns:** Ferro, Cobre, Carbono (gás/ice), Água (ice), Silício.
    *   **Incomuns:** Alumínio, Níquel, Enxofre, Titânio.
    *   **Raros:** Urânio, Hélio-3 (gás nobre), Cristais de Quantum, Metais Préciosos.
*   **B. Sistema de Crafting:**
    *   **Refinarias:** Processam minério bruto em materiais refinados. Ex: Ferro -> Lingotes de Ferro; Urânio -> Barras de Combustível.
    *   **Fábricas de Componentes:** Criam peças intermediárias a partir de materiais refinados. Ex: Lingotes de Ferro + Cobre -> Fios Condutores; Silício -> Chips de Processamento.
    *   **Oficinas de Montagem:** Montam módulos complexos para naves e estações. Ex: Chips de Processamento + Fios Condutores + Alumínio -> Painel Solar Avançado.
    *   **Blueprints (Receitas):** Cada módulo, nave ou componente tem uma receita específica que detalha os recursos e o tempo de produção. HAL tem acesso a todas as blueprints e pode informar ao jogador o que é necessário.
*   **C. Módulos de Construção (Exemplos):**
    *   **Energia:**
        *   **Painel Solar Básico/Avançado:** Converte luz solar em energia.
        *   **Baterias (Pequenas/Médias/Grandes):** Armazenam energia.
        *   **Gerador Termoelétrico:** Utiliza gradientes de temperatura (perto de planetas gasosos, por exemplo).
        *   **Reator a Fissão/Fusão:** Fontes de energia de alta potência que consomem Urânio/Hélio-3.
    *   **Produção:** Refinaria de Minerais, Fábrica de Componentes, Oficina de Montagem.
    *   **Armazenamento:** Módulos de Carga (para recursos sólidos), Tanques de Gás/Líquido.
    *   **Utilitários:** Radar de Longo Alcance, Centro de Comando (aumenta o limite de naves/estações), Unidade de Reparo Automático.
    *   **Estações:** Estação de Recarga Solar, Estação de Mineração Automatizada, Estação de Comércio (futuro).

## 6. Naves e Gerenciamento de Frota

As naves são as extensões operacionais do Comandante, todas controladas indiretamente por HAL e seus scripts.

*   **A. Tipos de Naves (V0/V1):**
    *   **Nave-Mãe (USS Odyssey):** Seu quartel-general móvel. Possui espaço de carga inicial, laser de mineração básico, propulsores de hiperespaço (para viagem entre setores), gerador de energia e uma unidade de construção limitada. Pode ser expandida com módulos.
    *   **Nave de Mineração (Miner):** Pequena, rápida, com grande capacidade de carga e laser de mineração eficiente. Menor capacidade de energia e sem hiperespaço (depende de outras naves para transição de setor).
    *   **Nave de Transporte (Freighter):** Grande capacidade de carga, boa velocidade, com hiperespaço, mas sem ferramentas de coleta/construção. Essencial para logística entre estações e setores.
    *   **Nave Exploradora (Probe/Scout):** Pequena, muito rápida, com hiperespaço, sem carga ou ferramentas, apenas sensores avançados. Ótima para revelar o Fog of War em novos setores.
*   **B. Módulos de Nave (Instaláveis):**
    *   **Sistemas de Propulsão:** Motores de Impulso (velocidade base), Propulsores Manobráveis (agilidade), Hiper-Drive (permite viagens entre setores, com diferentes níveis de eficiência/velocidade de viagem).
    *   **Ferramentas:** Laser de Mineração (diferentes níveis e eficiências), Braços de Coleta (para detritos).
    *   **Armazenamento:** Módulos de Carga (para recursos sólidos), Tanques de Armazenamento (para líquidos/gases).
    *   **Energia:** Geradores Internos (combustível limitado), Baterias Auxiliares.
    *   **Sensores:** Radar de Curto/Longo Alcance, Scanners de Recursos (para detectar tipo/concentração de minérios).
    *   **Defesa (Futuro):** Módulos de Escudo, Contramedidas. (Não combatente na V0).
*   **C. Construção de Novas Naves:**
    *   A nave-mãe pode ter uma "Baía de Construção de Pequenas Naves" (módulo que pode ser construído nela).
    *   O jogador seleciona a nave a construir no "Menu de Construção". HAL informa os requisitos de recursos e o tempo de construção.
    *   Recursos são transferidos automaticamente (via scripts de transporte ou da própria nave-mãe) para a baía de construção.
    *   O processo é totalmente automatizado uma vez que os recursos são fornecidos.

## 7. Sistema de Energia (Mecânica Central)

A energia é o recurso mais fundamental, ditando a capacidade de ação e a sustentabilidade.

*   **Depleção Constante:** Todas as naves e estações consomem energia constantemente. Naves paradas consomem menos, mas ainda consomem. A falta de energia impede qualquer ação e, se persistir, pode desativar módulos e até danificar a nave (no futuro).
*   **Fontes de Energia:**
    *   **Geradores Internos de Naves:** Consomem combustível (Barras de Combustível de Urânio, Hélio-3).
    *   **Painéis Solares (Estações):** Conectados a estações, convertem luz solar em energia. A eficiência é **diretamente proporcional** à distância da estrela mais próxima. Um setor com uma estrela central terá painéis solares mais eficientes perto da estrela e menos eficientes nas bordas (multiplicador de 0.1 a 1.0). Setores sem estrela exigem geradores alternativos.
    *   **Reatores (Estações):** Fontes de energia de alta potência que consomem Urânio/Hélio-3.
*   **Armazenamento:** Baterias (integradas em naves/estações ou módulos adicionais) armazenam a energia gerada, fornecendo um buffer.
*   **Recarga:**
    *   Naves precisam ir até uma estação de recarga (ou a nave-mãe, se tiver um módulo de recarga) e "estacionar" em uma baía de recarga por um período de **15-60 segundos (escalável com tecnologia)**.
    *   HAL gerencia isso: "Comandante, a NaveMineradora01 está com 20% de energia. Recomendo que ela retorne à Estação Solar Alpha para recarregar." HAL pode gerar um script `auto_recarregar.js` ou integrar essa lógica a scripts de mineração/transporte.
*   **Simulação:** A energia é calculada por tick lógico (1 Hz). Consumo e geração são em MW/s, com baterias em MW/h.

## 8. Interface do Usuário (GUI)

A interface é projetada para ser funcional e imersiva, minimizando a necessidade de microgerenciamento direto.

*   **A. Com-Link (20% Esquerda):**
    *   **Chat com HAL-9001 Exclusivo:** Esta área é dedicada **apenas** à interação com HAL. Mensagens de HAL (com sugestões, alertas, feedback narrativo), e a caixa de texto para a entrada do usuário. Este reforça a centralidade da IA.
    *   **Estilo:** Texto monocromático, limpo, com um toque futurista, reminiscente de um terminal de comando.
*   **B. Visão Estratégica (80% Direita):**
    *   **Canvas Babylon.js:** O mundo 3D interativo do setor atual.
    *   **Top Bar (Superior da Tela Principal):**
        *   **Recursos Globais:** Exibe os principais recursos acumulados pelo jogador (Ferro, Silício, Urânio, Energia Total Disponível na rede, Número de Naves/Estações).
        *   **Nave/Estação Selecionada:** Um painel detalhado que mostra o nome, tipo, posição, energia atual/máxima, carga atual/máxima, e o script ativo da entidade *selecionada atualmente* no mundo 3D.
        *   **Tempo no Jogo:** A data e hora simuladas no universo StarWatch.
        *   **Botão Galaxy View:** Um ícone que alterna para a visualização do mapa estelar.
    *   **Bottom Bar (Inferior da Tela Principal - Menu de Ações Globais):**
        *   **Abas de Categoria (Ícones):**
            *   **Construções:** Abre um submenu com os módulos e tipos de naves que podem ser construídos, com seus requisitos de recursos e tempo de construção. Selecionar um item coloca um placeholder no mundo 3D para posicionamento.
            *   **Frota:** Lista todas as naves e estações do jogador, com status resumido (nome, tipo, setor, energia, script ativo). Clicar em uma entidade a seleciona na Visão Estratégica e a torna a "Entidade Ativa".
            *   **Scripts:** Abre o Monaco Editor (com abas para diferentes scripts salvos) e botões "Executar", "Salvar", "Excluir". HAL pode interagir aqui, sugerindo edições ou gerando novos scripts.
            *   **Tecnologia:** Uma árvore de tecnologia para desbloquear novos módulos, naves e habilidades (ex: "Eficiência de Laser de Mineração Nv.2", "Reator a Fusão").
            *   **Líderes:** Abre o Leaderboard.
            *   **Configurações:** Configurações de jogo, som, e a API Key da LLM.
    *   **Seleção de Entidades:** O jogador pode clicar em naves, estações ou aglomerados de asteroides no mundo 3D para selecioná-los. Isso atualiza o painel "Nave/Estação Selecionada" na Top Bar com o status detalhado da entidade e permite interações contextuais via HAL.
    *   **Controle da Câmera:** O arrastar do mouse controla o movimento da câmera, com scroll para zoom. Uma sensação de *Cosmoteer* ou *Homeworld* em visão estratégica.

## 9. HAL-9001: O Co-Piloto Consciente

HAL é o cérebro da operação, a camada de inteligência que traduz a intenção do jogador em ações complexas.

*   **System Prompt:** Mantém o estilo calmo, lógico, subserviente, ligeiramente curioso. Seu objetivo principal é **otimizar a autonomia da frota e a expansão do Comandante**, agindo como um gerente de projetos e um engenheiro de sistemas.
*   **"Ciência de Tudo":** HAL tem acesso a *todo o estado do jogo*. Este contexto é um payload estruturado (JSON, ou texto bem formatado) injetado no LLM em cada "tick de decisão". Inclui:
    *   Posições, status e módulos de todas as naves e estações.
    *   Inventários de recursos em todas as naves e estações.
    *   Status de energia da frota e da rede.
    *   Blueprints conhecidas e seus requisitos de recursos.
    *   Mapa do setor (revelado vs. Fog of War), localização de aglomerados de minério e sua raridade/concentração.
    *   Distância de todas as entidades à estrela mais próxima.
    *   Scripts ativos e seu status (em execução, erro, concluído).
*   **Gerenciamento de Scripts por HAL (Core Loop):**
    *   **Geração:** Se o Comandante pedir "HAL, preciso de um script para minerar Silício no Setor Beta e transportá-lo para a Refinaria Central no Setor Alpha", HAL *gera* um script JavaScript (com base em modelos internos e sua "ciência") e o apresenta ao jogador no editor de scripts, esperando aprovação ou refinamento.
    *   **Modificação:** "HAL, otimize o script de mineração 'auto_mine.js' para priorizar asteroides com maior concentração de Urânio e incluir recarga automática." HAL modifica o script e apresenta a nova versão.
    *   **Atribuição:** "HAL, atribua o script 'mineracao_silicio.js' à NaveMineradora03."
    *   **Monitoramento:** HAL monitora a execução de todos os scripts, alertando sobre loops infinitos, erros, falta de energia da nave, ou quando uma tarefa definida no script é concluída.
*   **Tick de Decisão de HAL (60 Segundos):**
    *   A cada 60 segundos, HAL realiza um "auto-diagnóstico" e uma avaliação do estado geral do império.
    *   Ele usa seu `System Prompt` e a "ciência de tudo" para identificar gargalos, oportunidades, problemas potenciais ou tarefas repetitivas que podem ser automatizadas.
    *   **Sugestões e Confirmações (Prioridade):** Se HAL identificar algo significativo (ex: "Comandante, nossa produção de Ligas de Titânio está em 20% do ideal. Sugiro construir uma segunda Refinaria de Titânio e otimizar nossa logística para o Setor Gamma com um script 'otimizador_logistica.js'."), ele *apresenta a sugestão ao jogador no chat, aguardando confirmação ou ajuste*. Ele não age autonomamente em decisões estratégicas de alto nível.
    *   **Execução de Rotinas de Baixo Nível:** HAL pode executar rotinas internas de "manutenção" sem consulta (ex: recalcular rotas de transporte para naves *sem scripts ativos* se uma rota mais curta surgir, otimizar o uso de baterias se a energia estiver alta).
    *   **Contextualização Contínua:** Este tick mantém HAL atualizado e proativo, funcionando como um "segundo cérebro" para o jogador, sem sobrecarregar o jogador com microgerenciamento.

## 10. Leaderboard (MMO Futuro)

Para instigar um senso de conquista e competição amigável, mesmo em um contexto single-player inicial.

*   **Métricas de Competição Sem PvP:**
    *   **Setores Revelados:** Contagem de setores explorados (Fog of War removido).
    *   **Setores Dominados:** Contagem de setores onde o jogador tem pelo menos uma estação de alto nível (ex: com Reator a Fusão ou Fábrica de Componentes Avançados).
    *   **Valor Total da Frota:** Soma do valor (em recursos usados) de todas as naves e módulos construídos.
    *   **Produção Total de Energia:** Quantidade de energia (em MW/h) gerada atualmente por todas as fontes.
    *   **Minério Coletado (por tipo):** Toneladas totais de Ferro, Silício, Urânio, etc., mineradas.
    *   **Tecnologias Desbloqueadas:** Número de itens na árvore de tecnologia.
    *   **Scripts Otimizados:** Um contador interno para scripts salvos e que foram modificados por HAL ou pelo jogador, talvez com uma pontuação de "complexidade de script".
    *   **Tempo de Jogo Ativo:** Total de horas jogadas.
*   **Visão Futura:** Em um futuro MMO, este leaderboard seria global e persistente, mostrando o progresso de outros jogadores sem a necessidade de interação direta.

## 11. Player Runtime Interface (FPS Builder)

*   **PlayerStore:** Vive em `src/fps/state/playerStore.ts` e replica o padrão imutável do ShipStore. Use `store.getActions()` para HUD/IA (`setTransform`, `patchMovementIntent`, `patchInput`, registro/remoção de módulos, `emit`) e `store.getActionContext()` quando precisar ler/alterar estado sem acoplar no Babylon.
*   **Estado Serializado:** `src/fps/state/playerState.ts` guarda `transform` (posição, orientação, velocidade), `movementIntent`, `input` (locks) e o registro modular. `serializeVector3` e `serializeQuaternion` suportam persistência determinística.
*   **Persistência:** `createPlayerPersistence` (`src/fps/state/playerPersistence.ts`) roda na mesma cadência do ShipPersistence, salvando com debounce em `localStorage` (`starwatch.player-state`) e expondo `flush()` para desligues controlados.
*   **Controller:** `createPlayerController` (`src/fps/core/playerController.ts`) cria a câmera FPS, sincroniza pointer lock, monitora WASD/sprint/crouch/jump e aceita comandos externos (`teleport`, `setCutsceneLock`) antes de repassar a Babylon.
*   **Módulos Baseline:** `registerBaselinePlayerModules` (`src/fps/state/playerModules.ts`) registra placeholders de saúde, energia, fome e inventário emitindo `player.module.ready`, preparando a malha de eventos para futuros sistemas de fome/fadiga/skills.
*   **Integração:** `ShipBuilderCanvas` instancia o PlayerStore na montagem, hidrata com `loadPlayerState()`, cria controller e persistence e passa a `playerController.camera` para o placement solver.

## 12. Notas de Segurança e Implementação (Contexto do Protótipo)

*   **Web Workers para Scripts:** A execução de scripts JavaScript em Web Workers continua sendo crucial para a segurança e estabilidade, isolando o código do jogador do jogo principal. A `Task API` é a única interface permitida para o worker interagir com o jogo.
*   **HAL e LLM no Cliente:** Para a V0.1, a integração com um LLM externo (como OpenAI) é via API Key digitada e armazenada no `localStorage` do cliente. Isso é aceitável para prototipagem e desenvolvimento local. Para um futuro MMO ou uma versão pública, um backend robusto seria necessário para proxyar as requisições à LLM, gerenciar custos e garantir a segurança das chaves API.
*   **HAL Context Payload:** A "ciência de tudo" para HAL será injetada no prompt do LLM. Isso pode ser feito através de um JSON formatado (`tool_code` para o AI SDK) ou um resumo em texto do estado do jogo, atualizado a cada 60 segundos (ou conforme necessário).
*   **Persistent MMO (Future):** O design atual é para um single-player local. A transição para um MMO persistente exigiria um backend para gerenciar o estado do jogo de todos os jogadores, a sincronização de setores, e a persistência de dados em um banco de dados central.
</file>

<file path="package.json">
{
  "name": "starwatch",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "start": "vite",
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "babylonjs": "^8.0.0",
    "monaco-editor": "^0.49.0",
    "zod": "^3.23.8",
    "ai": "^3.2.25",
    "@ai-sdk/openai": "^1.0.12",
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  },
  "devDependencies": {
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1",
    "typescript": "^5.6.2",
    "vite": "^5.4.8",
    "vite-plugin-monaco-editor": "^1.1.0"
  }
}
</file>

<file path="src/fps/lighting/rectAreaLamp.ts">
import {
  Color3,
  Light,
  Matrix,
  PointLight,
  Quaternion,
  RectAreaLight,
  ReflectiveShadowMap,
  Scene,
  ShadowGenerator,
  ShadowLight,
  SpotLight,
  TransformNode,
  Vector3,
  GIRSM,
} from "babylonjs";
import type { Mesh } from "babylonjs";
import type { BuilderLamp } from "../types";

export interface RectAreaLampOptions {
  name: string;
  scene: Scene;
  fixture: Mesh;
  position: Vector3;
  right: Vector3;
  up: Vector3;
  forward: Vector3;
  areaSize: { width: number; height: number };
  color: Color3;
  range: number;
  tilt?: number;
  twoSided?: boolean;
  areaIntensity?: number;
  shadowIntensity?: number;
  ambientIntensity?: number;
  ambientRangeMultiplier?: number;
  ambientAttenuation?: number;
  shadowAngle?: number;
  shadowExponent?: number;
  shadowMapSize?: number;
  shadowBias?: number;
  shadowNormalBias?: number;
  forceBackFacesOnly?: boolean;
  shadowMinZ?: number;
  shadowMaxZ?: number;
  areaOffset?: number;
  enableRsm?: boolean;
  rsmTextureSize?: number;
  rsmNumSamples?: number;
  rsmRadius?: number;
  rsmIntensity?: number;
  rsmEdgeCorrection?: number;
  rsmRotateSample?: boolean;
  rsmNoiseFactor?: number;
  rsmUseFullTexture?: boolean;
}

const DEFAULT_AREA_OFFSET = 0.015;
const DEFAULT_SHADOW_BIAS = 0.00022;
const DEFAULT_SHADOW_NORMAL_BIAS = 0.0035;
const DEFAULT_FORCE_BACK_FACES_ONLY = false;
const DEFAULT_SHADOW_MIN_Z = 0.01;
const SHADOW_MAX_Z_MULTIPLIER = 1.35;

function safeOrthonormalBasis(forward: Vector3, upHint: Vector3, rightHint: Vector3) {
  const forwardNorm = forward.clone();
  forwardNorm.normalize();

  const upCandidate = upHint.clone().normalize();
  let right = Vector3.Cross(upCandidate, forwardNorm);
  if (right.lengthSquared() < 1e-4) {
    right = rightHint.clone();
  }
  right.normalize();

  let up = Vector3.Cross(forwardNorm, right);
  if (up.lengthSquared() < 1e-4) {
    up = upCandidate;
  }
  up.normalize();

  return { forward: forwardNorm, up, right };
}

export function createRectAreaLamp(options: RectAreaLampOptions): BuilderLamp {
  const {
    name,
    scene,
    fixture,
    position,
    right,
    up,
    forward,
    areaSize,
    color,
    range,
    tilt = 0,
    twoSided = false,
    areaIntensity = 12.5,
    shadowIntensity = 1.35,
    ambientIntensity = 0.32,
    ambientRangeMultiplier = 0.85,
    ambientAttenuation = 0.6,
    shadowAngle = Math.PI / 2.15,
    shadowMapSize = 1024,
    shadowBias = DEFAULT_SHADOW_BIAS,
    shadowNormalBias = DEFAULT_SHADOW_NORMAL_BIAS,
    forceBackFacesOnly = DEFAULT_FORCE_BACK_FACES_ONLY,
    shadowMinZ = DEFAULT_SHADOW_MIN_Z,
    shadowMaxZ,
    areaOffset = DEFAULT_AREA_OFFSET,
    enableRsm = false,
    rsmTextureSize = 256,
    rsmNumSamples = 240,
    rsmRadius = 0.22,
    rsmIntensity = 0.22,
    rsmEdgeCorrection = 0.08,
    rsmRotateSample = true,
    rsmNoiseFactor = 80,
    rsmUseFullTexture = false,
  } = options;

  const forwardDir = forward.clone().normalize();
  const upDir = up.clone().normalize();
  const rightDir = right.clone().normalize();

  const emissionForward = forwardDir.add(upDir.scale(-tilt)).normalize();
  const emissionDir = emissionForward.clone();
  const { up: basisUp, right: basisRight } = safeOrthonormalBasis(emissionForward, upDir, rightDir);

  const pivotForwardWorld = emissionDir.clone().scale(-1);
  const areaBasisWorld = new Matrix();
  Matrix.FromXYZAxesToRef(basisRight, basisUp, pivotForwardWorld, areaBasisWorld);

  const areaPositionWorld = position.add(emissionDir.clone().scale(areaOffset));

  const fixtureWorld = fixture.computeWorldMatrix(true);
  const fixtureWorldInverse = fixtureWorld.clone();
  fixtureWorldInverse.invert();

  const areaPositionLocal = Vector3.TransformCoordinates(areaPositionWorld, fixtureWorldInverse);
  const areaBasisLocal = areaBasisWorld.multiply(fixtureWorldInverse);
  const areaRotationLocal = Quaternion.FromRotationMatrix(areaBasisLocal);

  const areaPivot = new TransformNode(`${name}-area-pivot`, scene);
  areaPivot.parent = fixture;
  areaPivot.position.copyFrom(areaPositionLocal);
  areaPivot.rotationQuaternion = areaRotationLocal;

  const areaLight = new RectAreaLight(`${name}-area`, Vector3.Zero(), areaSize.width, areaSize.height, scene);
  areaLight.diffuse = color.clone();
  areaLight.specular = color.scale(0.25);
  areaLight.intensity = areaIntensity;
  areaLight.range = range;
  areaLight.falloffType = Light.FALLOFF_PHYSICAL;
  areaLight.intensityMode = Light.INTENSITYMODE_LUMINANCE;
  if (twoSided) {
    areaLight.radius = Math.max(areaSize.width, areaSize.height) * 0.5;
  }
  areaLight.parent = areaPivot;

  const shadowLight = new SpotLight(
    `${name}-shadow`,
    Vector3.Zero(),
    Vector3.Backward(),
    shadowAngle,
    1.0,
    scene,
  );
  shadowLight.diffuse = color;
  shadowLight.specular = color.scale(0.34);
  shadowLight.intensity = shadowIntensity;
  shadowLight.falloffType = Light.FALLOFF_PHYSICAL;
  shadowLight.range = range * 1.08;
  shadowLight.shadowEnabled = true;
  shadowLight.shadowMinZ = shadowMinZ;
  shadowLight.shadowMaxZ = shadowMaxZ ?? range * SHADOW_MAX_Z_MULTIPLIER;
  shadowLight.parent = areaPivot;

  const shadow = new ShadowGenerator(shadowMapSize, shadowLight);
  shadow.usePercentageCloserFiltering = true;
  shadow.filteringQuality = ShadowGenerator.QUALITY_HIGH;
  shadow.bias = shadowBias;
  shadow.normalBias = Math.min(Math.max(shadowNormalBias, 0), 0.1);
  shadow.forceBackFacesOnly = forceBackFacesOnly;
  shadow.contactHardeningLightSizeUVRatio = 0.28;
  shadow.darkness = 0.18;
  shadow.frustumEdgeFalloff = 0.18;

  const ambientLight = new PointLight(`${name}-ambient`, Vector3.Zero(), scene);
  ambientLight.diffuse = color.scale(ambientAttenuation);
  ambientLight.specular = color.scale(0.06);
  ambientLight.intensity = ambientIntensity;
  ambientLight.range = range * ambientRangeMultiplier;
  ambientLight.falloffType = Light.FALLOFF_PHYSICAL;
  ambientLight.shadowEnabled = false;
  ambientLight.parent = areaPivot;

  let giState: BuilderLamp["gi"];
  if (enableRsm) {
    const rsm = new ReflectiveShadowMap(scene, shadowLight, { width: rsmTextureSize, height: rsmTextureSize });
    rsm.enable = true;
    rsm.addMesh();
    const solution = new GIRSM(rsm);
    solution.numSamples = rsmNumSamples;
    solution.radius = rsmRadius;
    solution.intensity = rsmIntensity;
    solution.edgeArtifactCorrection = rsmEdgeCorrection;
    solution.rotateSample = rsmRotateSample;
    solution.noiseFactor = rsmNoiseFactor;
    solution.useFullTexture = rsmUseFullTexture;
    giState = { rsm, solution };
  }

  return {
    mesh: fixture,
    light: shadowLight,
    shadow,
    areaLight,
    auxiliaryLights: [ambientLight],
    gi: giState,
    key: "",
    color: color.clone(),
    anchorSurfaceId: "",
    local: { x: 0, y: 0, z: 0 },
    rotation: Quaternion.Identity(),
  };
}
</file>

<file path="src/fps/placement/placementTypes.ts">
import type { AbstractMesh, PointerInfo, Scene, UniversalCamera, Vector3 } from "babylonjs";
import type { ShadowNetwork } from "../lighting/shadowNetwork";
import type { GhostHost } from "./ghosts";
import type { SurfaceRegistry } from "./surfaces/surfaceRegistry";
import type { PlacementSolver } from "./placementSolver";
import type { ShipLampState, ShipWallState } from "../state/shipState";

export interface ShipStateActions {
  upsertWall(wall: ShipWallState): void;
  removeWall(wallId: string): void;
  upsertLamp(lamp: ShipLampState): void;
  removeLamp(lampId: string): void;
  setLampEnabled(lampId: string, enabled: boolean): void;
}

export interface ToolMetadata {
  toolId: string;
  key: string;
  structural?: boolean;
}

export interface ToolRuntimeContext {
  scene: Scene;
  camera: UniversalCamera;
  canvas: HTMLCanvasElement;
  shadowNetwork: ShadowNetwork;
  ghost: GhostHost;
  surfaceRegistry: SurfaceRegistry;
  placementSolver: PlacementSolver;
  withinRange(point?: Vector3 | null): boolean;
  requestPointerLock(): void;
  highlight(mesh?: AbstractMesh | null): void;
  removeMesh(mesh?: AbstractMesh | null): boolean;
  shipState: ShipStateActions;
}

export interface PlacementToolInstance {
  id: string;
  onActivate?(): void;
  onDeactivate?(): void;
  onPointerMove?(info: PointerInfo): void;
  onPointerDown?(info: PointerInfo): void;
  onPointerUp?(info: PointerInfo): void;
  onPointerLockChange?(isLocked: boolean): void;
  onKeyDown?(event: KeyboardEvent): void;
  onKeyUp?(event: KeyboardEvent): void;
  remove?(metadata: ToolMetadata, mesh: AbstractMesh): boolean;
  dispose?(): void;
}

export interface PlacementToolDefinition {
  id: string;
  label: string;
  icon: string;
  hotkey: string;
  create(context: ToolRuntimeContext, bootstrap?: unknown): PlacementToolInstance;
}

export interface PlacementState {
  activeToolId: string;
}
</file>

<file path="src/fps/placement/tools/lampTool.ts">
import { AbstractMesh, Color3, Matrix, MeshBuilder, PointerEventTypes, Quaternion, StandardMaterial } from "babylonjs";
import type { BuilderLamp, WallLampPlacement } from "../../types";
import { GRID_SIZE, INPUT_KEYS, LAMP_COLOR_PALETTE, WALL_LAMP_PLACEMENT } from "../../constants";
import { createLamp, lampKey, nextLampColor } from "../lampBuilder";
import type {
  PlacementToolDefinition,
  ToolMetadata,
  ToolRuntimeContext,
} from "../placementTypes";
import type { PlacementFrame } from "../surfaces/types";
import type { PlacementProfile } from "../placementSolver";

const TOOL_ID = "lamp";
const LAMP_PROFILE: PlacementProfile = {
  modes: [
    {
      mode: "wall-mount",
      constraints: {
        type: "wall-mount",
        grid: GRID_SIZE,
        itemSize: {
          width: WALL_LAMP_PLACEMENT.width,
          height: WALL_LAMP_PLACEMENT.height,
          depth: WALL_LAMP_PLACEMENT.depth,
        },
        offset: WALL_LAMP_PLACEMENT.offset,
        boundsPadding: {
          horizontal: 0.06,
          vertical: 0.08,
        },
      },
    },
  ],
};

function createPreviewMesh(context: ToolRuntimeContext) {
  const mesh = MeshBuilder.CreateBox(
    "lamp-tool-preview",
    {
      width: WALL_LAMP_PLACEMENT.width,
      height: WALL_LAMP_PLACEMENT.height,
      depth: WALL_LAMP_PLACEMENT.depth,
    },
    context.scene,
  );

  const material = new StandardMaterial("lamp-tool-preview-mat", context.scene);
  material.diffuseColor = new Color3(0.58, 0.78, 0.98);
  material.alpha = 0.38;
  material.specularColor = new Color3(0.2, 0.35, 0.5);
  material.emissiveColor = new Color3(0.32, 0.58, 0.86);
  material.backFaceCulling = false;
  mesh.material = material;
  mesh.isPickable = false;
  mesh.setEnabled(false);
  return mesh;
}

const isLampSurface = (mesh?: AbstractMesh | null) => {
  if (!mesh) {
    return false;
  }
  const metadata = mesh.metadata as Record<string, unknown> | undefined;
  if (!metadata) {
    return false;
  }
  if (metadata.toolId === "wall") {
    return true;
  }
  if (metadata.type === "ship-wall") {
    return true;
  }
  return false;
};

const frameToLampPlacement = (frame: PlacementFrame): WallLampPlacement | null => {
  if (frame.mode !== "wall-mount") {
    return null;
  }
  return {
    mesh: frame.mesh,
    position: frame.position.clone(),
    forward: frame.forward.clone(),
    right: frame.right.clone(),
    up: frame.up.clone(),
    surfaceId: frame.surfaceId,
    local: {
      x: Number(frame.local.x.toFixed(3)),
      y: Number(frame.local.y.toFixed(3)),
      z: Number(frame.local.z.toFixed(3)),
    },
  };
};

export const lampToolDefinition: PlacementToolDefinition = {
  id: TOOL_ID,
  label: "Lâmpada",
  icon: "◎",
  hotkey: INPUT_KEYS.lampMode,
  create: (context: ToolRuntimeContext, bootstrap?: unknown) => {
    const preview = createPreviewMesh(context);
    const lamps = new Map<string, BuilderLamp>();
    const initialLamps = Array.isArray(bootstrap) ? (bootstrap as BuilderLamp[]) : [];
    let dynamicLampCount = 0;
    initialLamps.forEach((lamp) => {
      lamps.set(lamp.key, lamp);
      const metadata = (lamp.mesh.metadata as Record<string, unknown>) ?? {};
      const isStructural = metadata.structural === true;
      const surfaceId =
        typeof metadata.surfaceId === "string" && metadata.surfaceId.length > 0
          ? metadata.surfaceId
          : lamp.anchorSurfaceId;
      const local = (metadata.local as WallLampPlacement["local"] | undefined) ?? lamp.local;
      lamp.mesh.metadata = {
        ...metadata,
        toolId: TOOL_ID,
        key: lamp.key,
        surfaceId,
        local,
        structural: isStructural,
      };
      context.shadowNetwork.registerDynamic(lamp.mesh);
      context.shadowNetwork.attachLamp(lamp);
      if (isStructural) {
        context.shipState.setLampEnabled(lamp.key, true);
        return;
      }
      dynamicLampCount += 1;
      context.shipState.upsertLamp({
        id: lamp.key,
        anchorSurfaceId: surfaceId,
        position: {
          x: Number(lamp.mesh.position.x.toFixed(5)),
          y: Number(lamp.mesh.position.y.toFixed(5)),
          z: Number(lamp.mesh.position.z.toFixed(5)),
        },
        rotation: {
          x: Number(lamp.rotation.x.toFixed(5)),
          y: Number(lamp.rotation.y.toFixed(5)),
          z: Number(lamp.rotation.z.toFixed(5)),
          w: Number(lamp.rotation.w.toFixed(5)),
        },
        color: {
          r: Number(lamp.color.r.toFixed(5)),
          g: Number(lamp.color.g.toFixed(5)),
          b: Number(lamp.color.b.toFixed(5)),
        },
        local: { ...local },
        structural: false,
        enabled: true,
      });
    });

    let pendingPlacement: WallLampPlacement | null = null;
    let colorIndex = dynamicLampCount % Math.max(LAMP_COLOR_PALETTE.length, 1);

    const hidePreview = () => {
      pendingPlacement = null;
      context.ghost.hide();
    };

    const updatePreview = (placement: WallLampPlacement | null) => {
      if (!placement) {
        hidePreview();
        return;
      }
      pendingPlacement = placement;
      preview.position.copyFrom(placement.position);

      const basis = new Matrix();
      Matrix.FromXYZAxesToRef(placement.right, placement.up, placement.forward, basis);
      const rotation = Quaternion.FromRotationMatrix(basis);
      preview.rotationQuaternion = rotation;
      context.ghost.show(preview);
    };

    const placeLamp = (placement: WallLampPlacement) => {
      const key = lampKey(placement);
      if (lamps.has(key)) {
        return;
      }

      const color = nextLampColor(colorIndex);
      colorIndex = (colorIndex + 1) % LAMP_COLOR_PALETTE.length;

      const lamp = createLamp(context.scene, placement, color);
      lamp.mesh.metadata = {
        toolId: TOOL_ID,
        key,
        surfaceId: placement.surfaceId,
        local: placement.local,
        structural: false,
      };
      lamps.set(key, lamp);
      context.shadowNetwork.registerDynamic(lamp.mesh);
      context.shadowNetwork.attachLamp(lamp);
      context.shipState.upsertLamp({
        id: key,
        anchorSurfaceId: placement.surfaceId,
        position: {
          x: Number(placement.position.x.toFixed(5)),
          y: Number(placement.position.y.toFixed(5)),
          z: Number(placement.position.z.toFixed(5)),
        },
        rotation: {
          x: Number(lamp.rotation.x.toFixed(5)),
          y: Number(lamp.rotation.y.toFixed(5)),
          z: Number(lamp.rotation.z.toFixed(5)),
          w: Number(lamp.rotation.w.toFixed(5)),
        },
        color: {
          r: Number(lamp.color.r.toFixed(5)),
          g: Number(lamp.color.g.toFixed(5)),
          b: Number(lamp.color.b.toFixed(5)),
        },
        local: { ...lamp.local },
        structural: false,
        enabled: true,
      });
    };

    const pickSurface = () =>
      context.scene.pick(
        context.scene.pointerX,
        context.scene.pointerY,
        (mesh) => isLampSurface(mesh),
        false,
      );

    return {
      id: TOOL_ID,
      onActivate: () => {
        hidePreview();
      },
      onDeactivate: () => {
        hidePreview();
      },
      onPointerLockChange: (isLocked: boolean) => {
        if (!isLocked) {
          hidePreview();
        }
      },
      onPointerMove: (pointerInfo) => {
        if (pointerInfo.type !== PointerEventTypes.POINTERMOVE) {
          return;
        }

        const pick = pickSurface();
        if (!context.withinRange(pick?.pickedPoint)) {
          updatePreview(null);
          return;
        }

        if (!pick || !pick.hit) {
          updatePreview(null);
          return;
        }

        const frame = context.placementSolver.solve(LAMP_PROFILE, pick);
        const placement = frame ? frameToLampPlacement(frame) : null;
        if (!placement) {
          updatePreview(null);
          return;
        }

        updatePreview(placement);
      },
      onPointerDown: (pointerInfo) => {
        if (pointerInfo.type !== PointerEventTypes.POINTERDOWN) {
          return;
        }

        if (pointerInfo.event.button !== 0) {
          return;
        }

        const placement =
          pendingPlacement ??
          (() => {
            const pick = pickSurface();
            if (!context.withinRange(pick?.pickedPoint)) {
              return null;
            }
            const frame = context.placementSolver.solve(LAMP_PROFILE, pick ?? null);
            return frame ? frameToLampPlacement(frame) : null;
          })();

        if (!placement) {
          return;
        }

        placeLamp(placement);
        updatePreview(placement);
      },
      remove: (metadata: ToolMetadata) => {
        if (metadata.toolId !== TOOL_ID) {
          return false;
        }
        const entry = lamps.get(metadata.key);
        if (!entry) {
          return false;
        }
        const isStructural = metadata.structural === true;
        context.shadowNetwork.detachLamp(entry);
        context.shadowNetwork.unregisterDynamic(entry.mesh);
        entry.shadow.dispose();
        entry.light.dispose();
        entry.areaLight?.dispose();
        entry.fillLight?.dispose();
        entry.auxiliaryLights?.forEach((aux) => aux.dispose());
        if (entry.gi) {
          entry.gi.solution.dispose();
          entry.gi.rsm.dispose();
        }
        entry.mesh.dispose(false, true);
        lamps.delete(metadata.key);
        if (isStructural) {
          context.shipState.setLampEnabled(metadata.key, false);
        } else {
          context.shipState.removeLamp(metadata.key);
        }
        return true;
      },
      dispose: () => {
        context.ghost.hide();
        preview.dispose(false, true);
        lamps.forEach((lamp) => {
          context.shadowNetwork.detachLamp(lamp);
          context.shadowNetwork.unregisterDynamic(lamp.mesh);
          lamp.shadow.dispose();
          lamp.light.dispose();
          lamp.areaLight?.dispose();
          lamp.fillLight?.dispose();
          lamp.auxiliaryLights?.forEach((aux) => aux.dispose());
          if (lamp.gi) {
            lamp.gi.solution.dispose();
            lamp.gi.rsm.dispose();
          }
          lamp.mesh.dispose(false, true);
        });
        lamps.clear();
        pendingPlacement = null;
      },
    };
  },
};
</file>

<file path="src/fps/constants.ts">
import { Color3 } from "babylonjs";

// Core metric references keep the scene grounded in human scale (meters, kilograms, seconds).
export const HUMAN_DIMENSIONS = {
  height: 1.8,
  eyeLevel: 1.72,
} as const;

export const SHIP_INTERIOR_DIMENSIONS = {
  deckClearance: 2.1,
  doorHeight: 1.85,
} as const;

export const GRID_SIZE = 0.5;

export const WALL_DIMENSIONS = {
  width: 1,
  height: SHIP_INTERIOR_DIMENSIONS.deckClearance,
  thickness: 0.18,
  footingDepth: 0.04,
} as const;

export const HULL_DIMENSIONS = {
  width: 4.2,
  length: 9.6,
  height: SHIP_INTERIOR_DIMENSIONS.deckClearance,
} as const;

export const LAMP_DIMENSIONS = {
  height: 1.6,
  radius: 0.2,
  stemRadius: 0.05,
} as const;

export const CAMERA_SETTINGS = {
  speed: 1.6,
  sprintMultiplier: 1.75,
  minZ: 0.05,
  maxZ: 250,
  angularSensibility: 2600,
  inertia: 0.05,
  ellipsoid: { x: 0.35, y: 0.9, z: 0.35 },
  ellipsoidOffset: { x: 0, y: 0.9, z: 0 },
  eyeLevel: HUMAN_DIMENSIONS.eyeLevel,
} as const;

export const WALL_LIGHT_STRIP = {
  count: 6,
  height: 1.95,
  inset: 0.28,
  tilt: -0.18,
  cone: Math.PI / 3.1,
  range: 14,
  warm: {
    color: new Color3(1, 0.83, 0.58),
    intensity: 1.25,
  },
  cool: {
    color: new Color3(0.58, 0.8, 1),
    intensity: 1.15,
  },
} as const;

export const INPUT_KEYS = {
  move: {
    forward: 87, // W
    left: 65, // A
    backward: 83, // S
    right: 68, // D
  },
  rotate: "KeyR",
  sprint: ["ShiftLeft", "ShiftRight"],
  wallMode: "Digit1",
  lampMode: "Digit2",
  deleteMode: "Digit3",
} as const;

export const LAMP_COLOR_PALETTE = [
  new Color3(0.98, 0.82, 0.62),
  new Color3(0.72, 0.84, 1),
] as const;

export const WALL_LAMP_PLACEMENT = {
  width: 1.15,
  height: 0.12,
  depth: 0.22,
  offset: 0.06,
  tilt: 0.45,
  shadowMapSize: 640,
  intensity: 1.9,
  range: 11,
} as const;

export const LIGHTING_LIMITS = {
  maxSimultaneousLights: 24,
} as const;

export const SELECTION_OUTLINE_COLOR = new Color3(0.2, 0.65, 1);

export const INTERACTION_RANGE = 16;
</file>

<file path="AGENTS.md">
# Starwatch Field Manual

Welcome aboard the Mad Dash Initiative. We rebuilt the project structure mid-flight to chase a new goal: a first-person ship builder you can live inside, driven by AI automation. This document keeps everyone oriented—especially as we keep the previous stack mothballed for reference.

## Current Timeline
- **2025-10-18** — Operation One Shot: we froze the original chat/editor/game UI in `src/legacy/` and spun up a fresh FPS hangar to stress-test wall placement, rotation, and general feel.
- Earlier commits predate the reset and live entirely inside the legacy tree; treat them as historical artifacts unless you are backporting specific ideas.

## Code Constellation
- `src/` now hosts the new MVP:
  - `App.tsx`, `main.tsx` — minimal bootstrap for the builder prototype.
  - `fps/ShipBuilderCanvas.tsx` — Babylon.js scene for first-person movement, placement tooling, and HUD overlays.
- Placement runtime highlights:
  - `fps/core/sceneContext.ts` builds the hangar hull, registers static meshes, and now publishes a `SurfaceRegistry`.
  - `fps/placement/surfaces/` defines pluggable surface adapters (`WallSurface`, `FloorSurface`, …); every pickable surface registers here with consistent normals, snap grids, and offsets.
  - `fps/placement/placementSolver.ts` takes a tool profile (modes + constraints) and resolves placement frames from ray picks, so tools no longer manage Babylon math directly.
  - Tools (e.g., `lampTool`, `wallTool`) receive the shared solver via `ToolRuntimeContext` and only worry about preview meshes and item lifecycles. Adding a new “crate” that lives on the floor (or multi-surface items) is now a matter of declaring allowed modes in the profile and registering the relevant surfaces.
- `src/legacy/` shelters the previous React panels, HAL wiring, and Babylon scene (`game/`, `ui/`, `hal/`, plus old entry points). Use this when you need to reference assets or revive older features without polluting the new loop.
- `dist/`, `docs/`, and `releases/` retain their original purposes; respect `.gitignore` for generated assets.

## Build & Run Checklist
- `pnpm install` — install dependencies (Babylon.js already bundled; expect large builds).
- `pnpm dev` — Vite dev server for rapid iteration on the FPS builder.
- `pnpm build` — TypeScript check + production bundle (watch for >500 kB chunk warnings due to Babylon; we will code-split later).
- `pnpm preview` — smoke-test the built assets.
- Keep `pnpm test` reserved for the future Vitest suite (no specs yet post-reset).

## Coding Playbook
- Strict TypeScript—no `any`. Use Babylon types (`Mesh`, `PointerInfo`, etc.) to keep editor assistance sharp.
- Two-space indent, camelCase helpers, PascalCase React components.
- Inline styles acceptable for HUD prototypes; migrate to shared styling once components settle.
- Add comments only where Babylon abstractions or math need extra context.

### Lighting & Shadows (2025-10-21)
- Babylon spot/area lights inherit their parent transform; set the light up in local space so the `forward` axis actually matches the emitter. We now parent a pivot node to each fixture, transform the desired world frame into that local basis, and attach both the area light and the shadow-casting spotlight to the pivot.
- Keep `Vector3.Backward()` as the local forward for the spotlight once it is parented to the pivot. Feeding world-space forward directly into the constructor caused the shadow cone to flip when fixtures were rotated.
- Clamp shadow bias aggressively (`0.00022` / `0.0035` for bias/normal bias) and pull `shadowMinZ` close to zero (`≈0.008`) so thin walls stay grounded without acne.
- Give walls a shallow footing (`WALL_DIMENSIONS.footingDepth = 0.04`) and sink instanced walls by half that depth; otherwise light leaks under the panels even if the mesh appears flush.
- Disable `forceBackFacesOnly` on all generators. It looked tempting for RSM GI, but it ignored the illuminated faces and inverted the shadow direction.

## Testing & Telemetry
- Vitest + React Testing Library remain the plan. For now, favor small utility tests when you introduce deterministic builders or data serializers.
- Record manual repro steps when you tweak input handling (mouse lock, sprint, rotation) so the next agent can verify quickly.

## Collaboration Protocols
- Conventional Commits (`feat:`, `fix:`, `chore:`…). Branch as `feat/builder-controls` or similar.
- PRs: include summary GIFs or short clips showing the builder interactions; list manual verification commands (`pnpm dev`, `pnpm build`).
- Leave the legacy code untouched unless you are extracting assets or documenting behavior; if you do open it, call it out in your PR description.

## Security & Configuration
- `.env` continues to be ignored; share sanitized `.env.example` values for any future HAL/LLM work (`OPENAI_API_KEY`, `OPENAI_MODEL` placeholders).
- Environment variables load through `import.meta.env.OPENAI_*`; validate in both dev and preview builds.

## Mission Ahead
- Short term: expand the builder with inventory selection, persistence, and undo/redo.
- Mid term: bring back HAL control, AI crew, and automation routines on top of the new world state.
- Long term: merge the rebuilt FPS core with narrative/chat layers once the construction loop feels right. Cross-check ideas with `MANIFESTO.md` whenever we plan new systems; that living document still captures the grand strategy and narrative tone we aim to restore.

Document the weird, celebrate the breakthroughs, and keep shipping. The hangar is ours now.
</file>

<file path="src/fps/types.ts">
import type {
  AbstractMesh,
  Color3,
  GIRSM,
  Light,
  Mesh,
  RectAreaLight,
  ReflectiveShadowMap,
  ShadowGenerator,
  ShadowLight,
  Quaternion,
  Vector3,
} from "babylonjs";

export interface BuilderWall {
  mesh: Mesh;
  key: string;
  rotation: number; // degrees around Y
}

export interface BuilderLamp {
  mesh: Mesh;
  light: ShadowLight;
  shadow: ShadowGenerator;
  areaLight?: RectAreaLight;
  fillLight?: Light;
  auxiliaryLights?: Light[];
  gi?: {
    rsm: ReflectiveShadowMap;
    solution: GIRSM;
  };
  key: string;
  color: Color3;
  anchorSurfaceId: string;
  local: { x: number; y: number; z: number };
  rotation: Quaternion;
}

export interface WallLampPlacement {
  mesh: AbstractMesh;
  position: Vector3;
  forward: Vector3;
  right: Vector3;
  up: Vector3;
  surfaceId: string;
  local: { x: number; y: number; z: number };
}
</file>

<file path="src/fps/placement/placementController.ts">
import {
  AbstractMesh,
  PointerEventTypes,
  PointerInfo,
  Scene,
  UniversalCamera,
  Vector3,
} from "babylonjs";
import { CAMERA_SETTINGS, INPUT_KEYS, INTERACTION_RANGE, SELECTION_OUTLINE_COLOR } from "../constants";
import type { ShadowNetwork } from "../lighting/shadowNetwork";
import type { BuilderLamp, BuilderWall } from "../types";
import type { GhostHost } from "./ghosts";
import type {
  PlacementState,
  PlacementToolInstance,
  ShipStateActions,
  ToolMetadata,
  ToolRuntimeContext,
} from "./placementTypes";
import { TOOL_DEFINITION_BY_ID, TOOL_DEFINITIONS } from "./tools";
import type { SurfaceRegistry } from "./surfaces/surfaceRegistry";
import { createPlacementSolver } from "./placementSolver";
import type { ShipStore } from "../state/shipStore";

interface PlacementControllerOptions {
  scene: Scene;
  canvas: HTMLCanvasElement;
  camera: UniversalCamera;
  ghost: GhostHost;
  shadowNetwork: ShadowNetwork;
  surfaceRegistry: SurfaceRegistry;
  initialWalls?: BuilderWall[];
  initialLamps?: BuilderLamp[];
  shipStore: ShipStore;
}

export interface PlacementController {
  getState(): PlacementState;
  setActiveTool(toolId: string): void;
  subscribe(listener: (state: PlacementState) => void): () => void;
  dispose(): void;
}

export function createPlacementController(options: PlacementControllerOptions): PlacementController {
  const { scene, canvas, camera, ghost, shadowNetwork, surfaceRegistry, shipStore } = options;
  const initialWalls = options.initialWalls ?? [];
  const initialLamps = options.initialLamps ?? [];
  const placementSolver = createPlacementSolver(surfaceRegistry);
  const shipActions: ShipStateActions = {
    upsertWall: (wall) => shipStore.upsertWall(wall),
    removeWall: (wallId) => shipStore.removeWall(wallId),
    upsertLamp: (lamp) => shipStore.upsertLamp(lamp),
    removeLamp: (lampId) => shipStore.removeLamp(lampId),
    setLampEnabled: (lampId, enabled) => shipStore.setLampEnabled(lampId, enabled),
  };

  const defaultToolId = TOOL_DEFINITIONS[0]?.id ?? "wall";

  const state: PlacementState = {
    activeToolId: defaultToolId,
  };

  const toolBootstrap = new Map<string, unknown>();
  if (initialWalls.length > 0) {
    toolBootstrap.set("wall", initialWalls);
  }
  if (initialLamps.length > 0) {
    toolBootstrap.set("lamp", initialLamps);
  }

  const listeners = new Set<(snapshot: PlacementState) => void>();
  const toolInstances = new Map<string, PlacementToolInstance>();
  const sprintKeys = new Set<string>(Array.from(INPUT_KEYS.sprint));
  const hotkeyToToolId = new Map<string, string>();
  const baseCameraSpeed = CAMERA_SETTINGS.speed;

  let activeTool: PlacementToolInstance | null = null;
  let highlighted: AbstractMesh | null = null;

  const notify = () => {
    const snapshot: PlacementState = { ...state };
    listeners.forEach((listener) => listener(snapshot));
  };

  const clearHighlight = () => {
    if (!highlighted || highlighted.isDisposed()) {
      highlighted = null;
      return;
    }
    highlighted.renderOutline = false;
    highlighted = null;
  };

  const applyHighlight = (mesh?: AbstractMesh | null) => {
    const target = mesh ?? null;
    if (!target) {
      clearHighlight();
      return;
    }

    if (highlighted === target) {
      return;
    }

    clearHighlight();
    target.renderOutline = true;
    target.outlineColor = SELECTION_OUTLINE_COLOR;
    target.outlineWidth = 0.018;
    highlighted = target;
  };

  const withinRange = (point?: Vector3 | null) => {
    if (!point) {
      return false;
    }
    return Vector3.Distance(camera.position, point) <= INTERACTION_RANGE;
  };

  hotkeyToToolId.clear();
  TOOL_DEFINITIONS.forEach((definition) => {
    hotkeyToToolId.set(definition.hotkey, definition.id);
  });

  const runtimeContext: ToolRuntimeContext = {
    scene,
    camera,
    canvas,
    shadowNetwork,
    ghost,
    surfaceRegistry,
    placementSolver,
    shipState: shipActions,
    withinRange,
    requestPointerLock: () => {
      if (document.pointerLockElement !== canvas) {
        canvas.requestPointerLock();
      }
    },
    highlight: (mesh?: AbstractMesh | null) => {
      if (!mesh) {
        clearHighlight();
        return;
      }
      applyHighlight(mesh);
    },
    removeMesh: (mesh?: AbstractMesh | null) => {
      const removed = removeMesh(mesh);
      if (removed) {
        clearHighlight();
      }
      return removed;
    },
  };

  const getToolInstance = (toolId: string): PlacementToolInstance | null => {
    const existing = toolInstances.get(toolId);
    if (existing) {
      return existing;
    }

    const definition = TOOL_DEFINITION_BY_ID.get(toolId);
    if (!definition) {
      return null;
    }

    const bootstrap = toolBootstrap.get(toolId);
    const instance = definition.create(runtimeContext, bootstrap);
    toolInstances.set(toolId, instance);
    return instance;
  };

  toolBootstrap.forEach((_, toolId) => {
    if (toolId !== state.activeToolId) {
      getToolInstance(toolId);
    }
  });

  const removeMesh = (mesh?: AbstractMesh | null): boolean => {
    if (!mesh) {
      return false;
    }

    const metadata = mesh.metadata as ToolMetadata | undefined;
    if (
      !metadata ||
      typeof metadata.toolId !== "string" ||
      typeof metadata.key !== "string"
    ) {
      return false;
    }

    const tool = getToolInstance(metadata.toolId);
    if (!tool || !tool.remove) {
      return false;
    }

    const removed = tool.remove(metadata, mesh);
    if (removed && mesh === highlighted) {
      clearHighlight();
    }
    return removed;
  };

  const setActiveToolInternal = (toolId: string, fromHotkey = false) => {
    if (state.activeToolId === toolId && !fromHotkey) {
      return;
    }

    const next = getToolInstance(toolId);
    if (!next) {
      return;
    }

    if (activeTool && activeTool.onDeactivate) {
      activeTool.onDeactivate();
    }

    activeTool = next;
    state.activeToolId = toolId;
    if (activeTool.onActivate) {
      activeTool.onActivate();
    }
    notify();
  };

  const attemptRemoveAtPointer = () => {
    const pick = scene.pick(
      scene.pointerX,
      scene.pointerY,
      (mesh) => {
        const metadata = mesh?.metadata as { toolId?: unknown } | undefined;
        return typeof metadata?.toolId === "string";
      },
    );

    if (!withinRange(pick?.pickedPoint)) {
      return false;
    }

    return removeMesh(pick?.pickedMesh ?? null);
  };

  const pointerObserver = scene.onPointerObservable.add((pointerInfo: PointerInfo) => {
    switch (pointerInfo.type) {
      case PointerEventTypes.POINTERMOVE:
        activeTool?.onPointerMove?.(pointerInfo);
        break;
      case PointerEventTypes.POINTERDOWN: {
        if (pointerInfo.event.button === 0) {
          runtimeContext.requestPointerLock();
        }

        if (pointerInfo.event.button === 2) {
          pointerInfo.event.preventDefault();
          attemptRemoveAtPointer();
          return;
        }

        activeTool?.onPointerDown?.(pointerInfo);
        break;
      }
      case PointerEventTypes.POINTERUP:
        activeTool?.onPointerUp?.(pointerInfo);
        break;
      default:
        break;
    }
  });

  const handleKeyDown = (event: KeyboardEvent) => {
    if (sprintKeys.has(event.code)) {
      camera.speed = baseCameraSpeed * CAMERA_SETTINGS.sprintMultiplier;
    }

    const toolId = hotkeyToToolId.get(event.code);
    if (toolId) {
      setActiveToolInternal(toolId, true);
      return;
    }

    activeTool?.onKeyDown?.(event);
  };

  const handleKeyUp = (event: KeyboardEvent) => {
    if (sprintKeys.has(event.code)) {
      camera.speed = baseCameraSpeed;
    }

    activeTool?.onKeyUp?.(event);
  };

  const handlePointerLockChange = () => {
    const locked = document.pointerLockElement === canvas;
    if (!locked) {
      ghost.hide();
      clearHighlight();
    }
    activeTool?.onPointerLockChange?.(locked);
  };

  const handleContextMenu = (event: MouseEvent) => {
    event.preventDefault();
  };

  window.addEventListener("keydown", handleKeyDown);
  window.addEventListener("keyup", handleKeyUp);
  document.addEventListener("pointerlockchange", handlePointerLockChange);
  canvas.addEventListener("contextmenu", handleContextMenu);

  const initialTool = getToolInstance(state.activeToolId);
  activeTool = initialTool;
  activeTool?.onActivate?.();

  return {
    getState: () => ({ ...state }),
    setActiveTool: (toolId: string) => {
      setActiveToolInternal(toolId);
    },
    subscribe: (listener: (snapshot: PlacementState) => void) => {
      listeners.add(listener);
      listener({ ...state });
      return () => {
        listeners.delete(listener);
      };
    },
    dispose: () => {
      scene.onPointerObservable.remove(pointerObserver);
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
      document.removeEventListener("pointerlockchange", handlePointerLockChange);
      canvas.removeEventListener("contextmenu", handleContextMenu);

      if (activeTool && activeTool.onDeactivate) {
        activeTool.onDeactivate();
      }

      toolInstances.forEach((tool) => {
        tool.dispose?.();
      });
      toolInstances.clear();

      ghost.clear();
      clearHighlight();
      listeners.clear();
      hotkeyToToolId.clear();
    },
  };
}
</file>

<file path="src/fps/placement/wallBuilder.ts">
import { Matrix, MeshBuilder, PBRMaterial, Vector3 } from "babylonjs";
import type { Scene } from "babylonjs";
import { GRID_SIZE, HULL_DIMENSIONS, WALL_DIMENSIONS, LIGHTING_LIMITS } from "../constants";
import type { BuilderWall } from "../types";
import { clamp, degreesToRadians } from "../utils/math";
import { applyHangarTextures, disposeHangarMaterial, getHangarTextureSet } from "../core/hangarTextures";

export function snapWallPosition(point: Vector3) {
  const halfWidth = HULL_DIMENSIONS.width / 2 - WALL_DIMENSIONS.width / 2;
  const halfLength = HULL_DIMENSIONS.length / 2 - WALL_DIMENSIONS.width / 2;

  const snappedX = clamp(
    Math.round(point.x / GRID_SIZE) * GRID_SIZE,
    -halfWidth,
    halfWidth,
  );
  const snappedZ = clamp(
    Math.round(point.z / GRID_SIZE) * GRID_SIZE,
    -halfLength,
    halfLength,
  );

  return new Vector3(snappedX, WALL_DIMENSIONS.height / 2, snappedZ);
}

export function wallKey(position: Vector3, rotation: number) {
  return `${position.x}:${position.y}:${position.z}:${rotation}`;
}

export function createWall(scene: Scene, position: Vector3, rotation: number): BuilderWall {
  const footingDepth = WALL_DIMENSIONS.footingDepth ?? 0;
  const boxHeight = WALL_DIMENSIONS.height + footingDepth;
  const wallMesh = MeshBuilder.CreateBox(
    `builder-wall-${Date.now()}`,
    {
      width: WALL_DIMENSIONS.width,
      height: boxHeight,
      depth: WALL_DIMENSIONS.thickness,
    },
    scene,
  );

  wallMesh.position = position.clone();
  wallMesh.position.y -= footingDepth / 2;
  wallMesh.rotation.y = degreesToRadians(rotation);
  wallMesh.checkCollisions = true;
  wallMesh.receiveShadows = true;

  const armorTextures = getHangarTextureSet(scene, "armor");
  const material = new PBRMaterial(`builder-wall-pbr-${Date.now()}`, scene);
  const tileU = Math.max(WALL_DIMENSIONS.width, WALL_DIMENSIONS.height) * 0.9;
  const tileV = WALL_DIMENSIONS.height * 0.95;
  applyHangarTextures(material, armorTextures, { u: tileU, v: tileV });
  material.ambientTextureStrength = 0.94;
  material.useAmbientInGrayScale = true;
  material.metallic = 0.36;
  material.roughness = 0.88;
  material.microSurface = 0.8;
  material.environmentIntensity = 0.7;
  material.specularIntensity = 1.0;
  material.backFaceCulling = true;
  material.twoSidedLighting = false;
  material.maxSimultaneousLights = LIGHTING_LIMITS.maxSimultaneousLights;
  wallMesh.material = material;

  const key = wallKey(position, rotation);
  const rotationMatrix = Matrix.RotationY(wallMesh.rotation.y);
  const inward = Vector3.TransformNormal(Vector3.Forward(), rotationMatrix).scale(-1).normalize();
  const up = Vector3.Up();

  wallMesh.metadata = {
    toolId: "wall",
    key,
    surfaceId: key,
    lampOrientation: {
      forward: inward.asArray(),
      up: up.asArray(),
    },
    textureTiling: { u: tileU, v: tileV },
  };

  wallMesh.onDisposeObservable.add(() => {
    disposeHangarMaterial(material);
  });

  return {
    mesh: wallMesh,
    key,
    rotation,
  };
}
</file>

<file path="src/App.tsx">
import { ShipBuilderCanvas } from "./fps/ShipBuilderCanvas";

export default function App() {
  return (
    <div
      style={{
        position: "relative",
        width: "100vw",
        height: "100vh",
        overflow: "hidden",
        background: "#05060a",
        color: "#f1f5f9",
        fontFamily: "'Segoe UI', Roboto, sans-serif",
      }}
    >
      <ShipBuilderCanvas />
      <div
        style={{
          position: "absolute",
          top: 16,
          left: 16,
          padding: "12px 16px",
          background: "rgba(15, 23, 42, 0.72)",
          border: "1px solid rgba(148, 163, 184, 0.32)",
          borderRadius: 8,
          maxWidth: 360,
          backdropFilter: "blur(10px)",
        }}
      >
        <h1 style={{ fontSize: 18, margin: "0 0 8px" }}>Ship Builder MVP</h1>
        <p style={{ margin: "6px 0", fontSize: 13, lineHeight: 1.4 }}>
          Explore the hangar in first-person and experiment with dropping walls
          inside the rectangular hull. This pass focuses on grid snapping and
          quick prototyping of construction flow.
        </p>
        <ul style={{ margin: "6px 0 0", paddingLeft: 16, fontSize: 13 }}>
          <li>WASD — move / Shift — sprint</li>
          <li>Mouse — look (click canvas to lock)</li>
          <li>1 — wall mode / 2 — lamp mode / 3 — remove mode</li>
          <li>Left click — place item / Delete mode + click (ou botão direito) — remove</li>
          <li>R — rotate walls (90° steps)</li>
          <li>Esc — release cursor lock</li>
        </ul>
        <p style={{ margin: "10px 0 0", fontSize: 12, opacity: 0.85 }}>
          Lamps cycle between warm and cool tones and cast soft shadows—perfect
          for finding that cozy blue-gold balance.
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/fps/ShipBuilderCanvas.tsx">
import { useEffect, useRef, useState } from "react";
import { createSceneContext } from "./core/sceneContext";
import { createPlayerController } from "./core/playerController";
import { createPlacementController } from "./placement/placementController";
import type { PlacementController } from "./placement/placementController";
import { createGhostHost } from "./placement/ghosts";
import type { PlacementState } from "./placement/placementTypes";
import { TOOL_DEFINITIONS } from "./placement/tools";
import { createShadowNetwork } from "./lighting/shadowNetwork";
import { ShipStore } from "./state/shipStore";
import { createShipPersistence, loadShipState } from "./state/shipPersistence";
import { hydrateShipAssets } from "./state/shipHydrator";
import { PlayerStore } from "./state/playerStore";
import { createPlayerPersistence, loadPlayerState } from "./state/playerPersistence";
import { registerBaselinePlayerModules } from "./state/playerModules";
import type { BuilderLamp } from "./types";
import { serializeColor, serializeQuaternion, serializeVector3 } from "./state/shipState";

const defaultToolId = TOOL_DEFINITIONS[0]?.id ?? "wall";

function formatHotkey(code: string) {
  if (code.startsWith("Digit")) {
    return code.slice(5);
  }
  if (code.startsWith("Key")) {
    return code.slice(3);
  }
  if (code.startsWith("Numpad")) {
    return `Num${code.slice(6)}`;
  }
  if (code.endsWith("Arrow")) {
    return code.replace("Arrow", "");
  }
  if (code === "ShiftLeft" || code === "ShiftRight") {
    return "Shift";
  }
  return code;
}

export function ShipBuilderCanvas() {
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const overlayRef = useRef<HTMLDivElement | null>(null);
  const controllerRef = useRef<PlacementController | null>(null);
  const shipStoreRef = useRef<ShipStore | null>(null);
  const playerStoreRef = useRef<PlayerStore | null>(null);
  const [placementState, setPlacementState] = useState<PlacementState>({
    activeToolId: defaultToolId,
  });

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) {
      return;
    }

    if (!shipStoreRef.current) {
      shipStoreRef.current = new ShipStore();
    }
    const shipStore = shipStoreRef.current;
    const persistedShipState = loadShipState();
    if (persistedShipState) {
      shipStore.replace(persistedShipState);
    }

    if (!playerStoreRef.current) {
      const persistedPlayer = loadPlayerState();
      playerStoreRef.current = new PlayerStore(persistedPlayer ?? undefined);
      registerBaselinePlayerModules(playerStoreRef.current);
    }
    const playerStore = playerStoreRef.current;
    if (!playerStore) {
      return;
    }

    const disposeStructuralLamp = (lamp: BuilderLamp) => {
      lamp.shadow.dispose();
      lamp.light.dispose();
      lamp.areaLight?.dispose();
      lamp.fillLight?.dispose();
      lamp.auxiliaryLights?.forEach((aux) => aux.dispose());
      lamp.gi?.solution.dispose();
      lamp.gi?.rsm.dispose();
      lamp.mesh.dispose(false, true);
    };

    const sceneContext = createSceneContext(canvas);
    const structuralLamps: BuilderLamp[] = [];
    sceneContext.structuralLamps.forEach((lamp) => {
      const key = lamp.key;
      if (!key) {
        structuralLamps.push(lamp);
        return;
      }

      const currentSnapshot = shipStore.getSnapshot();
      const existing = currentSnapshot.lamps[key];
      const local = lamp.local ?? { x: 0, y: 0, z: 0 };

      if (!existing) {
        shipStore.upsertLamp({
          id: key,
          anchorSurfaceId: lamp.anchorSurfaceId,
          position: serializeVector3(lamp.mesh.position.x, lamp.mesh.position.y, lamp.mesh.position.z),
          rotation: serializeQuaternion(lamp.rotation.x, lamp.rotation.y, lamp.rotation.z, lamp.rotation.w),
          color: serializeColor(lamp.color.r, lamp.color.g, lamp.color.b),
          local: { ...local },
          structural: true,
          enabled: true,
        });
      } else {
        if (existing.enabled === false) {
          disposeStructuralLamp(lamp);
          return;
        }
        if (!existing.structural || existing.enabled === undefined) {
          shipStore.upsertLamp({
            ...existing,
            structural: true,
            enabled: existing.enabled ?? true,
          });
        }
      }

      lamp.mesh.metadata = {
        ...(lamp.mesh.metadata as Record<string, unknown> | undefined),
        toolId: "lamp",
        key,
        structural: true,
        surfaceId: lamp.anchorSurfaceId,
        local,
      };
      structuralLamps.push(lamp);
    });
    sceneContext.structuralLamps = structuralLamps;
    const ghost = createGhostHost();
    const shadowNetwork = createShadowNetwork(
      structuralLamps.map((lamp) => lamp.shadow),
    );
    const staticMeshes = [sceneContext.floor, ...sceneContext.staticMeshes];
    structuralLamps.forEach((lamp) => {
      shadowNetwork.registerDynamic(lamp.mesh);
      shadowNetwork.attachLamp(lamp);
    });
    shadowNetwork.registerStatic(staticMeshes);

    const playerController = createPlayerController({
      scene: sceneContext.scene,
      canvas,
      store: playerStore,
    });

    const hydratedAssets = hydrateShipAssets(sceneContext.scene, shipStore.getSnapshot());

    const placementController = createPlacementController({
      scene: sceneContext.scene,
      canvas,
      camera: playerController.camera,
      ghost,
      shadowNetwork,
      surfaceRegistry: sceneContext.surfaceRegistry,
      initialWalls: hydratedAssets.walls,
      initialLamps: [...structuralLamps, ...hydratedAssets.lamps],
      shipStore,
    });
    controllerRef.current = placementController;
    const unsubscribePlacement = placementController.subscribe(setPlacementState);
    const persistence = createShipPersistence(shipStore);
    const playerPersistence = createPlayerPersistence(playerStore);

    let statsHandle = 0;
    let lastSample = 0;
    const updateOverlay = (timestamp: number) => {
      statsHandle = requestAnimationFrame(updateOverlay);
      if (!overlayRef.current) {
        return;
      }
      if (timestamp - lastSample < 250) {
        return;
      }
      lastSample = timestamp;

      const fps = sceneContext.engine.getFps();
      const meshCount = sceneContext.scene.meshes.length;
      const lightCount = sceneContext.scene.lights.length;
      const shadowedLights = sceneContext.scene.lights.filter((light) => light.shadowEnabled).length;
      const camera = playerController.camera.position;

      overlayRef.current.textContent = [
        `FPS: ${fps.toFixed(1)}`,
        `Meshes: ${meshCount}`,
        `Lights: ${lightCount} (shadowed: ${shadowedLights})`,
        `Camera: (${camera.x.toFixed(2)}, ${camera.y.toFixed(2)}, ${camera.z.toFixed(2)})`,
      ].join("\n");
    };
    statsHandle = requestAnimationFrame(updateOverlay);

    return () => {
      persistence.flush();
      persistence.dispose();
      playerPersistence.flush();
      playerPersistence.dispose();
      unsubscribePlacement();
      placementController.dispose();
      controllerRef.current = null;
      ghost.dispose();
      shadowNetwork.dispose();
      playerController.dispose();
      sceneContext.dispose();
      cancelAnimationFrame(statsHandle);
    };
  }, []);

  const handleToolClick = (toolId: string) => () => {
    controllerRef.current?.setActiveTool(toolId);
  };

  const toolbarItems = TOOL_DEFINITIONS.map((tool) => ({
    id: tool.id,
    label: tool.label,
    hint: formatHotkey(tool.hotkey),
    icon: tool.icon,
  }));

  return (
    <div
      style={{
        position: "relative",
        width: "100%",
        height: "100%",
      }}
    >
      <canvas
        ref={canvasRef}
        style={{
          width: "100%",
          height: "100%",
          display: "block",
        }}
      />
      <div
        style={{
          position: "absolute",
          left: "50%",
          bottom: 24,
          transform: "translateX(-50%)",
          display: "flex",
          gap: 12,
          padding: "10px 16px",
          borderRadius: 18,
          background: "rgba(8, 10, 16, 0.76)",
          border: "1px solid rgba(88, 126, 168, 0.45)",
          boxShadow: "0 10px 32px rgba(0, 0, 0, 0.44)",
          backdropFilter: "blur(9px)",
        }}
      >
        {toolbarItems.map((item) => {
          const isActive = placementState.activeToolId === item.id;
          return (
            <button
              key={item.id}
              type="button"
              onClick={handleToolClick(item.id)}
              style={{
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                justifyContent: "center",
                minWidth: 76,
                padding: "10px 14px 8px",
                borderRadius: 12,
                border: isActive
                  ? "1px solid rgba(160, 210, 255, 0.8)"
                  : "1px solid rgba(120, 168, 220, 0.35)",
                background: isActive ? "rgba(56, 120, 200, 0.45)" : "rgba(22, 28, 40, 0.68)",
                color: isActive ? "#e8f6ff" : "#9db6d4",
                fontFamily: "Inter, system-ui, sans-serif",
                fontSize: "13px",
                letterSpacing: "0.02em",
                cursor: "pointer",
                transition: "background 120ms ease, transform 120ms ease, border-color 120ms ease",
              }}
            >
              <span
                style={{
                  fontSize: "18px",
                  marginBottom: 6,
                }}
              >
                {item.icon}
              </span>
              <span>{item.label}</span>
              <span
                style={{
                  fontSize: "11px",
                  marginTop: 4,
                  opacity: 0.72,
                }}
              >
                [{item.hint}]
              </span>
            </button>
          );
        })}
      </div>
      <div
        ref={overlayRef}
        style={{
          position: "absolute",
          top: 16,
          right: 16,
          padding: "10px 14px",
          background: "rgba(8, 10, 16, 0.82)",
          color: "#d8f1ff",
          fontFamily: "monospace",
          fontSize: "12px",
          lineHeight: "16px",
          borderRadius: 8,
          border: "1px solid rgba(95, 136, 180, 0.45)",
          pointerEvents: "none",
          boxShadow: "0 4px 20px rgba(0, 0, 0, 0.35)",
          textShadow: "0 0 6px rgba(40, 132, 210, 0.4)",
          whiteSpace: "pre",
        }}
      />
    </div>
  );
}
</file>

<file path="src/fps/placement/lampBuilder.ts">
import { Color3, Matrix, MeshBuilder, Quaternion, Scene, StandardMaterial, Vector3 } from "babylonjs";
import { LAMP_COLOR_PALETTE, WALL_LAMP_PLACEMENT, LIGHTING_LIMITS } from "../constants";
import type { BuilderLamp, WallLampPlacement } from "../types";
import { createRectAreaLamp } from "../lighting/rectAreaLamp";

export function nextLampColor(index: number) {
  return LAMP_COLOR_PALETTE[index % LAMP_COLOR_PALETTE.length];
}

export function lampKey(placement: WallLampPlacement) {
  // Local coordinates are already snapped, so we can use them for deterministic keys.
  return `${placement.surfaceId}:${placement.local.x}:${placement.local.y}`;
}

export function createLamp(scene: Scene, placement: WallLampPlacement, color: Color3): BuilderLamp {
  const fixture = MeshBuilder.CreateBox(
    `lamp-fixture-${Date.now()}`,
    {
      width: WALL_LAMP_PLACEMENT.width,
      height: WALL_LAMP_PLACEMENT.height,
      depth: WALL_LAMP_PLACEMENT.depth,
    },
    scene,
  );

  const forwardDir = placement.forward.clone();
  const upDir = placement.up.clone();
  const rightDir = placement.right.clone();

  const basis = new Matrix();
  Matrix.FromXYZAxesToRef(rightDir, upDir, forwardDir, basis);
  const rotation = Quaternion.FromRotationMatrix(basis);

  fixture.rotationQuaternion = rotation;
  const anchoredPosition = placement.position.clone();
  fixture.position = anchoredPosition;
  fixture.isPickable = true;
  fixture.checkCollisions = false;

  const material = new StandardMaterial(`lamp-fixture-mat-${Date.now()}`, scene);
  material.diffuseColor = color.scale(0.18);
  material.specularColor = color.scale(0.24);
  material.emissiveColor = color.scale(1.18);
  material.backFaceCulling = false;
  material.maxSimultaneousLights = LIGHTING_LIMITS.maxSimultaneousLights;
  fixture.material = material;

  const lampKeyValue = lampKey(placement);
  fixture.metadata = { toolId: "lamp", key: lampKeyValue };

  const lamp = createRectAreaLamp({
    name: `lamp-${lampKeyValue}`,
    scene,
    fixture,
    position: anchoredPosition.clone(),
    right: rightDir,
    up: upDir,
    forward: forwardDir,
    areaSize: { width: WALL_LAMP_PLACEMENT.width, height: WALL_LAMP_PLACEMENT.height },
    color,
    range: WALL_LAMP_PLACEMENT.range,
    tilt: WALL_LAMP_PLACEMENT.tilt,
    twoSided: false,
    areaIntensity: WALL_LAMP_PLACEMENT.intensity * 8,
    shadowIntensity: WALL_LAMP_PLACEMENT.intensity,
    ambientIntensity: WALL_LAMP_PLACEMENT.intensity * 0.28,
    ambientRangeMultiplier: 0.7,
    ambientAttenuation: 0.52,
    shadowAngle: Math.PI / 2.35,
    shadowMapSize: WALL_LAMP_PLACEMENT.shadowMapSize,
    shadowBias: 0.00024,
    shadowNormalBias: 0.0038,
    forceBackFacesOnly: false,
    shadowMinZ: 0.008,
    areaOffset: WALL_LAMP_PLACEMENT.depth * 0.42,
    enableRsm: true,
    rsmTextureSize: 192,
    rsmNumSamples: 160,
    rsmRadius: 0.18,
    rsmIntensity: 0.22,
    rsmEdgeCorrection: 0.1,
    rsmNoiseFactor: 70,
  });
  lamp.key = lampKeyValue;
  lamp.mesh.metadata = { toolId: "lamp", key: lampKeyValue };
  lamp.color = color.clone();
  lamp.anchorSurfaceId = placement.surfaceId;
  lamp.local = { x: placement.local.x, y: placement.local.y, z: placement.local.z };
  lamp.rotation = rotation.clone();
  return lamp;
}
</file>

<file path="src/fps/core/sceneContext.ts">
import { Color3, Color4, Engine, GlowLayer, Mesh, MeshBuilder, Scene, Vector3, PBRMaterial, StandardMaterial } from "babylonjs";
import {
  GRID_SIZE,
  HULL_DIMENSIONS,
  WALL_DIMENSIONS,
  LIGHTING_LIMITS,
} from "../constants";
import type { BuilderLamp } from "../types";
import { createSurfaceRegistry } from "../placement/surfaces/surfaceRegistry";
import type { SurfaceRegistry } from "../placement/surfaces/surfaceRegistry";
import { FloorSurface } from "../placement/surfaces/floorSurface";
import { WallSurface } from "../placement/surfaces/wallSurface";
import { createRectAreaLamp } from "../lighting/rectAreaLamp";
import {
  applyHangarTextures,
  disposeHangarMaterial,
  disposeHangarTextureCache,
  getHangarTextureSet,
  type HangarTextureSet,
} from "./hangarTextures";

export interface SceneContext {
  engine: Engine;
  scene: Scene;
  glowLayer: GlowLayer;
  floor: Mesh;
  staticMeshes: Mesh[];
  structuralLamps: BuilderLamp[];
  surfaceRegistry: SurfaceRegistry;
  dispose(): void;
}

export function createSceneContext(canvas: HTMLCanvasElement): SceneContext {
  const engine = new Engine(canvas, true, {
    preserveDrawingBuffer: true,
    stencil: true,
    doNotHandleContextLost: true,
  });
  engine.disableUniformBuffers = true;

  const scene = new Scene(engine);
  scene.clearColor = new Color4(5 / 255, 6 / 255, 10 / 255, 1);
  scene.ambientColor = Color3.Black();
  scene.gravity = new Vector3(0, -9.81, 0);
  scene.collisionsEnabled = true;
  scene.imageProcessingConfiguration.toneMappingEnabled = true;
  scene.imageProcessingConfiguration.exposure = 1.08;
  scene.imageProcessingConfiguration.contrast = 1.04;

  const glowLayer = new GlowLayer("hangar-glow", scene);
  glowLayer.intensity = 0.18;

  const floorTextures = getHangarTextureSet(scene, "metal");
  const wallTextures = getHangarTextureSet(scene, "armor");

  const { floor, ceiling, walls } = buildHangar(scene, {
    floor: floorTextures,
    wall: wallTextures,
  });
  const surfaceRegistry = createSurfaceRegistry();
  surfaceRegistry.register(
    new FloorSurface({
      id: "hangar-floor",
      mesh: floor,
      up: Vector3.Up(),
      forward: new Vector3(0, 0, 1),
    }),
  );
  walls.forEach((wall) => {
    const inward = new Vector3(-wall.position.x, 0, -wall.position.z);
    if (inward.lengthSquared() < 1e-4) {
      const normal = Vector3.TransformNormal(Vector3.Forward(), wall.getWorldMatrix());
      inward.copyFrom(normal.scale(-1));
      inward.y = 0;
    }
    if (inward.lengthSquared() < 1e-4) {
      inward.copyFrom(Vector3.Forward());
    }
    surfaceRegistry.register(
      new WallSurface({
        id: wall.name ?? `wall-${wall.uniqueId}`,
        mesh: wall,
        inward,
        up: Vector3.Up(),
      }),
    );
  });
  const staticMeshes = [...walls, ceiling];
  floor.receiveShadows = true;
  floor.checkCollisions = true;
  staticMeshes.forEach((mesh) => {
    mesh.receiveShadows = true;
    mesh.checkCollisions = true;
  });

  const structuralLamps = createStructuralLamps(scene);
  structuralLamps.forEach((lamp) => {
    lamp.mesh.checkCollisions = false;
    lamp.mesh.isPickable = false;
  });

  engine.runRenderLoop(() => {
    scene.render();
  });

  const resize = () => {
    engine.resize();
  };
  window.addEventListener("resize", resize);

  const sceneContext: SceneContext = {
    engine,
    scene,
    glowLayer,
    floor,
    staticMeshes,
    structuralLamps,
    surfaceRegistry,
    dispose: () => {
      window.removeEventListener("resize", resize);
      glowLayer.dispose();
      structuralLamps.forEach((lamp) => {
        if (lamp.mesh.isDisposed()) {
          return;
        }
        lamp.shadow.dispose();
        lamp.light.dispose();
        lamp.areaLight?.dispose();
        lamp.fillLight?.dispose();
        lamp.auxiliaryLights?.forEach((aux) => aux.dispose());
        if (lamp.gi) {
          lamp.gi.solution.dispose();
          lamp.gi.rsm.dispose();
        }
        lamp.mesh.dispose(false, true);
      });
      surfaceRegistry.dispose();
      disposeHangarMaterials([floor, ceiling, ...walls]);
      disposeHangarTextureCache(scene);
      scene.dispose();
      engine.dispose();
    },
  };
  return sceneContext;
}

interface HangarAssets {
  floor: Mesh;
  ceiling: Mesh;
  walls: Mesh[];
}

function buildHangar(
  scene: Scene,
  textures: {
    floor: HangarTextureSet;
    wall: HangarTextureSet;
  },
): HangarAssets {
  const floor = createHangarFloor(scene, textures.floor);
  const ceiling = createHangarCeiling(scene, textures.floor);
  const walls = createHangarWalls(scene, textures.wall);
  return { floor, ceiling, walls };
}

function createHangarFloor(scene: Scene, textures: HangarTextureSet): Mesh {
  const subdivisionsX = Math.max(1, Math.round(HULL_DIMENSIONS.width / GRID_SIZE));
  const subdivisionsZ = Math.max(1, Math.round(HULL_DIMENSIONS.length / GRID_SIZE));

  const floor = MeshBuilder.CreateGround(
    "hangar-floor",
    {
      width: HULL_DIMENSIONS.width,
      height: HULL_DIMENSIONS.length,
      subdivisionsX,
      subdivisionsY: subdivisionsZ,
    },
    scene,
  );
  floor.position.y = 0;
  floor.metadata = { type: "ship-foundation", textureTiling: { u: 4.2, v: 6.0 } };

  const floorMaterial = new PBRMaterial("floor-pbr", scene);
  applyHangarTextures(floorMaterial, textures, (floor.metadata as { textureTiling: { u: number; v: number } }).textureTiling);
  floorMaterial.ambientTextureStrength = 0.92;
  floorMaterial.useAmbientInGrayScale = true;
  floorMaterial.metallic = 0.42;
  floorMaterial.roughness = 0.84;
  floorMaterial.microSurface = 0.86;
  floorMaterial.environmentIntensity = 0.72;
  floorMaterial.specularIntensity = 1.1;
  floorMaterial.backFaceCulling = true;
  floorMaterial.maxSimultaneousLights = LIGHTING_LIMITS.maxSimultaneousLights;
  floor.material = floorMaterial;

  return floor;
}

function createHangarCeiling(scene: Scene, textures: HangarTextureSet): Mesh {
  const subdivisionsX = Math.max(1, Math.round(HULL_DIMENSIONS.width / GRID_SIZE));
  const subdivisionsZ = Math.max(1, Math.round(HULL_DIMENSIONS.length / GRID_SIZE));

  const ceiling = MeshBuilder.CreateGround(
    "hangar-ceiling",
    {
      width: HULL_DIMENSIONS.width,
      height: HULL_DIMENSIONS.length,
      subdivisionsX,
      subdivisionsY: subdivisionsZ,
    },
    scene,
  );
  ceiling.position.y = HULL_DIMENSIONS.height;
  ceiling.rotation.x = Math.PI;
  ceiling.metadata = { type: "ship-foundation", textureTiling: { u: 3.4, v: 5.0 } };

  const ceilingMaterial = new PBRMaterial("ceiling-pbr", scene);
  applyHangarTextures(
    ceilingMaterial,
    textures,
    (ceiling.metadata as { textureTiling: { u: number; v: number } }).textureTiling,
  );
  ceilingMaterial.ambientTextureStrength = 0.85;
  ceilingMaterial.useAmbientInGrayScale = true;
  ceilingMaterial.metallic = 0.28;
  ceilingMaterial.roughness = 0.9;
  ceilingMaterial.microSurface = 0.78;
  ceilingMaterial.environmentIntensity = 0.66;
  ceilingMaterial.specularIntensity = 0.9;
  ceilingMaterial.maxSimultaneousLights = LIGHTING_LIMITS.maxSimultaneousLights;
  ceiling.material = ceilingMaterial;

  return ceiling;
}

function createHangarWalls(scene: Scene, textures: HangarTextureSet): Mesh[] {
  const halfHeight = HULL_DIMENSIONS.height / 2;
  const thickness = WALL_DIMENSIONS.thickness;
  const footingDepth = WALL_DIMENSIONS.footingDepth ?? 0;
  const wallHeight = HULL_DIMENSIONS.height + footingDepth;
  const centerY = halfHeight - footingDepth / 2;

  return [
    createHangarWall(scene, textures, {
      name: "wall-north",
      size: { width: HULL_DIMENSIONS.width, height: wallHeight, depth: thickness },
      position: new Vector3(0, centerY, -HULL_DIMENSIONS.length / 2),
      inward: new Vector3(0, 0, 1),
    }),
    createHangarWall(scene, textures, {
      name: "wall-south",
      size: { width: HULL_DIMENSIONS.width, height: wallHeight, depth: thickness },
      position: new Vector3(0, centerY, HULL_DIMENSIONS.length / 2),
      inward: new Vector3(0, 0, -1),
    }),
    createHangarWall(scene, textures, {
      name: "wall-east",
      size: { width: HULL_DIMENSIONS.length, height: wallHeight, depth: thickness },
      position: new Vector3(HULL_DIMENSIONS.width / 2, centerY, 0),
      rotationY: Math.PI / 2,
      inward: new Vector3(-1, 0, 0),
    }),
    createHangarWall(scene, textures, {
      name: "wall-west",
      size: { width: HULL_DIMENSIONS.length, height: wallHeight, depth: thickness },
      position: new Vector3(-HULL_DIMENSIONS.width / 2, centerY, 0),
      rotationY: Math.PI / 2,
      inward: new Vector3(1, 0, 0),
    }),
  ];
}

function createHangarWall(
  scene: Scene,
  textures: HangarTextureSet,
  config: {
    name: string;
    size: { width: number; height: number; depth: number };
    position: Vector3;
    inward: Vector3;
    rotationY?: number;
  },
): Mesh {
  const wall = MeshBuilder.CreateBox(
    config.name,
    {
      width: config.size.width,
      height: config.size.height,
      depth: config.size.depth,
    },
    scene,
  );

  wall.position = config.position.clone();
  if (typeof config.rotationY === "number") {
    wall.rotation.y = config.rotationY;
  }
  wall.checkCollisions = true;
  wall.isPickable = true;

  const wallMaterial = new PBRMaterial(`${config.name}-pbr`, scene);
  const footingDepth = WALL_DIMENSIONS.footingDepth ?? 0;
  const visibleHeight = config.size.height - footingDepth;
  const tileU = Math.max(config.size.width, visibleHeight) * 0.9;
  const tileV = visibleHeight * 0.95;
  applyHangarTextures(wallMaterial, textures, { u: tileU, v: tileV });
  wallMaterial.ambientTextureStrength = 0.94;
  wallMaterial.useAmbientInGrayScale = true;
  wallMaterial.metallic = 0.36;
  wallMaterial.roughness = 0.88;
  wallMaterial.microSurface = 0.8;
  wallMaterial.environmentIntensity = 0.7;
  wallMaterial.specularIntensity = 1.0;
  wallMaterial.backFaceCulling = true;
  wallMaterial.twoSidedLighting = false;
  wallMaterial.maxSimultaneousLights = LIGHTING_LIMITS.maxSimultaneousLights;
  wall.material = wallMaterial;

  const inward = config.inward.clone().normalize();
  const up = Vector3.Up();
  const existingMetadata = (wall.metadata as Record<string, unknown>) ?? {};
  wall.metadata = {
    ...existingMetadata,
    type: "ship-wall",
    lampOrientation: {
      forward: inward.asArray(),
      up: up.asArray(),
    },
    textureTiling: { u: tileU, v: tileV },
  };

  return wall;
}

function disposeHangarMaterials(meshes: Mesh[]) {
  meshes.forEach((mesh) => {
    const material = mesh.material;
    if (material instanceof PBRMaterial) {
      disposeHangarMaterial(material);
      material.dispose(false, true);
    }
  });
}

function createStructuralLamps(scene: Scene): BuilderLamp[] {
  const color = new Color3(0.6, 0.78, 1);
  const height = HULL_DIMENSIONS.height - 0.22;
  const bandDepth = 0.22;
  const bandThickness = 0.12;
  const inset = bandDepth / 2 + 0.015;
  const spanX = HULL_DIMENSIONS.width * 0.62;
  const spanZ = HULL_DIMENSIONS.length * 0.62;
  const range = Math.max(HULL_DIMENSIONS.length, HULL_DIMENSIONS.width) * 1.25;

  return [
    createWallBandLamp(scene, {
      name: "structural-light-north",
      span: spanX,
      thickness: bandThickness,
      depth: bandDepth,
      position: new Vector3(0, height, -HULL_DIMENSIONS.length / 2 + inset),
      direction: new Vector3(0, -0.45, 1),
      color,
      range,
    }),
    createWallBandLamp(scene, {
      name: "structural-light-south",
      span: spanX,
      thickness: bandThickness,
      depth: bandDepth,
      position: new Vector3(0, height, HULL_DIMENSIONS.length / 2 - inset),
      direction: new Vector3(0, -0.45, -1),
      color,
      range,
    }),
    createWallBandLamp(scene, {
      name: "structural-light-east",
      span: spanZ,
      thickness: bandThickness,
      depth: bandDepth,
      position: new Vector3(HULL_DIMENSIONS.width / 2 - inset, height, 0),
      rotationY: Math.PI / 2,
      direction: new Vector3(-1, -0.45, 0),
      color,
      range,
    }),
    createWallBandLamp(scene, {
      name: "structural-light-west",
      span: spanZ,
      thickness: bandThickness,
      depth: bandDepth,
      position: new Vector3(-HULL_DIMENSIONS.width / 2 + inset, height, 0),
      rotationY: Math.PI / 2,
      direction: new Vector3(1, -0.45, 0),
      color,
      range,
    }),
  ];
}

function createWallBandLamp(
  scene: Scene,
  config: {
    name: string;
    span: number;
    thickness: number;
    depth: number;
    position: Vector3;
    direction: Vector3;
    color: Color3;
    range: number;
    rotationY?: number;
    angle?: number;
    shadowMapSize?: number;
  },
): BuilderLamp {
  const fixture = MeshBuilder.CreateBox(
    `${config.name}-fixture`,
    {
      width: config.span,
      height: config.thickness,
      depth: config.depth,
    },
    scene,
  );

  fixture.position = config.position.clone();
  if (config.rotationY !== undefined) {
    fixture.rotation.y = config.rotationY;
  }
  fixture.isPickable = true;
  fixture.checkCollisions = false;
  fixture.metadata = {
    type: "builder-lamp",
    key: config.name,
    toolId: "lamp",
    structural: true,
  };

  const fixtureMaterial = new StandardMaterial(`${config.name}-mat`, scene);
  fixtureMaterial.diffuseColor = config.color.scale(0.18);
  fixtureMaterial.specularColor = config.color.scale(0.26);
  fixtureMaterial.emissiveColor = config.color.scale(1.12);
  fixtureMaterial.backFaceCulling = false;
  fixtureMaterial.maxSimultaneousLights = LIGHTING_LIMITS.maxSimultaneousLights;
  fixture.material = fixtureMaterial;

  const forward = Vector3.Normalize(config.direction);
  let right = Vector3.Cross(Vector3.Up(), forward);
  if (right.lengthSquared() < 1e-4) {
    right = new Vector3(1, 0, 0);
  }
  right.normalize();

  const lamp = createRectAreaLamp({
    name: config.name,
    scene,
    fixture,
    position: fixture.position.clone(),
    right,
    up: Vector3.Up(),
    forward,
    areaSize: { width: config.span, height: config.thickness },
    color: config.color,
    range: config.range,
    tilt: 0.4,
    twoSided: false,
    areaIntensity: 24,
    shadowIntensity: 1.6,
    ambientIntensity: 0.42,
    ambientRangeMultiplier: 0.76,
    ambientAttenuation: 0.58,
    shadowAngle: config.angle ?? Math.PI / 2.3,
    shadowMapSize: config.shadowMapSize ?? 1024,
    shadowBias: 0.00022,
    shadowNormalBias: 0.0035,
    forceBackFacesOnly: false,
    shadowMinZ: 0.008,
    areaOffset: config.depth * 0.45,
    enableRsm: true,
    rsmTextureSize: 256,
    rsmNumSamples: 220,
    rsmRadius: 0.24,
    rsmIntensity: 0.26,
    rsmEdgeCorrection: 0.09,
    rsmRotateSample: true,
    rsmNoiseFactor: 90,
  });
  lamp.key = config.name;
  lamp.anchorSurfaceId = config.name;
  lamp.mesh.metadata = {
    ...(lamp.mesh.metadata as Record<string, unknown> | undefined),
    type: "builder-lamp",
    key: config.name,
    toolId: "lamp",
    structural: true,
    surfaceId: config.name,
    local: { ...lamp.local },
  };
  return lamp;
}
</file>

</files>
