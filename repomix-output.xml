This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  config/
    constants.ts
  core/
    bootstrap.ts
    constants.ts
    loop.ts
  hud/
    constants.ts
    crosshair.ts
    hud.ts
    render-settings.ts
    toolbar.ts
  persistence/
    manager.ts
  player/
    input/
      fly.ts
      interactions.ts
      pointerLock.ts
    player.ts
  types/
    noa-engine.d.ts
  utils/
    seeded-random.ts
  world/
    sector/
      asteroid-field.ts
      sector.ts
      skybox.ts
      sun.ts
    config.ts
    world.ts
  main.ts
  styles.css
.gitignore
.repomixignore
index.html
package.json
tsconfig.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/core/loop.ts">
import { Engine } from 'noa-engine';

export interface TickSystem {
  id: string;
  update(dt: number): void;
}

export function initializeTickLoop(noa: Engine, systems: TickSystem[]) {
  noa.on('tick', (dt) => {
    systems.forEach((system) => {
      system.update(dt);
    });
  });
}
</file>

<file path="src/hud/constants.ts">
export const HUD_POSITION_PREFIX = 'POS';
export const HUD_BLOCK_PREFIX = 'BLOCK';

export const CROSSHAIR_STATE_IDLE = 'idle';
export const CROSSHAIR_STATE_TARGET = 'target';

export const TOOLBAR_SLOT_CLASS = 'toolbar__slot';
export const KEY_PREFIX_DIGIT = 'Digit';
</file>

<file path="src/hud/crosshair.ts">
import { CROSSHAIR_STATE_IDLE, CROSSHAIR_STATE_TARGET } from './constants';

const crosshairEl = document.querySelector<HTMLDivElement>('.crosshair');

export interface CrosshairController {
  setState(state: 'target' | 'idle'): void;
}

export function createCrosshairController(): CrosshairController {
  return {
    setState(state) {
      if (!crosshairEl) return;
      const value = state === 'target' ? CROSSHAIR_STATE_TARGET : CROSSHAIR_STATE_IDLE;
      crosshairEl.dataset.state = value;
    },
  };
}
</file>

<file path="src/hud/hud.ts">
import { HUD_BLOCK_PREFIX, HUD_POSITION_PREFIX } from './constants';

const energyEl = document.getElementById('status-energy');
const blockEl = document.getElementById('status-heat');

export interface HudController {
  updatePosition(position: [number, number, number]): void;
  updateSelected(label: string): void;
}

export function createHudController(): HudController {
  return {
    updatePosition(position) {
      if (!energyEl) return;
      energyEl.textContent = `${HUD_POSITION_PREFIX} ${position
        .map((value) => value.toFixed(1))
        .join(' ')}`;
    },
    updateSelected(label) {
      if (!blockEl) return;
      blockEl.textContent = `${HUD_BLOCK_PREFIX} ${label}`;
    },
  };
}
</file>

<file path="src/hud/toolbar.ts">
import type { BlockPaletteEntry } from '../world/world';
import { KEY_PREFIX_DIGIT, TOOLBAR_SLOT_CLASS } from './constants';

type SelectCallback = (index: number) => void;

declare global {
  interface HTMLElementEventMap {
    selectpalette: CustomEvent<number>;
  }
}

export interface ToolbarController {
  render(selectedIndex: number): void;
}

export function initializeToolbar(
  palette: BlockPaletteEntry[],
  onSelect: SelectCallback,
): ToolbarController {
  const toolbarEl = document.getElementById('toolbar');
  const buttons: HTMLButtonElement[] = [];

  if (!toolbarEl) {
    return {
      render() {
        /* noop */
      },
    };
  }

  toolbarEl.innerHTML = '';

  palette.forEach((entry, index) => {
    const button = document.createElement('button');
    button.type = 'button';
    button.className = TOOLBAR_SLOT_CLASS;
    button.dataset.index = String(index);
    button.innerHTML = `<sup>${entry.hotkey}</sup>${entry.label}`;
    button.addEventListener('click', (event) => {
      event.preventDefault();
      onSelect(index);
    });
    toolbarEl.appendChild(button);
    buttons.push(button);
  });

  window.addEventListener('keydown', (event) => {
    if (!event.code.startsWith(KEY_PREFIX_DIGIT)) return;
    const digit = Number.parseInt(event.code.replace(KEY_PREFIX_DIGIT, ''), 10);
    if (Number.isNaN(digit)) return;
    const targetIndex = palette.findIndex((entry) => entry.hotkey === String(digit));
    if (targetIndex >= 0) {
      onSelect(targetIndex);
    }
  });

  return {
    render(selectedIndex: number) {
      buttons.forEach((button, index) => {
        button.classList.toggle('is-active', index === selectedIndex);
      });
    },
  };
}
</file>

<file path="src/persistence/manager.ts">
import type { Engine } from 'noa-engine';
import { PERSISTENCE_SYSTEM_ID } from '../core/constants';

export interface BlockMutation {
  position: [number, number, number];
  type: number;
}

export interface PlayerSnapshot {
  pos: [number, number, number];
  rot: [number, number];
}

interface StoredPlayerPayload extends PlayerSnapshot {
  version: number;
  updatedAt: string;
}

interface StoredBlocksPayload {
  version: number;
  updatedAt: string;
  blocks: Record<string, number>;
}

const STORAGE_ROOT = 'starwatch.save';
const STORAGE_VERSION = 1;
const SAVE_INTERVAL_MS = 10_000;

function getNow(): number {
  if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
    return performance.now();
  }
  return Date.now();
}

function coordsKey(x: number, y: number, z: number): string {
  return `${x},${y},${z}`;
}

function approxEqual(a: number, b: number, epsilon = 0.001) {
  return Math.abs(a - b) <= epsilon;
}

function positionsEqual(
  a: [number, number, number],
  b: [number, number, number],
  epsilon = 0.001,
): boolean {
  return approxEqual(a[0], b[0], epsilon) && approxEqual(a[1], b[1], epsilon) && approxEqual(a[2], b[2], epsilon);
}

function rotationsEqual(
  a: [number, number],
  b: [number, number],
  epsilon = 0.0001,
): boolean {
  return approxEqual(a[0], b[0], epsilon) && approxEqual(a[1], b[1], epsilon);
}

function safeStringify<T>(value: T): string | null {
  try {
    return JSON.stringify(value);
  } catch (error) {
    console.warn('[Persistence] Unable to stringify value', error);
    return null;
  }
}

export class PersistenceManager {
  private readonly storage: Storage | null;

  private readonly keyPlayer: string;

  private readonly keyBlocks: string;

  private lastSaveTimestamp = getNow();

  private blockOverrides: Map<string, number> = new Map();

  private playerState: PlayerSnapshot | null = null;

  private dirtyBlocks = false;

  private dirtyPlayer = false;

  constructor(private readonly noa: Engine, private readonly sectorId: string) {
    this.storage = typeof window !== 'undefined' && window.localStorage ? window.localStorage : null;
    const baseKey = `${STORAGE_ROOT}.${sectorId}`;
    this.keyPlayer = `${baseKey}.player`;
    this.keyBlocks = `${baseKey}.blocks`;

    this.loadBlocks();
    this.loadPlayer();
  }

  getSectorId(): string {
    return this.sectorId;
  }

  getBlockOverride(x: number, y: number, z: number): number | undefined {
    return this.blockOverrides.get(coordsKey(x, y, z));
  }

  registerBlockMutation(mutation: BlockMutation) {
    const [x, y, z] = mutation.position;
    const key = coordsKey(x, y, z);
    const previous = this.blockOverrides.get(key);
    if (previous === mutation.type) {
      return;
    }
    this.blockOverrides.set(key, mutation.type);
    this.dirtyBlocks = true;
  }

  capturePlayerSnapshot() {
    const positionData = this.noa.entities.getPositionData(this.noa.playerEntity);
    const position = positionData.position.slice() as [number, number, number];
    const rotation: [number, number] = [this.noa.camera.pitch ?? 0, this.noa.camera.heading ?? 0];

    if (this.playerState) {
      if (positionsEqual(this.playerState.pos, position) && rotationsEqual(this.playerState.rot, rotation)) {
        return;
      }
    }

    this.playerState = {
      pos: position,
      rot: rotation,
    };
    this.dirtyPlayer = true;
  }

  applyPlayerSnapshot() {
    if (!this.playerState) {
      return;
    }
    this.noa.entities.setPosition(this.noa.playerEntity, this.playerState.pos);
    this.noa.camera.pitch = this.playerState.rot[0];
    this.noa.camera.heading = this.playerState.rot[1];
  }

  flush(force = false) {
    if (!this.storage) {
      return;
    }

    if (!force && !this.dirtyBlocks && !this.dirtyPlayer) {
      return;
    }

    if (this.dirtyBlocks) {
      const payload: StoredBlocksPayload = {
        version: STORAGE_VERSION,
        updatedAt: new Date().toISOString(),
        blocks: Object.fromEntries(this.blockOverrides.entries()),
      };
      const serialized = safeStringify(payload);
      if (serialized) {
        try {
          this.storage.setItem(this.keyBlocks, serialized);
          console.log('[Persistence] Blocks saved:', this.blockOverrides.size);
          this.dirtyBlocks = false;
        } catch (error) {
          console.warn('[Persistence] Failed to persist block data', error);
        }
      }
    }

    if (this.dirtyPlayer && this.playerState) {
      const payload: StoredPlayerPayload = {
        version: STORAGE_VERSION,
        updatedAt: new Date().toISOString(),
        pos: this.playerState.pos,
        rot: this.playerState.rot,
      };
      const serialized = safeStringify(payload);
      if (serialized) {
        try {
          this.storage.setItem(this.keyPlayer, serialized);
          console.log('[Persistence] Player snapshot saved');
          this.dirtyPlayer = false;
        } catch (error) {
          console.warn('[Persistence] Failed to persist player state', error);
        }
      }
    }

    this.lastSaveTimestamp = getNow();
  }

  createTickSystem() {
    return {
      id: PERSISTENCE_SYSTEM_ID,
      update: (dt: number) => {
        this.capturePlayerSnapshot();
        const now = getNow();
        const elapsed = now - this.lastSaveTimestamp;
        let seconds = dt;
        if (dt > 5) {
          seconds = dt / 1000;
        }
        if (elapsed >= SAVE_INTERVAL_MS || seconds >= SAVE_INTERVAL_MS / 1000) {
          this.flush();
        }
      },
    };
  }

  private loadBlocks() {
    if (!this.storage) {
      return;
    }
    const raw = this.storage.getItem(this.keyBlocks);
    if (!raw) {
      return;
    }
    try {
      const payload = JSON.parse(raw) as StoredBlocksPayload;
      if (payload.version !== STORAGE_VERSION || typeof payload.blocks !== 'object') {
        return;
      }
      this.blockOverrides = new Map(
        Object.entries(payload.blocks).map(([key, value]) => [key, Number(value)]),
      );
      console.log('[Persistence] Loaded blocks:', this.blockOverrides.size);
    } catch (error) {
      console.warn('[Persistence] Failed to parse stored blocks', error);
    }
  }

  private loadPlayer() {
    if (!this.storage) {
      return;
    }
    const raw = this.storage.getItem(this.keyPlayer);
    if (!raw) {
      return;
    }
    try {
      const payload = JSON.parse(raw) as StoredPlayerPayload;
      if (payload.version !== STORAGE_VERSION) {
        return;
      }
      this.playerState = {
        pos: payload.pos,
        rot: payload.rot,
      };
      console.log('[Persistence] Loaded player snapshot');
    } catch (error) {
      console.warn('[Persistence] Failed to parse player snapshot', error);
    }
  }
}
</file>

<file path="src/player/input/fly.ts">
import { Engine } from 'noa-engine';
import { FLY_SYSTEM_ID } from '../../core/constants';

const TOGGLE_ACTION = 'toggle-fly';
const DESCEND_ACTION = 'fly-down';
const FLY_SPEED_BLOCKS = 200; // ~60 m/s with 0.3 m grid
const SMOOTHING = 8;

interface PhysicsBody {
  gravityMultiplier: number;
  velocity: [number, number, number];
  friction?: number;
}

function getPlayerBody(noa: Engine): PhysicsBody | null {
  const physics = noa.entities.getPhysics(noa.playerEntity);
  if (!physics) return null;
  return physics.body as PhysicsBody;
}

export function initializeFlightControls(noa: Engine) {
  const inputs = noa.inputs;
  inputs.bind(TOGGLE_ACTION, ['KeyF']);
  inputs.bind(DESCEND_ACTION, ['ShiftLeft', 'ControlLeft']);

  let enabled = false;
  let previousGravity = 2;

  const setFlightState = (next: boolean) => {
    const body = getPlayerBody(noa);
    if (!body) return;
    enabled = next;
    if (enabled) {
      previousGravity = body.gravityMultiplier ?? previousGravity;
      body.gravityMultiplier = 0;
      console.log('[Flight] Enabled');
    } else {
      body.gravityMultiplier = previousGravity;
      body.velocity[1] = 0;
      console.log('[Flight] Disabled');
    }
  };

  inputs.down.on(TOGGLE_ACTION, () => {
    setFlightState(!enabled);
  });

  return {
    id: FLY_SYSTEM_ID,
    update: (dt: number) => {
      const body = getPlayerBody(noa);
      if (!body) return;
      if (!enabled) return;

      body.gravityMultiplier = 0;

      const state = noa.inputs.state as Record<string, boolean>;
      const ascend = !!state.jump;
      const descend = !!state[DESCEND_ACTION];
      const targetVelocity = ascend ? FLY_SPEED_BLOCKS : descend ? -FLY_SPEED_BLOCKS : 0;
      const lerpFactor = Math.min((dt / 1000) * SMOOTHING, 1);
      body.velocity[1] = body.velocity[1] + (targetVelocity - body.velocity[1]) * lerpFactor;
    },
  };
}
</file>

<file path="src/player/input/pointerLock.ts">
import { Engine } from 'noa-engine';

export function initializePointerLock(noa: Engine) {
  const canvas = noa.container?.canvas;

  if (canvas) {
    canvas.addEventListener('click', () => {
      if (canvas.requestPointerLock) {
        canvas.requestPointerLock();
      }
    });
  }

  window.addEventListener('blur', () => {
    if (document.pointerLockElement) {
      try {
        document.exitPointerLock();
      } catch (error) {
        // ignore
      }
    }
  });
}
</file>

<file path="src/player/player.ts">
import { Engine } from 'noa-engine';
import { CreateBox } from '@babylonjs/core/Meshes/Builders/boxBuilder';
import { Vector3 } from '@babylonjs/core/Maths/math.vector';
import '@babylonjs/core/Materials/standardMaterial';

export function initializePlayer(noa: Engine) {
  const playerEntity = noa.playerEntity;
  const positionData = noa.entities.getPositionData(playerEntity);
  const scene = noa.rendering.getScene();

  const playerMesh = CreateBox('player-box', { size: 1 }, scene);
  playerMesh.scaling = new Vector3(positionData.width, positionData.height, positionData.width);
  playerMesh.material = noa.rendering.makeStandardMaterial();

  noa.entities.addComponent(playerEntity, noa.entities.names.mesh, {
    mesh: playerMesh,
    offset: [0, positionData.height / 2, 0],
  });
}
</file>

<file path="src/utils/seeded-random.ts">
const DEFAULT_SEED = 0x6d2b79f5;

function hashStringToInt(seed: string): number {
  let h = DEFAULT_SEED;
  for (let i = 0; i < seed.length; i += 1) {
    h ^= seed.charCodeAt(i);
    h = Math.imul(h, 0x5bd1e995);
    h ^= h >>> 13;
  }
  return h >>> 0;
}

export class SeededRandom {
  private state: number;

  constructor(seed: string | number) {
    const initial = typeof seed === 'number' ? seed : hashStringToInt(seed);
    this.state = initial === 0 ? DEFAULT_SEED : initial >>> 0;
  }

  next(): number {
    // Mulberry32 PRNG
    let t = (this.state += 0x6d2b79f5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }

  nextInt(minInclusive: number, maxExclusive: number): number {
    if (maxExclusive <= minInclusive) {
      return minInclusive;
    }
    const span = maxExclusive - minInclusive;
    return minInclusive + Math.floor(this.next() * span);
  }

  nextFloat(min: number, max: number): number {
    if (max <= min) {
      return min;
    }
    return min + (max - min) * this.next();
  }

  nextSigned(): number {
    return this.next() * 2 - 1;
  }

  fork(label: string | number): SeededRandom {
    const seed = typeof label === 'number' ? label : hashStringToInt(label);
    return new SeededRandom(this.state ^ seed);
  }
}

export function pseudoNoise3D(x: number, y: number, z: number, seed: number): number {
  let n = Math.imul(x, 73856093) ^ Math.imul(y, 19349663) ^ Math.imul(z, 83492791) ^ seed;
  n = Math.imul(n ^ (n >>> 13), 1274126177);
  n ^= n >>> 16;
  return (n & 0x7fffffff) / 0x3fffffff - 1;
}
</file>

<file path=".repomixignore">
MANIFESTO.md
AGENTS.md
</file>

<file path="src/config/constants.ts">
export const GRID_UNIT_METERS = 0.3;
export const PLATFORM_HALF_SIZE = 5; // results in a 10x10 platform
export const PLATFORM_BLOCK_Y = 1;

export const ENGINE_OPTIONS = {
  debug: true,
  showFPS: true,
  chunkSize: 32,
  chunkAddDistance: 1.5,
  chunkRemoveDistance: 2.1,
  playerStart: [0, 6, 0] as [number, number, number],
  clearColor: [0, 0, 0, 1] as [number, number, number, number],
};

export const DEFAULT_BLOCK_SELECTION_INDEX = 0;
</file>

<file path="src/player/input/interactions.ts">
import { Engine } from 'noa-engine';
import type { BlockMutation } from '../../persistence/manager';

type BlockResolver = () => number;

const INPUT_ACTION_FIRE = 'fire';
const INPUT_ACTION_ALT_FIRE = 'alt-fire';
const INPUT_ACTION_JUMP = 'jump';

const ALT_FIRE_BINDINGS = ['Mouse2', 'KeyE'];
const JUMP_BINDINGS = ['Space'];

export type BlockMutationHandler = (mutation: BlockMutation) => void;

export function initializeInteractions(
  noa: Engine,
  resolveBlockId: BlockResolver,
  onBlockMutation?: BlockMutationHandler,
  _setSelection?: (index: number) => void,
) {
  noa.inputs.down.on(INPUT_ACTION_FIRE, () => {
    if (!noa.targetedBlock) return;
    const [x, y, z] = noa.targetedBlock.position;
    noa.setBlock(0, x, y, z);
    onBlockMutation?.({
      position: [x, y, z],
      type: 0,
    });
  });

  noa.inputs.down.on(INPUT_ACTION_ALT_FIRE, () => {
    if (!noa.targetedBlock) return;
    const [x, y, z] = noa.targetedBlock.adjacent;
    const blockId = resolveBlockId();
    noa.setBlock(blockId, x, y, z);
    onBlockMutation?.({
      position: [x, y, z],
      type: blockId,
    });
  });

  noa.inputs.bind(INPUT_ACTION_ALT_FIRE, ALT_FIRE_BINDINGS);
  noa.inputs.bind(INPUT_ACTION_JUMP, JUMP_BINDINGS);
}
</file>

<file path="src/world/sector/asteroid-field.ts">
import { Vector3 } from '@babylonjs/core/Maths/math.vector';
import { SeededRandom, pseudoNoise3D } from '../../utils/seeded-random';
import { GRID_UNIT_METERS } from '../../config/constants';

export interface AsteroidMaterialIds {
  stone: number;
  iron: number;
  copper: number;
}

interface MaterialWeight {
  key: keyof AsteroidMaterialIds;
  weight: number;
}

interface ZoneConfig {
  id: string;
  minDistance: number; // blocks
  maxDistance: number; // blocks
  spawnProbability: number;
  radiusRange: [number, number]; // blocks
  verticalRange: [number, number]; // blocks relative to origin
  materials: MaterialWeight[];
  noiseAmplitude: [number, number];
  voidFactor: [number, number];
}

interface AsteroidCluster {
  center: Vector3;
  radius: number;
  radiusSquared: number;
  blockId: number;
  shapeSeed: number;
  noiseAmplitude: number;
  voidFactor: number;
  voidSeed: number;
}

const CHUNK_SIZE = 32;
const BLOCKS_PER_KM = 1000 / GRID_UNIT_METERS;
const CLUSTER_CELL_SIZE = 4096; // blocks (~1.2 km)

const kmToBlocks = (km: number) => Math.round(km * BLOCKS_PER_KM);

const ZONES: ZoneConfig[] = [
  {
    id: 'inner',
    minDistance: kmToBlocks(100),
    maxDistance: kmToBlocks(400),
    spawnProbability: 0.85,
    radiusRange: [kmToBlocks(0.8), kmToBlocks(2.4)],
    verticalRange: [-kmToBlocks(5), kmToBlocks(5)],
    materials: [
      { key: 'stone', weight: 0.6 },
      { key: 'copper', weight: 0.25 },
      { key: 'iron', weight: 0.15 },
    ],
    noiseAmplitude: [0.35, 0.55],
    voidFactor: [0.45, 0.65],
  },
  {
    id: 'mid',
    minDistance: kmToBlocks(400),
    maxDistance: kmToBlocks(1200),
    spawnProbability: 0.65,
    radiusRange: [kmToBlocks(1.5), kmToBlocks(4.0)],
    verticalRange: [-kmToBlocks(10), kmToBlocks(10)],
    materials: [
      { key: 'stone', weight: 0.5 },
      { key: 'iron', weight: 0.3 },
      { key: 'copper', weight: 0.2 },
    ],
    noiseAmplitude: [0.3, 0.6],
    voidFactor: [0.4, 0.6],
  },
  {
    id: 'outer',
    minDistance: kmToBlocks(1200),
    maxDistance: kmToBlocks(2000),
    spawnProbability: 0.4,
    radiusRange: [kmToBlocks(2.5), kmToBlocks(6.0)],
    verticalRange: [-kmToBlocks(15), kmToBlocks(15)],
    materials: [
      { key: 'stone', weight: 0.4 },
      { key: 'iron', weight: 0.35 },
      { key: 'copper', weight: 0.25 },
    ],
    noiseAmplitude: [0.35, 0.65],
    voidFactor: [0.4, 0.55],
  },
];

const MAX_CLUSTER_RADIUS = Math.max(...ZONES.map((zone) => zone.radiusRange[1]));

const getChunkBase = (value: number) => Math.floor(value / CHUNK_SIZE) * CHUNK_SIZE;

export class AsteroidField {
  private readonly sectorSeed: string;

  private readonly materialIds: AsteroidMaterialIds;

  private readonly chunkCache = new Map<string, AsteroidCluster[]>();

  private readonly cacheQueue: string[] = [];

  private readonly maxCacheSize = 2048;

  private readonly lastChunk: { key: string | null; clusters: AsteroidCluster[] } = {
    key: null,
    clusters: [],
  };

  constructor(materialIds: AsteroidMaterialIds, options?: { sectorSeed?: string }) {
    this.materialIds = materialIds;
    this.sectorSeed = options?.sectorSeed ?? 'sector.001';
  }

  sample(x: number, y: number, z: number): number {
    const chunkX = getChunkBase(x);
    const chunkY = getChunkBase(y);
    const chunkZ = getChunkBase(z);
    const chunkKey = `${chunkX}:${chunkY}:${chunkZ}`;

    let clusters: AsteroidCluster[];
    if (this.lastChunk.key === chunkKey) {
      clusters = this.lastChunk.clusters;
    } else {
      clusters = this.getClustersForChunk(chunkX, chunkY, chunkZ);
      this.lastChunk.key = chunkKey;
      this.lastChunk.clusters = clusters;
    }

    for (let i = 0; i < clusters.length; i += 1) {
      const cluster = clusters[i];
      const dx = x - cluster.center.x;
      const dy = y - cluster.center.y;
      const dz = z - cluster.center.z;
      const radialDistanceSquared = dx * dx + dy * dy + dz * dz;
      if (radialDistanceSquared > cluster.radiusSquared * 1.96) {
        continue;
      }
      const radialDistance = Math.sqrt(radialDistanceSquared);
      const baseRadius = cluster.radius;
      const noise = pseudoNoise3D(
        Math.floor(x * 0.2),
        Math.floor(y * 0.2),
        Math.floor(z * 0.2),
        cluster.shapeSeed,
      );
      const surfaceThreshold = baseRadius * (0.55 + noise * cluster.noiseAmplitude);
      if (radialDistance <= surfaceThreshold) {
      const voidNoise = pseudoNoise3D(x + 97, y + 211, z + 389, cluster.voidSeed);
      if (voidNoise > cluster.voidFactor) {
        return 0;
      }
      return cluster.blockId;
    }
    }

    return 0;
  }

  private getClustersForChunk(chunkX: number, chunkY: number, chunkZ: number): AsteroidCluster[] {
    const key = `${chunkX}:${chunkY}:${chunkZ}`;
    const cached = this.chunkCache.get(key);
    if (cached) {
      return cached;
    }

    const clusters: AsteroidCluster[] = [];

    const chunkMin = new Vector3(chunkX, chunkY, chunkZ);
    const chunkMax = new Vector3(chunkX + CHUNK_SIZE, chunkY + CHUNK_SIZE, chunkZ + CHUNK_SIZE);

    const cellMinX = Math.floor((chunkMin.x - MAX_CLUSTER_RADIUS) / CLUSTER_CELL_SIZE);
    const cellMaxX = Math.floor((chunkMax.x + MAX_CLUSTER_RADIUS) / CLUSTER_CELL_SIZE);
    const cellMinZ = Math.floor((chunkMin.z - MAX_CLUSTER_RADIUS) / CLUSTER_CELL_SIZE);
    const cellMaxZ = Math.floor((chunkMax.z + MAX_CLUSTER_RADIUS) / CLUSTER_CELL_SIZE);

    for (let cx = cellMinX; cx <= cellMaxX; cx += 1) {
      for (let cz = cellMinZ; cz <= cellMaxZ; cz += 1) {
        this.tryAddClusterForCell(cx, cz, chunkMin, chunkMax, clusters);
      }
    }

    this.storeInCache(key, clusters);
    return clusters;
  }

  private tryAddClusterForCell(
    cellX: number,
    cellZ: number,
    chunkMin: Vector3,
    chunkMax: Vector3,
    clusters: AsteroidCluster[],
  ) {
    const cellSeed = `${this.sectorSeed}:${cellX}:${cellZ}`;
    const random = new SeededRandom(cellSeed);
    const cellOriginX = cellX * CLUSTER_CELL_SIZE;
    const cellOriginZ = cellZ * CLUSTER_CELL_SIZE;
    const candidateX = cellOriginX + random.nextFloat(0, CLUSTER_CELL_SIZE);
    const candidateZ = cellOriginZ + random.nextFloat(0, CLUSTER_CELL_SIZE);
    const horizontalDistance = Math.sqrt(candidateX * candidateX + candidateZ * candidateZ);
    const zone = this.resolveZone(horizontalDistance);
    if (!zone) {
      return;
    }
    if (random.next() > zone.spawnProbability) {
      return;
    }

    const attempts = random.next() > 0.7 ? 2 : 1;
    for (let attempt = 0; attempt < attempts; attempt += 1) {
      const radius = random.nextFloat(zone.radiusRange[0], zone.radiusRange[1]);
      const centerY = random.nextFloat(zone.verticalRange[0], zone.verticalRange[1]);
      const center = new Vector3(candidateX + random.nextFloat(-radius, radius) * 0.2, centerY, candidateZ + random.nextFloat(-radius, radius) * 0.2);

      const minX = center.x - radius;
      const maxX = center.x + radius;
      const minY = center.y - radius;
      const maxY = center.y + radius;
      const minZ = center.z - radius;
      const maxZ = center.z + radius;

      if (maxX < chunkMin.x || minX > chunkMax.x || maxY < chunkMin.y || minY > chunkMax.y || maxZ < chunkMin.z || minZ > chunkMax.z) {
        continue;
      }

      const materialId = this.pickMaterial(zone, random);
      if (!materialId) {
        continue;
      }

      clusters.push({
        center,
        radius,
        radiusSquared: radius * radius,
        blockId: materialId,
        shapeSeed: random.nextInt(1, 2_147_483_647),
        noiseAmplitude: random.nextFloat(zone.noiseAmplitude[0], zone.noiseAmplitude[1]),
        voidFactor: random.nextFloat(zone.voidFactor[0], zone.voidFactor[1]),
        voidSeed: random.nextInt(1, 2_147_483_647),
      });
    }
  }

  private resolveZone(distance: number): ZoneConfig | null {
    for (let i = 0; i < ZONES.length; i += 1) {
      const zone = ZONES[i];
      if (distance >= zone.minDistance && distance <= zone.maxDistance) {
        return zone;
      }
    }
    return null;
  }

  private pickMaterial(zone: ZoneConfig, random: SeededRandom): number | null {
    const totalWeight = zone.materials.reduce((sum, entry) => sum + entry.weight, 0);
    let roll = random.nextFloat(0, totalWeight);
    for (let i = 0; i < zone.materials.length; i += 1) {
      const entry = zone.materials[i];
      if (roll <= entry.weight) {
        return this.materialIds[entry.key];
      }
      roll -= entry.weight;
    }
    return this.materialIds[zone.materials[zone.materials.length - 1].key] ?? null;
  }

  private storeInCache(key: string, clusters: AsteroidCluster[]) {
    this.chunkCache.set(key, clusters);
    this.cacheQueue.push(key);
    if (this.cacheQueue.length > this.maxCacheSize) {
      const oldest = this.cacheQueue.shift();
      if (oldest) {
        this.chunkCache.delete(oldest);
      }
    }
  }
}
</file>

<file path="src/world/sector/skybox.ts">
import { MeshBuilder } from '@babylonjs/core/Meshes/meshBuilder';
import { Color3, Color4 } from '@babylonjs/core/Maths/math.color';
import { DynamicTexture } from '@babylonjs/core/Materials/Textures/dynamicTexture';
import { StandardMaterial } from '@babylonjs/core/Materials/standardMaterial';
import type { Scene } from '@babylonjs/core/scene';
import type { Engine } from 'noa-engine';
import { SeededRandom } from '../../utils/seeded-random';

const SKYBOX_SIZE = 40000000; // 40,000 km in blocks
const STAR_CANVAS_SIZE = 1024;
const STAR_COUNT = 560;

const STAR_PALETTES: Array<{
  core: [number, number, number];
  mid: [number, number, number];
}> = [
  { core: [255, 244, 224], mid: [255, 196, 120] },
  { core: [230, 242, 255], mid: [130, 170, 255] },
  { core: [255, 255, 255], mid: [200, 220, 255] },
];

function colorToString([r, g, b]: [number, number, number], alpha: number): string {
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function drawStarField(texture: DynamicTexture, seed: string) {
  const ctx = texture.getContext();
  if (!ctx) {
    return;
  }

  const random = new SeededRandom(`${seed}-skybox`);

  ctx.fillStyle = '#02030a';
  ctx.fillRect(0, 0, STAR_CANVAS_SIZE, STAR_CANVAS_SIZE);

  for (let i = 0; i < STAR_COUNT; i += 1) {
    const radius = random.nextFloat(0.8, 2.2);
    const x = random.nextFloat(0, STAR_CANVAS_SIZE);
    const y = random.nextFloat(0, STAR_CANVAS_SIZE);
    const palette = STAR_PALETTES[random.nextInt(0, STAR_PALETTES.length)];
    const brightness = random.nextFloat(0.75, 1.0);

    const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
    gradient.addColorStop(0, colorToString(palette.core, 0.9 * brightness));
    gradient.addColorStop(0.35, colorToString(palette.mid, 0.35 * brightness));
    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

    ctx.fillStyle = gradient;
    ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);

    if (random.next() > 0.86) {
      // occasional bright pixel in the center
      ctx.fillStyle = colorToString(palette.core, 0.6 + 0.4 * brightness);
      ctx.fillRect(x - 0.5, y - 0.5, 1, 1);
    }
  }

  texture.update(false);
}

export class SectorSkybox {
  private readonly material: StandardMaterial;

  private readonly texture: DynamicTexture;

  private twinkleTime = 0;

  constructor(noa: Engine, scene: Scene, sectorSeed: string) {
    scene.clearColor = Color4.FromHexString('#000000ff');
    const mesh = MeshBuilder.CreateBox('sector-skybox', { size: SKYBOX_SIZE }, scene);
    mesh.isPickable = false;
    mesh.isVisible = true;
    mesh.infiniteDistance = true;
    mesh.material = this.createMaterial(scene, sectorSeed);
    mesh.applyFog = false;
    mesh.alwaysSelectAsActiveMesh = true;
    mesh.renderingGroupId = 0;
    noa.rendering.addMeshToScene(mesh, false);

    this.material = mesh.material as StandardMaterial;
    this.texture = this.material.emissiveTexture as DynamicTexture;
  }

  update(dt: number) {
    const dtSeconds = dt > 5 ? dt / 1000 : dt;
    this.twinkleTime += dtSeconds;
    const twinkle = 0.92 + 0.08 * Math.sin(this.twinkleTime * 0.7);
    this.material.emissiveColor = new Color3(0.05 * twinkle, 0.06 * twinkle, 0.09 * twinkle);
    this.texture.level = 0.85 + 0.15 * Math.sin((this.twinkleTime + 1.3) * 0.45);
  }

  private createMaterial(scene: Scene, sectorSeed: string) {
    const material = new StandardMaterial('sector-skybox-material', scene);
    material.backFaceCulling = false;
    material.disableLighting = true;
    material.specularColor = Color3.Black();
    material.diffuseColor = Color3.Black();

    const texture = new DynamicTexture(
      'sector-skybox-stars',
      {
        width: STAR_CANVAS_SIZE,
        height: STAR_CANVAS_SIZE,
      },
      scene,
      false,
    );
    drawStarField(texture, sectorSeed);

    material.emissiveTexture = texture;
    material.emissiveColor = new Color3(0.06, 0.07, 0.1);
    return material;
  }
}
</file>

<file path="src/world/config.ts">
export interface BlockDefinition {
  key: string;
  registryId: number;
  materialName: string;
  materialColor: [number, number, number];
  label: string;
  hotkey: string;
  includeInPalette?: boolean;
}

export const BLOCK_DEFINITIONS: BlockDefinition[] = [
  {
    key: 'platform-stone',
    registryId: 1,
    materialName: 'platform-stone',
    materialColor: [0.36, 0.38, 0.44],
    label: 'PLATFORM',
    hotkey: '1',
  },
  {
    key: 'construction-alloy',
    registryId: 2,
    materialName: 'construction-alloy',
    materialColor: [0.52, 0.54, 0.6],
    label: 'ALLOY',
    hotkey: '2',
  },
  {
    key: 'asteroid-stone',
    registryId: 3,
    materialName: 'asteroid-stone',
    materialColor: [0.32, 0.32, 0.36],
    label: 'ASTEROID STONE',
    hotkey: '3',
    includeInPalette: false,
  },
  {
    key: 'asteroid-iron',
    registryId: 4,
    materialName: 'asteroid-iron',
    materialColor: [0.44, 0.32, 0.26],
    label: 'ASTEROID IRON',
    hotkey: '4',
    includeInPalette: false,
  },
  {
    key: 'asteroid-copper',
    registryId: 5,
    materialName: 'asteroid-copper',
    materialColor: [0.62, 0.33, 0.18],
    label: 'ASTEROID COPPER',
    hotkey: '5',
    includeInPalette: false,
  },
];
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "preserve",
    "strict": true,
    "baseUrl": ".",
    "paths": {}
  },
  "include": ["src"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite';

export default defineConfig({
  server: {
    host: true,
    port: 5173,
  },
  preview: {
    host: true,
    port: 4173,
  },
});
</file>

<file path="src/core/constants.ts">
export const HUD_SYSTEM_ID = 'hud-updater';
export const CROSSHAIR_SYSTEM_ID = 'crosshair-updater';
export const SECTOR_SKYBOX_SYSTEM_ID = 'sector-skybox';
export const SECTOR_SUN_SYSTEM_ID = 'sector-sun';
export const PERSISTENCE_SYSTEM_ID = 'persistence-autosave';
export const FLY_SYSTEM_ID = 'flight-controller';
</file>

<file path="src/hud/render-settings.ts">
import { Engine } from 'noa-engine';
import { GRID_UNIT_METERS } from '../config/constants';

const STORAGE_KEY = 'starwatch.settings.render-distance';
const SUN_DISTANCE_STORAGE_KEY = 'starwatch.settings.sun-distance';
const SUN_SIZE_STORAGE_KEY = 'starwatch.settings.sun-size';

const DEFAULT_HORIZONTAL = 2.5;
const VERTICAL_RATIO = 0.6;
const REMOVE_OFFSET = 1;

interface StoredRenderSettings {
  horizontalChunks: number;
}

interface SunAdjustment {
  getDistance(): number;
  setDistance(distance: number): void;
  getDiameter(): number;
  setDiameter(diameter: number): void;
}

function parseStoredSettings(raw: string | null): StoredRenderSettings | null {
  if (!raw) return null;
  try {
    const parsed = JSON.parse(raw) as StoredRenderSettings;
    if (typeof parsed.horizontalChunks !== 'number' || Number.isNaN(parsed.horizontalChunks)) {
      return null;
    }
    return parsed;
  } catch (error) {
    console.warn('[RenderSettings] Failed to parse stored settings', error);
    return null;
  }
}

function clamp(value: number, min: number, max: number): number {
  return Math.min(Math.max(value, min), max);
}

function parseStoredNumber(raw: string | null): number | null {
  if (!raw) return null;
  const value = Number(raw);
  if (Number.isFinite(value)) return value;
  return null;
}

function formatWorldUnits(value: number): string {
  const meters = value * GRID_UNIT_METERS;
  if (meters >= 1000) {
    return `${(meters / 1000).toFixed(2)} km`;
  }
  return `${meters.toFixed(1)} m`;
}

export function initializeRenderSettingsDrawer(
  noa: Engine,
  chunkSize: number,
  defaults: { horizontal: number },
  sunControls?: SunAdjustment,
) {
  if (typeof window === 'undefined') return;

  const toggleButton = document.getElementById('render-settings-toggle');
  const drawer = document.getElementById('render-settings');
  const slider = document.getElementById('render-settings-distance') as HTMLInputElement | null;
  const readout = document.getElementById('render-settings-distance-readout');
  const hint = document.getElementById('render-settings-hint');
  const sunDistanceSlider = document.getElementById('render-settings-sun-distance') as HTMLInputElement | null;
  const sunDistanceReadout = document.getElementById('render-settings-sun-distance-readout');
  const sunSizeSlider = document.getElementById('render-settings-sun-size') as HTMLInputElement | null;
  const sunSizeReadout = document.getElementById('render-settings-sun-size-readout');

  if (!toggleButton || !drawer || !slider || !readout) {
    return;
  }

  const stored = parseStoredSettings(window.localStorage?.getItem(STORAGE_KEY) ?? null);
  const kmFromChunks = (chunks: number) => (chunks * chunkSize * GRID_UNIT_METERS) / 1000;

  const sliderMinChunks = Number(slider.min);
  const sliderMaxChunks = Number(slider.max);
  const HARD_MAX_CHUNKS = 120;
  const storedChunks = stored?.horizontalChunks ?? defaults.horizontal ?? DEFAULT_HORIZONTAL;
  const initialChunks = clamp(storedChunks, sliderMinChunks, Math.min(sliderMaxChunks, HARD_MAX_CHUNKS));
  slider.value = initialChunks.toString();

  const applyDistance = (horizontalChunksRaw: number) => {
    const horizontalChunks = clamp(horizontalChunksRaw, sliderMinChunks, Math.min(sliderMaxChunks, HARD_MAX_CHUNKS));
    const verticalChunks = Math.max(1, Math.round(horizontalChunks * VERTICAL_RATIO));
    const removeHorizontal = horizontalChunks + REMOVE_OFFSET;
    const removeVertical = verticalChunks + REMOVE_OFFSET;

    noa.world.setAddRemoveDistance([horizontalChunks, verticalChunks], [removeHorizontal, removeVertical]);

    const km = kmFromChunks(horizontalChunks);
    readout.textContent = `${km.toFixed(2)} km • ${horizontalChunks.toFixed(0)} chunks`;

    if (hint) {
      hint.textContent = `Vertical draw ~${verticalChunks.toFixed(0)} chunks`;
    }

    window.localStorage?.setItem(
      STORAGE_KEY,
      JSON.stringify({
        horizontalChunks,
      }),
    );
  };

  applyDistance(initialChunks);

  slider.addEventListener('input', () => {
    applyDistance(Number(slider.value));
  });

  if (sunControls && sunDistanceSlider && sunDistanceReadout) {
    const storedDistance = parseStoredNumber(window.localStorage?.getItem(SUN_DISTANCE_STORAGE_KEY) ?? null);
    const defaultDistance = sunControls.getDistance();
    const initialDistance = clamp(
      storedDistance ?? defaultDistance ?? Number(sunDistanceSlider.value),
      Number(sunDistanceSlider.min),
      Number(sunDistanceSlider.max),
    );
    const updateFarPlane = (distance: number) => {
      const scene = noa.rendering.getScene();
      const camera = scene?.activeCamera as { maxZ?: number } | undefined;
      if (!camera) return;
      const desired = Math.max(distance * 1.5, 50000);
      if (!camera.maxZ || camera.maxZ < desired) {
        camera.maxZ = desired;
      }
    };
    const applySunDistance = (distance: number) => {
      const clampedDistance = clamp(distance, Number(sunDistanceSlider.min), Number(sunDistanceSlider.max));
      sunControls.setDistance(clampedDistance);
      sunDistanceReadout.textContent = `${clampedDistance.toFixed(1)} blocks • ${formatWorldUnits(clampedDistance)}`;
      window.localStorage?.setItem(SUN_DISTANCE_STORAGE_KEY, clampedDistance.toString());
      updateFarPlane(clampedDistance);
    };
    sunDistanceSlider.value = initialDistance.toString();
    applySunDistance(initialDistance);
    sunDistanceSlider.addEventListener('input', () => {
      applySunDistance(Number(sunDistanceSlider.value));
    });
  }

  if (sunControls && sunSizeSlider && sunSizeReadout) {
    const storedDiameter = parseStoredNumber(window.localStorage?.getItem(SUN_SIZE_STORAGE_KEY) ?? null);
    const defaultDiameter = sunControls.getDiameter();
    const initialDiameter = clamp(
      storedDiameter ?? defaultDiameter ?? Number(sunSizeSlider.value),
      Number(sunSizeSlider.min),
      Number(sunSizeSlider.max),
    );
    const applySunSize = (diameter: number) => {
      const clampedDiameter = clamp(diameter, Number(sunSizeSlider.min), Number(sunSizeSlider.max));
      sunControls.setDiameter(clampedDiameter);
      sunSizeReadout.textContent = `${clampedDiameter.toFixed(1)} blocks • ${formatWorldUnits(clampedDiameter)}`;
      window.localStorage?.setItem(SUN_SIZE_STORAGE_KEY, clampedDiameter.toString());
    };
    sunSizeSlider.value = initialDiameter.toString();
    applySunSize(initialDiameter);
    sunSizeSlider.addEventListener('input', () => {
      applySunSize(Number(sunSizeSlider.value));
    });
  }

  const setDrawerState = (open: boolean) => {
    if (open) {
      drawer.classList.add('is-open');
    } else {
      drawer.classList.remove('is-open');
    }
    const expanded = drawer.classList.contains('is-open');
    toggleButton.setAttribute('aria-expanded', expanded ? 'true' : 'false');
    drawer.setAttribute('aria-hidden', expanded ? 'false' : 'true');
  };

  const toggleDrawer = () => {
    setDrawerState(!drawer.classList.contains('is-open'));
  };

  toggleButton.addEventListener('click', (event) => {
    event.preventDefault();
    event.stopPropagation();
    toggleDrawer();
  });

  document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape' && drawer.classList.contains('is-open')) {
      setDrawerState(false);
    }
  });

  document.addEventListener('click', (event) => {
    if (!drawer.classList.contains('is-open')) return;
    const target = event.target as HTMLElement;
    if (drawer.contains(target) || target === toggleButton) {
      return;
    }
    setDrawerState(false);
  });

  setDrawerState(false);
}
</file>

<file path="src/world/world.ts">
import { Engine } from 'noa-engine';
import { PLATFORM_BLOCK_Y, PLATFORM_HALF_SIZE } from '../config/constants';
import { BLOCK_DEFINITIONS, type BlockDefinition } from './config';
import type { PersistenceManager } from '../persistence/manager';
import { initializeSector, type SectorEnvironment } from './sector/sector';
import type { AsteroidField } from './sector/asteroid-field';
import { SunEntity } from './sector/sun';

export interface BlockPaletteEntry {
  id: number;
  label: string;
  hotkey: string;
}

export interface WorldContext {
  blockPalette: BlockPaletteEntry[];
  blockIds: Record<string, number>;
  systems: { id: string; update(dt: number): void }[];
  sector: SectorEnvironment;
  sun: SunEntity;
}

const WORLD_DATA_EVENT = 'worldDataNeeded';

export function initializeWorld(noa: Engine, persistence: PersistenceManager): WorldContext {
  registerMaterials(noa, BLOCK_DEFINITIONS);
  const { blockPalette, blockIds } = registerBlocks(noa, BLOCK_DEFINITIONS);

  const sectorSeed = persistence.getSectorId();
  const sectorSetup = initializeSector(noa, {
    stone: blockIds['asteroid-stone'],
    iron: blockIds['asteroid-iron'],
    copper: blockIds['asteroid-copper'],
  }, { sectorSeed });

  setupWorldGeneration(noa, blockIds, sectorSetup.field, persistence);
  return {
    blockPalette,
    blockIds,
    systems: sectorSetup.systems,
    sector: sectorSetup.environment,
    sun: sectorSetup.sun,
  };
}

function registerMaterials(noa: Engine, definitions: BlockDefinition[]) {
  definitions.forEach(({ materialName, materialColor }) => {
    noa.registry.registerMaterial(materialName, { color: materialColor });
  });
}

function registerBlocks(
  noa: Engine,
  definitions: BlockDefinition[],
): { blockPalette: BlockPaletteEntry[]; blockIds: Record<string, number> } {
  const blockPalette: BlockPaletteEntry[] = [];
  const blockIds: Record<string, number> = {};

  definitions.forEach(({ registryId, materialName, label, hotkey, includeInPalette = true, key }) => {
    const blockId = noa.registry.registerBlock(registryId, { material: materialName });
    blockIds[key] = blockId;
    if (includeInPalette) {
      blockPalette.push({
        id: blockId,
        label,
        hotkey,
      });
    }
  });

  return { blockPalette, blockIds };
}

function setupWorldGeneration(
  noa: Engine,
  blockIds: Record<string, number>,
  field: AsteroidField,
  persistence: PersistenceManager,
) {
  const platformId = blockIds['platform-stone'] ?? 0;

  noa.world.on(WORLD_DATA_EVENT, (id, data, x, y, z) => {
    for (let i = 0; i < data.shape[0]; i += 1) {
      for (let j = 0; j < data.shape[1]; j += 1) {
        for (let k = 0; k < data.shape[2]; k += 1) {
          const worldX = x + i;
          const worldY = y + j;
          const worldZ = z + k;
          const blockId = getVoxelId(worldX, worldY, worldZ, platformId, field, persistence);
          data.set(i, j, k, blockId);
        }
      }
    }

    noa.world.setChunkData(id, data);
  });
}

function withinPlatform(x: number, z: number): boolean {
  return (
    x >= -PLATFORM_HALF_SIZE &&
    x < PLATFORM_HALF_SIZE &&
    z >= -PLATFORM_HALF_SIZE &&
    z < PLATFORM_HALF_SIZE
  );
}

function getVoxelId(
  x: number,
  y: number,
  z: number,
  platformId: number,
  field: AsteroidField,
  persistence: PersistenceManager,
): number {
  const persistedBlock = persistence.getBlockOverride(x, y, z);
  if (typeof persistedBlock === 'number') {
    return persistedBlock;
  }

  if (y === PLATFORM_BLOCK_Y && withinPlatform(x, z)) {
    return platformId;
  }

  const asteroidBlock = field.sample(x, y, z);
  if (asteroidBlock > 0) {
    return asteroidBlock;
  }

  return 0;
}
</file>

<file path="src/main.ts">
import './styles.css';
import { bootstrapStarwatch } from './core/bootstrap';

const context = bootstrapStarwatch();

declare global {
  interface Window {
    starwatch?: typeof context;
  }
}

window.starwatch = context;
</file>

<file path="src/styles.css">
:root {
  color-scheme: dark;
  font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
}

* {
  box-sizing: border-box;
}

html,
body {
  margin: 0;
  padding: 0;
  height: 100%;
  overflow: hidden;
  background: radial-gradient(circle at top, #0b1423 0%, #05070f 70%);
  color: #d9e6ff;
}

#starwatch-ui {
  position: fixed;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: space-between;
  padding: 24px;
  z-index: 5;
  pointer-events: none;
}

#starwatch-controls {
  position: fixed;
  top: 24px;
  right: 24px;
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 12px;
  z-index: 8;
  pointer-events: auto;
}

.drawer-toggle {
  pointer-events: auto;
  appearance: none;
  border: 1px solid rgba(92, 132, 210, 0.6);
  background: rgba(10, 18, 30, 0.85);
  color: #dce8ff;
  font-size: 12px;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  padding: 8px 16px;
  border-radius: 999px;
  cursor: pointer;
  transition: transform 0.16s ease, border-color 0.16s ease, background 0.16s ease;
}

.drawer-toggle:hover,
.drawer-toggle:focus {
  outline: none;
  border-color: rgba(136, 176, 255, 0.85);
  background: rgba(18, 28, 44, 0.9);
  transform: translateY(-1px);
}

.drawer-toggle:active {
  transform: translateY(1px);
}

.drawer {
  pointer-events: none;
  width: 240px;
  padding: 18px;
  border-radius: 16px;
  background: rgba(6, 12, 20, 0.92);
  border: 1px solid rgba(70, 112, 188, 0.55);
  box-shadow: 0 22px 44px rgba(0, 0, 0, 0.45);
  transform: translateY(-12px) scale(0.98);
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.18s ease, transform 0.18s ease, visibility 0.18s ease;
}

.drawer.is-open {
  opacity: 1;
  visibility: visible;
  transform: translateY(0) scale(1);
  pointer-events: auto;
}

.drawer__header {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin-bottom: 12px;
  font-size: 13px;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: #cfdcfd;
}

.drawer__value {
  font-size: 11px;
  color: rgba(154, 198, 255, 0.8);
}

.drawer__field {
  display: flex;
  flex-direction: column;
  gap: 8px;
  font-size: 12px;
  color: rgba(208, 224, 255, 0.85);
  margin-bottom: 8px;
}

.drawer__field input[type='range'] {
  width: 100%;
  appearance: none;
  height: 4px;
  border-radius: 999px;
  background: rgba(64, 98, 160, 0.5);
  outline: none;
  accent-color: rgba(160, 205, 255, 0.9);
  cursor: pointer;
}

.drawer__field input[type='range']::-webkit-slider-thumb {
  appearance: none;
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: #aaceff;
  box-shadow: 0 0 0 2px rgba(32, 54, 92, 0.8);
}

.drawer__hint {
  margin: 0 0 4px 0;
  font-size: 11px;
  color: rgba(148, 200, 255, 0.7);
}

.drawer__section {
  margin: 6px 0 4px;
  font-size: 11px;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: rgba(179, 208, 255, 0.75);
}

.drawer__divider {
  height: 1px;
  width: 100%;
  margin: 10px 0;
  background: linear-gradient(90deg, rgba(40, 70, 130, 0) 0%, rgba(60, 110, 180, 0.65) 50%, rgba(40, 70, 130, 0) 100%);
}

.drawer__support {
  margin: 0;
  font-size: 10px;
  line-height: 1.4;
  color: rgba(140, 160, 196, 0.7);
}

.crosshair {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 28px;
  height: 28px;
  transform: translate(-50%, -50%);
  pointer-events: none;
}

.crosshair::before,
.crosshair::after {
  content: '';
  position: absolute;
  background: rgba(160, 190, 255, 0.9);
  border-radius: 1px;
  transition: background 0.18s ease, transform 0.18s ease;
}

.crosshair::before {
  width: 100%;
  height: 2px;
  top: 50%;
  left: 0;
  transform: translateY(-50%);
}

.crosshair::after {
  width: 2px;
  height: 100%;
  left: 50%;
  top: 0;
  transform: translateX(-50%);
}

.crosshair[data-state='target']::before,
.crosshair[data-state='target']::after {
  background: rgba(255, 138, 102, 0.95);
  transform: scale(1.05);
}

.hud-panel {
  display: flex;
  gap: 12px;
  align-self: flex-start;
  font-size: 12px;
  letter-spacing: 0.04em;
  text-transform: uppercase;
  padding: 10px 14px;
  border-radius: 8px;
  background: rgba(10, 16, 26, 0.75);
  border: 1px solid rgba(90, 134, 211, 0.35);
  box-shadow: 0 18px 36px rgba(0, 0, 0, 0.35);
  pointer-events: none;
}

.hud-panel span {
  opacity: 0.85;
}

.toolbar {
  margin-top: auto;
  margin-bottom: 20px;
  display: flex;
  gap: 14px;
  pointer-events: auto;
  background: rgba(8, 12, 20, 0.65);
  border: 1px solid rgba(80, 126, 214, 0.4);
  padding: 12px 18px;
  border-radius: 16px;
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
}

.toolbar__slot {
  position: relative;
  min-width: 70px;
  padding: 10px 14px;
  background: rgba(20, 28, 44, 0.8);
  border: 1px solid rgba(116, 164, 255, 0.35);
  color: #dce8ff;
  font-size: 12px;
  letter-spacing: 0.03em;
  text-transform: uppercase;
  border-radius: 12px;
  cursor: pointer;
  transition: transform 0.12s ease, border-color 0.12s ease, background 0.12s ease;
}

.toolbar__slot sup {
  display: block;
  font-size: 10px;
  opacity: 0.6;
  margin-bottom: 4px;
}

.toolbar__slot.is-active {
  transform: translateY(-4px);
  border-color: rgba(160, 210, 255, 0.85);
  background: linear-gradient(180deg, rgba(54, 82, 132, 0.95), rgba(22, 32, 56, 0.95));
  box-shadow: 0 8px 20px rgba(60, 140, 255, 0.35);
}

.toolbar__slot:active {
  transform: translateY(-2px);
}
</file>

<file path=".gitignore">
node_modules/
dist/
.env
docs/
noa-examples/
</file>

<file path="src/core/bootstrap.ts">
import { Engine } from 'noa-engine';
import { DEFAULT_BLOCK_SELECTION_INDEX, ENGINE_OPTIONS } from '../config/constants';
import { initializeWorld } from '../world/world';
import type { WorldContext } from '../world/world';
import { initializePlayer } from '../player/player';
import { initializePointerLock } from '../player/input/pointerLock';
import { initializeInteractions } from '../player/input/interactions';
import { initializeFlightControls } from '../player/input/fly';
import { initializeTickLoop, TickSystem } from './loop';
import { CROSSHAIR_SYSTEM_ID, HUD_SYSTEM_ID } from './constants';
import { createHudController } from '../hud/hud';
import { createCrosshairController } from '../hud/crosshair';
import { CROSSHAIR_STATE_IDLE, CROSSHAIR_STATE_TARGET } from '../hud/constants';
import { initializeToolbar } from '../hud/toolbar';
import { PersistenceManager } from '../persistence/manager';
import { initializeRenderSettingsDrawer } from '../hud/render-settings';

export interface StarwatchContext {
  noa: Engine;
  persistence: PersistenceManager;
  sector: WorldContext['sector'];
  sun: WorldContext['sun'];
}

export function bootstrapStarwatch(): StarwatchContext {
  const noa = new Engine(ENGINE_OPTIONS);
  const persistence = new PersistenceManager(noa, 'sector.001');

  const worldContext = initializeWorld(noa, persistence);
  initializePlayer(noa);
  persistence.applyPlayerSnapshot();
  initializePointerLock(noa);

  let selectedIndex = DEFAULT_BLOCK_SELECTION_INDEX;

  const resolveBlockId = () => worldContext.blockPalette[selectedIndex]?.id ?? 0;
  const hud = createHudController();
  const crosshair = createCrosshairController();
  const palette = worldContext.blockPalette;

  const applySelection = () => {
    const label = palette[selectedIndex]?.label ?? '---';
    hud.updateSelected(label);
    toolbar.render(selectedIndex);
  };

  const toolbar = initializeToolbar(palette, (index) => {
    if (index < 0 || index >= palette.length) return;
    selectedIndex = index;
    applySelection();
  });

  applySelection();

  initializeInteractions(noa, resolveBlockId, (mutation) => {
    persistence.registerBlockMutation(mutation);
  });

  const chunkSize = ENGINE_OPTIONS.chunkSize ?? 32;
  const horizontalDefault =
    typeof ENGINE_OPTIONS.chunkAddDistance === 'number'
      ? ENGINE_OPTIONS.chunkAddDistance
      : Array.isArray(ENGINE_OPTIONS.chunkAddDistance)
        ? ENGINE_OPTIONS.chunkAddDistance[0]
        : 2.5;
  initializeRenderSettingsDrawer(noa, chunkSize, { horizontal: horizontalDefault }, worldContext.sun);

  const flightSystem = initializeFlightControls(noa);

  const systems: TickSystem[] = [
    ...worldContext.systems,
    flightSystem,
    {
      id: HUD_SYSTEM_ID,
      update: () => {
        const position = noa.entities.getPositionData(noa.playerEntity).position;
        hud.updatePosition(position);
      },
    },
    {
      id: CROSSHAIR_SYSTEM_ID,
      update: () => {
        crosshair.setState(noa.targetedBlock ? CROSSHAIR_STATE_TARGET : CROSSHAIR_STATE_IDLE);
      },
    },
    persistence.createTickSystem(),
  ];

  initializeTickLoop(noa, systems);

  return { noa, persistence, sector: worldContext.sector, sun: worldContext.sun };
}
</file>

<file path="src/types/noa-engine.d.ts">
declare module 'noa-engine' {
  export interface EngineOptions {
    [key: string]: unknown;
  }

  export interface TargetedBlock {
    position: [number, number, number];
    adjacent: [number, number, number];
  }

  export interface World {
    on(event: 'worldDataNeeded', handler: (id: string, data: any, x: number, y: number, z: number) => void): void;
    setChunkData(id: string, data: any): void;
    setAddRemoveDistance(addDist?: number | [number, number], remDist?: number | [number, number]): void;
  }

  export interface Inputs {
    down: {
      on(event: string, handler: (event: any) => void): void;
    };
    bind(action: string, bindings: string | string[]): void;
    pointerLock(): void;
    exitPointerLock(): void;
    state: Record<string, boolean>;
  }

  export interface Entities {
    names: {
      mesh: string;
    };
    getPositionData(id: number): {
      position: [number, number, number];
      width: number;
      height: number;
    };
    addComponent(id: number, name: string, data: any): void;
    setPosition(id: number, position: [number, number, number]): void;
    getPhysics(id: number): { body: any } | null;
  }

  export interface Rendering {
    getScene(): any;
    makeStandardMaterial(options?: Record<string, unknown>): any;
    addMeshToScene(mesh: any, isStatic?: boolean): void;
  }

  export interface Camera {
    heading: number;
    pitch: number;
  }

  interface Container {
    canvas: HTMLCanvasElement;
  }

  export class Engine {
    constructor(options?: EngineOptions);
    world: World;
    registry: any;
    rendering: Rendering;
    inputs: Inputs;
    entities: Entities;
    playerEntity: number;
    targetedBlock: TargetedBlock | null;
    container: Container;
    camera: Camera;
    on(event: string, handler: (dt: number) => void): void;
    setBlock(id: number, x: number, y: number, z: number): void;
    globalToLocal(position: [number, number, number], store?: any, out?: number[]): number[];
    localToGlobal(position: [number, number, number], store?: any, out?: number[]): number[];
  }
}
</file>

<file path="src/world/sector/sector.ts">
import { Vector3 } from '@babylonjs/core/Maths/math.vector';
import type { Engine } from 'noa-engine';
import { Scene } from '@babylonjs/core/scene';
import type { FreeCamera } from '@babylonjs/core/Cameras/freeCamera';
import { SectorSkybox } from './skybox';
import { SunEntity, DEFAULT_SUN_DISTANCE_BLOCKS } from './sun';
import { AsteroidField, AsteroidMaterialIds } from './asteroid-field';
import { SECTOR_SKYBOX_SYSTEM_ID, SECTOR_SUN_SYSTEM_ID } from '../../core/constants';

export interface SectorTickSystem {
  id: string;
  update(dt: number): void;
}

export interface SectorEnvironment {
  getSolarFactor(): number;
  getSunPosition(): Vector3;
}

interface SectorOptions {
  sectorSeed: string;
  sunPosition: Vector3;
}

const DEFAULT_SECTOR_OPTIONS: SectorOptions = {
  sectorSeed: 'sector.001',
  sunPosition: new Vector3(DEFAULT_SUN_DISTANCE_BLOCKS, 0, 0),
};

class SolarRadiation implements SectorEnvironment {
  private solarFactor = 0;

  private lastLoggedFactor = -1;

  constructor(private readonly noa: Engine, private readonly sun: SunEntity) {}

  update() {
    const playerData = this.noa.entities.getPositionData(this.noa.playerEntity);
    const [px, py, pz] = playerData.position;
    const sunPosition = this.sun.getPosition();

    const dx = sunPosition.x - px;
    const dy = sunPosition.y - py;
    const dz = sunPosition.z - pz;
    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
    const clampedDistance = Math.max(distance, 1);
    const factor = 1 / (clampedDistance * clampedDistance);
    this.solarFactor = factor;

    if (Math.abs(factor - this.lastLoggedFactor) > 0.05) {
      console.log(
        `[Sector] solar factor updated -> ${factor.toFixed(3)} (distance ${clampedDistance.toFixed(1)})`,
      );
      this.lastLoggedFactor = factor;
    }
  }

  getSolarFactor(): number {
    return this.solarFactor;
  }

  getSunPosition(): Vector3 {
    return this.sun.getPosition();
  }
}

export interface SectorSetupResult {
  field: AsteroidField;
  systems: SectorTickSystem[];
  environment: SectorEnvironment;
  sun: SunEntity;
}

export function initializeSector(
  noa: Engine,
  materialIds: AsteroidMaterialIds,
  options?: Partial<SectorOptions>,
): SectorSetupResult {
  const mergedOptions = { ...DEFAULT_SECTOR_OPTIONS, ...options };
  const scene = noa.rendering.getScene() as Scene;
  scene.fogMode = Scene.FOGMODE_NONE;
  scene.fogEnabled = false;
  scene.fogDensity = 0;
  const camera = scene.activeCamera as FreeCamera | null;
  if (camera) {
    const desiredMaxZ = Math.max(50000, DEFAULT_SUN_DISTANCE_BLOCKS * 2);
    camera.maxZ = desiredMaxZ;
  }

  const skybox = new SectorSkybox(noa, scene, mergedOptions.sectorSeed);
  const sun = new SunEntity(noa, scene, mergedOptions.sunPosition);
  const field = new AsteroidField(materialIds, {
    sectorSeed: mergedOptions.sectorSeed,
  });
  const solarRadiation = new SolarRadiation(noa, sun);

  const systems: SectorTickSystem[] = [
    {
      id: SECTOR_SKYBOX_SYSTEM_ID,
      update: (dt) => {
        skybox.update(dt);
      },
    },
    {
      id: SECTOR_SUN_SYSTEM_ID,
      update: (dt) => {
        sun.update(dt);
        solarRadiation.update();
      },
    },
  ];

  return {
    field,
    systems,
    environment: solarRadiation,
    sun,
  };
}
</file>

<file path="src/world/sector/sun.ts">
import { MeshBuilder } from '@babylonjs/core/Meshes/meshBuilder';
import { StandardMaterial } from '@babylonjs/core/Materials/standardMaterial';
import { Color3 } from '@babylonjs/core/Maths/math.color';
import { PointLight } from '@babylonjs/core/Lights/pointLight';
import { GlowLayer } from '@babylonjs/core/Layers/glowLayer';
import { Vector3 } from '@babylonjs/core/Maths/math.vector';
import type { Scene } from '@babylonjs/core/scene';
import type { Engine } from 'noa-engine';
import { Mesh } from '@babylonjs/core/Meshes/mesh';
import { GRID_UNIT_METERS } from '../../config/constants';

const BLOCKS_PER_KM = 1000 / GRID_UNIT_METERS;

export const SUN_BASE_DIAMETER = 4;
export const DEFAULT_SUN_DISTANCE_BLOCKS = Math.round(1000 * BLOCKS_PER_KM); // ≈1 000 km
export const DEFAULT_SUN_DIAMETER_BLOCKS = Math.round(90 * BLOCKS_PER_KM); // ≈90 km
const SUN_GLOW_INTENSITY = 1.6;
const SUN_LIGHT_INTENSITY = 1.2;
const SUN_LIGHT_RANGE = 90;
const MIN_DIAMETER = 0.5;
const MIN_DISTANCE = 1;
const MAX_GLOW_SCALE = 4;

export class SunEntity {
  private readonly noa: Engine;

  private readonly mesh: Mesh;

  private readonly glow: GlowLayer;

  private readonly light: PointLight;

  private pulseTime = 0;

  private readonly direction: Vector3;

  private currentDistance: number;

  private currentDiameter: number;

  private readonly baseGlowIntensity = SUN_GLOW_INTENSITY;

  private readonly baseLightRange = SUN_LIGHT_RANGE;

  private readonly baseLightIntensity = SUN_LIGHT_INTENSITY;

  private readonly globalPosition: Vector3;

  constructor(noa: Engine, scene: Scene, position: Vector3) {
    this.noa = noa;
    this.mesh = MeshBuilder.CreateSphere('sector-sun', { diameter: SUN_BASE_DIAMETER, segments: 24 }, scene);
    this.mesh.position = position.clone();
    this.mesh.billboardMode = Mesh.BILLBOARDMODE_ALL;
    this.mesh.alwaysSelectAsActiveMesh = true;
    this.mesh.isPickable = false;
    this.mesh.applyFog = false;
    this.mesh.renderingGroupId = 1;
    this.mesh.isVisible = true;
    this.mesh.alwaysSelectAsActiveMesh = true;
    this.mesh.doNotSyncBoundingInfo = false;
    noa.rendering.addMeshToScene(this.mesh, false);

    const material = new StandardMaterial('sector-sun-material', scene);
    material.disableLighting = true;
    material.emissiveColor = new Color3(1.0, 0.2, 0.9);
    material.alpha = 0.9;
    material.specularColor = Color3.Black();
    this.mesh.material = material;
    this.mesh.refreshBoundingInfo();

    this.light = new PointLight('sector-solar-light', position.clone(), scene);
    this.light.intensity = SUN_LIGHT_INTENSITY;
    this.light.range = SUN_LIGHT_RANGE;
    this.light.diffuse = new Color3(1.0, 0.4, 0.8);
    this.light.specular = new Color3(1.0, 0.4, 0.8);

    this.glow = new GlowLayer('sector-sun-glow', scene, {
      blurKernelSize: 64,
    });
    this.glow.intensity = SUN_GLOW_INTENSITY;
    this.glow.addIncludedOnlyMesh(this.mesh);

    const initialDirection = position.clone();
    if (initialDirection.length() < 0.001) {
      initialDirection.set(0, 1, 0);
    }
    initialDirection.normalize();
    this.direction = initialDirection;
    this.currentDistance = position.length();
    if (this.currentDistance < MIN_DISTANCE) {
      this.currentDistance = MIN_DISTANCE;
    }

    this.currentDiameter = SUN_BASE_DIAMETER;
    this.globalPosition = position.clone();
    const initialDistance = position.length() < MIN_DISTANCE ? DEFAULT_SUN_DISTANCE_BLOCKS : position.length();
    this.setDistance(initialDistance);
    this.setDiameter(DEFAULT_SUN_DIAMETER_BLOCKS);

    console.log('[Sector] SunEntity initialized at', position.toString());
  }

  update(dt: number) {
    const dtSeconds = dt > 5 ? dt / 1000 : dt;
    this.pulseTime += dtSeconds;
    const pulse = 0.9 + 0.1 * Math.sin(this.pulseTime * 1.1);
    const material = this.mesh.material as StandardMaterial;
    material.emissiveColor = new Color3(1.0 * pulse, 0.4 * pulse, 0.85 * pulse);
    this.glow.intensity = Math.min(this.baseGlowIntensity * this.getSizeScale() * pulse, this.baseGlowIntensity * MAX_GLOW_SCALE);
  }

  getPosition(): Vector3 {
    return this.mesh.position.clone();
  }

  getDistance(): number {
    return this.currentDistance;
  }

  setDistance(distance: number) {
    const clamped = Math.max(distance, MIN_DISTANCE);
    this.currentDistance = clamped;
    this.direction.scaleToRef(clamped, this.globalPosition);
    this.applyTransforms();
    this.mesh.refreshBoundingInfo();
  }

  getDiameter(): number {
    return this.currentDiameter;
  }

  setDiameter(diameter: number) {
    const clamped = Math.max(diameter, MIN_DIAMETER);
    this.currentDiameter = clamped;
    const scale = clamped / SUN_BASE_DIAMETER;
    this.mesh.scaling.setAll(scale);
    const rangeScale = Math.max(scale, 0.2);
    const intensityScale = Math.min(Math.max(scale, 0.2), 50);
    this.light.range = Math.min(this.baseLightRange * rangeScale, this.baseLightRange * 100000);
    this.light.intensity = this.baseLightIntensity * intensityScale;
    this.mesh.refreshBoundingInfo();
  }

  private getSizeScale(): number {
    return this.currentDiameter / SUN_BASE_DIAMETER;
  }

  private applyTransforms() {
    const globalArray = this.globalPosition.asArray();
    const localPosition = this.noa.globalToLocal(globalArray, null, []);
    const [lx, ly, lz] = localPosition as [number, number, number];
    this.mesh.position.set(lx, ly, lz);
    this.light.position.set(lx, ly, lz);
  }
}
</file>

<file path="index.html">
<!doctype html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Starwatch — Prototype</title>
    <link rel="stylesheet" href="/src/styles.css" />
  </head>
  <body>
    <div id="starwatch-ui">
      <div class="crosshair" data-state="idle"></div>
      <div class="hud-panel">
        <span id="status-energy">POS 0 0 0</span>
        <span id="status-heat">BLOCK ROCK</span>
      </div>
      <div class="toolbar" id="toolbar"></div>
    </div>
    <div id="starwatch-controls">
      <button
        id="render-settings-toggle"
        class="drawer-toggle"
        type="button"
        aria-expanded="false"
      >
        Setor
      </button>
      <div id="render-settings" class="drawer" aria-hidden="true">
        <header class="drawer__header">
          <span>Render Distance</span>
          <span id="render-settings-distance-readout" class="drawer__value">0.0 chunks</span>
        </header>
        <label class="drawer__field" for="render-settings-distance">
          <span>Horizonte</span>
          <input
            id="render-settings-distance"
            type="range"
            min="1"
            max="40"
            step="1"
            value="16"
          />
        </label>
        <p id="render-settings-hint" class="drawer__hint"></p>
        <div class="drawer__divider"></div>
        <header class="drawer__section">
          <span>Solar Controls</span>
        </header>
        <label class="drawer__field" for="render-settings-sun-distance">
          <span>Sun Distance</span>
          <input
            id="render-settings-sun-distance"
            type="range"
            min="2"
            max="8000000"
            step="500"
            value="3333333"
          />
        </label>
        <p id="render-settings-sun-distance-readout" class="drawer__hint"></p>
        <label class="drawer__field" for="render-settings-sun-size">
          <span>Sun Diameter</span>
          <input
            id="render-settings-sun-size"
            type="range"
            min="0.5"
            max="1000000"
            step="10"
            value="300000"
          />
        </label>
        <p id="render-settings-sun-size-readout" class="drawer__hint"></p>
        <p class="drawer__support">
          Distâncias maiores mostram clusters mais distantes, mas podem custar FPS.
        </p>
      </div>
    </div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "starwatch",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "start": "vite",
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "sandbox": "vite --config sandbox/vite.config.ts"
  },
  "dependencies": {
    "@babylonjs/core": "^6.1.0",
    "babylonjs-inspector": "^5.14.1",
    "noa-engine": "^0.33.0",
    "repomix": "^1.8.0",
    "voxel-crunch": "^0.2.1"
  },
  "devDependencies": {
    "typescript": "^5.9.3",
    "vite": "^5.4.21"
  }
}
</file>

</files>
